<html>
    <head>
        <script src="https://arnaudbuchholz.github.io/gpf/0.2.5/gpf.js"></script>
        <script>var allowedGlobals = ["myApi"];</script>
        <script src="challenge.js"></script>
        <style>.definition {display: none;}</style>
    </head>
    <body>
        <div class="definition description">
Consider the sample code below.

This pattern is used to inject a [polyfill](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill)
of an API when the native implementation does not exist *(here the API to inject is myApi but it could be
[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise))*.
Very often, the scripting host offers a keyword that gives access to the global scope (such as
[window](https://developer.mozilla.org/en-US/docs/Web/API/Window) in browsers or
[global](https://nodejs.org/api/globals.html#globals_global) in [NodeJS](https://nodejs.org/)).

But what happens if such a keyword does not exist (as in [Nashorn](https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29))
or it is made unavailable on purpose *(check the source code of this exercise)*?

Rules are:
* You can only type code in the <strong>your_solution_here</strong> placeholder, use the field below and press Submit to test it
* The solution does not require any external library and should work for any host
        </div>
        <div class="definition source">
  "use strict";

(function () {

    var globalScope = your_solution_here;

    assert("function" === typeof globalScope.Promise);

    if (!globalScope.myApi) {
        globalScope.myApi = function () {
            assert(true);
        };
    }

}());

myApi();
        </div>
    </body>
</html>
