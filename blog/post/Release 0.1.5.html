<script src="../../../../Downloads/noUiSlider.9.0.0/nouislider.min.js"></script>
<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    Release 0.1.5
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/release.png" align="left">
    This new release delivers clean foundation to build the library in a proper (and faster?) way.
    In this article, I will detail all the tooling that were built and what is the road map
    for the next releases.
</div>
<code class="markdown">
## It's finally out !

Almost two years ago, I was experimenting [NPM publication](https://docs.npmjs.com/cli/publish) and the
version [0.1.4](https://www.npmjs.com/package/gpf-js) went out.

At that time, I had no clear road map or even a vision of what I wanted to do with the
[GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js).
Long story short, I was trying to consolidate my JavaScript know-how in order to re-create (in a better way) a library
that I started in a previous company.

If you check the [package.json history](https://github.com/ArnaudBuchholz/gpf-js/commits/master/package.json),
version 0.1.5 'officially' started on [November 26th, 2015](https://github.com/ArnaudBuchholz/gpf-js/commit/
f117eb8ba9f0c7aaf08ce65fb3c893e2b01e322b). This was after I added some [grunt packages](https://www.npmjs.com/) to
automate linting ([jshint](https://www.npmjs.com/package/grunt-contrib-jshint) and
[ESlint](https://www.npmjs.com/package/grunt-eslint)) as well as testing (mocha
[1](https://www.npmjs.com/package/grunt-mocha), [2](https://www.npmjs.com/package/grunt-mocha-test)
and istanbul [1](https://www.npmjs.com/package/grunt-istanbul),
[2] (https://www.npmjs.com/package/grunt-istanbul-coverage)).

Clearly, the goal shifted from coding to automating, testing and checking quality.
And that probably explains why I needed a full year to achieve this version.

## What's inside?

Well... that's embarrassing but... almost nothing.
Indeed, if you check the [documentation](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/index.html), only
[few functions](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/gpf.html) and one
[class](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/gpf.Error.html) are available for now.

![That's suspicious](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/futurama-suspicious.jpg)

At least, the library provides a
[compatibility layer](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/tutorial-COMPATIBILITY.html) for all
[supported environments](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/tutorial-LOADING.html).

But, still, you might wonder: what did I spend my year on?

To put it in a nutshell, I focused more on the how than on the what.

## From Grunt command line to Web interface

[Grunt](http://gruntjs.com/) has been implemented to automate lots of tasks.

When I use grunt --help, the following commands are listed:
`    concurrent  Run grunt tasks concurrently *
       connect  Start a connect web server. *
          copy  Copy files. *
        jshint  Validate files with JSHint. *
        uglify  Minify files with UglifyJS. *
         watch  Run predefined tasks whenever watched files change.
        eslint  Validate files with ESLint *
          exec  Execute shell commands. *
      htmllint  HTML5 linter and validator. *
    instrument  instruments a file or a directory tree
   reloadTasks  override instrumented tasks
 storeCoverage  store coverage from global
    makeReport  make coverage report
      coverage  check coverage thresholds *
         jsdoc  Generates source documentation using jsdoc *
         mocha  Run Mocha unit tests in a headless PhantomJS instance. *
     mochaTest  Run node unit tests with Mocha *
        notify  Show an arbitrary notification whenever you need. *
  notify_hooks  Config the automatic notification hooks.
        chrome  Alias for "connectIf", "exec:testChromeVerbose" tasks.
       firefox  Alias for "connectIf", "exec:testFirefoxVerbose" tasks.
            ie  Alias for "connectIf", "exec:testIeVerbose" tasks.
         check  Alias for "exec:globals", "concurrent:linters",
                "concurrent:quality", "exec:metrics" tasks.
     connectIf  Run connect if not detected
       default  Alias for "serve" task.
 fixInstrument  Custom task.
      istanbul  Alias for "instrument", "fixInstrument", "copy:sourcesJson",
                "mochaTest:coverage", "storeCoverage", "makeReport", "coverage"
                tasks.
          make  Alias for "exec:version", "check", "jsdoc:public", "connectIf",
                "concurrent:source", "exec:buildDebug", "exec:buildRelease",
                "uglify:buildRelease", "exec:fixUglify", "concurrent:debug",
                "concurrent:release", "uglify:buildTests",
                "copy:publishVersionPlato", "copy:publishVersion",
                "copy:publishVersionDoc", "copy:publishTest" tasks.
         plato  Alias for "copy:getPlatoHistory", "exec:plato" tasks.
          node  Custom task.
       phantom  Custom task.
         rhino  Custom task.
       wscript  Custom task.
     pre-serve  Custom task.
         serve  Alias for "pre-serve", "connect:server", "watch" tasks.`

(...) The exec task has also 27 configurations...

As I am too lazy to remember (or even type) all the grunt tasks, I decided to create a small web interface that would
offer me all the commands I need in one click.

When you install the project and run grunt (see [readme](https://github.com/ArnaudBuchholz/gpf-js#setup)),
a browser will pop to display this page:

![Welcome page](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/Welcome.png)

(...) It will be empty at first but [this will be improved](https://github.com/ArnaudBuchholz/gpf-js/issues/114).

The magic happens when you click the buttons or links.
They are simple hyperlinks to URL like: <pre>http://localhost:8000/grunt/make</pre>
This one triggers the grunt task named make.

While being executed in the background, any output generated by the task is parsed for formatting and sent back
to the browser. As a result, you can trace the task execution in real time:

![grunt make](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/make.png)

If you are interested by the implementation, I added a
[middleware](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/connect-middleware/grunt.js) to the
[connect task](https://github.com/gruntjs/grunt-contrib-connect).

(...) This is not the code I am the most proud of... but it works.
I am planning to rework this code as soon as the library will offer decent parsing helpers.

## Source management

I briefly explained my issues with source management and the reason why I needed a
[template mechanism](http://gpf-js.blogspot.ca/2016/08/my-own-templates-implementation.html).
After implementing my [own template engine](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/res/tpl.js), I
created a page that allows me to quickly enable / disable sources and reorganize them (using drag &amp; drop).

The tile titled "Sources" shows the number of active source compared to the total number of sources.
If you click it, you access the list.

![Sources preview](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/sources.png)

In front of each source, you have access to:
* **Dependencies analysis**: the red bubble shows the count of sources the current one depends on and the green bubble
shows the count of sources depending on this one. Each bubble details the dependencies inside a tooltip
* **Load checkbox**: the source will be part of the library when ticked
* **Test checkbox**: it appears only if a matching test file exists and it configures if it is included in the test
suite
* **Doc checkbox**: [jsdoc](http://usejsdoc.org/) integration appeared very late, I wanted to be able to control which
files the documentation is extracted from
* **Description**: this is directly extracted from the source by searching the
[@file](http://usejsdoc.org/tags-file.html) comment

As of today, only 28 are part of the library for a total of 100 existing sources.
Indeed, because quality is measured, I was looking for an easy way to exclude files without physically remove them from
the project.

All these files accesses are implemented through another
[middleware](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/connect-middleware/fs.js) to the
[connect task](https://github.com/gruntjs/grunt-contrib-connect).
It implements basic [CRUD methods](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) on the file system.

(...) Well, Delete is not yet enabled because I didn't need it.

(...) You might also have valid concerns about security as this middleware not only allows reads but also updates.
I will add an extra path checking algorithm to make sure that only
[project files are available](https://github.com/ArnaudBuchholz/gpf-js/issues/116).
As they are backed up by git, those files can be easily restored if anything goes wrong.

As the complexity of the [sources.json](https://github.com/ArnaudBuchholz/gpf-js/commits/v0.1.5/src/sources.json) file
constantly grows, this tool rapidly demonstrated value. I recently had to re-organize the order, this was done in a
blink!

## Testing

I am constantly advocating for [Test Driven Development](http://agiledata.org/essays/tdd.html).
As a consequence, there was no way I could release this version without the necessary tooling to achieve it.

All the available environment can be tested, this is why the tile named "Environments" was created.
But I usually go with mocha &amp; my
[bdd implementation](http://gpf-js.blogspot.ca/2015/10/my-own-bdd-implementation.html) inside the browser.
So I created a second tile named "Tests".

![Mocha in a browser](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/mocha.png)
![BDD in a browser](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/bdd.png)

### Selenium

Manual testing in a browser is one thing but it is even better when it is fully automated.

So I implemented [Selenium](http://www.seleniumhq.org/) to manipulate browsers and I wrote an
[explanation to configure it](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/TESTME.md#selenium-drivers).

I had to create three helper files to deal with selenium drivers:

* [detectSelenium.js](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/detectSelenium.js): which is going over the
list of possible drivers (see [selenium.json](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/selenium.json)) and
try to instantiate each of them. As a result, a file is generated in the tmp folder and it determines what can be
used on the current host (grunt tasks will be
[dynamically generated](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/exec.js#L108-L111) from this file).

* [seleniumDriverFactory.js](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/seleniumDriverFactory.js): which is
responsible of initializing and configuring the driver for the selected browser

* Once the selenium tests are made browser-agnostic, the
[selenium.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/test/host/selenium.js) program executes the tests
and waits for the result.

This can be triggered through grunt tasks and it has been integrated in the build process (so that it fails if anything
goes wrong).

### Backward compatibility

Each release comes with several files:
* **gpf.js**: the minified library (see below to see how this version is built), version
[0.1.5](https://arnaudbuchholz.github.io/gpf/0.1.5/gpf.js)
* **gpf-debug.js**: the concatenated library (with comments), version
[0.1.5](https://arnaudbuchholz.github.io/gpf/0.1.5/gpf-debug.js)
* **test.js**: the minified concatenation of all test files, version
[0.1.5](https://arnaudbuchholz.github.io/gpf/0.1.5/tests.js)

As it is important to ensure the backward compatibility of the API, I have some
[plans](https://github.com/ArnaudBuchholz/gpf-js/issues/115) to keep track of all release
tests files in order to check them constantly.

### Developing tests

I would have some funny stories to tell about test development...

But this will be a long article so I will only give some advices learned the hard way:

* Tests are a critical part of the project. The test code must be clean and easily maintainable.
When something is broken after a modification, you will be happy if you can quickly identify the reason from the tests.

* Asynchronous testing is complex, never take any assumption on the performance of the host running your tests.
When I developed the
[timeout ones](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/test/compatibility/timeout.js),
I had some hard times understanding that the timer resolution does not allow me to consider intervals that are smaller
than 10ms. Also, I had to make sure that concurrent timeouts are triggered simultaneously.

* Testing the internal logic of the library might be necessary: the public API rely on internal helpers. This is
also true when the library supports different platforms but only one is used for code coverage (NodeJS in my case).
I decided to
[expose those internals](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/src/compatibility/timeout.js#L104-L111)
when using the source version.  A good example is the compatibility layer: NodeJS and most browsers support all the
modern API but Rhino or cscript don't. Hence, I had to develop
[tests](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/test/compatibility/timeout.js) that are capable of checking
both version (native and [polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill)).

## Code coverage

I decided to go with [istanbul](http://gotwarlost.github.io/istanbul/) for
[code coverage](https://en.wikipedia.org/wiki/Code_coverage). I also evaluated [Blanket.JS](http://blanketjs.org/)
(see my [training on JavaScript functions using stubs](https://github.com/ArnaudBuchholz/training-functions-stub)) but
the first one offers more flexibility.

The code coverage is evaluated by running the tests on the source version (see build process).

### Ignoring untested path

There are almost 41 use of
[istanbul ignore](https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md) in the sources.
For instance, the [host detection](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/src/boot.js#L160) algorithm
inside boot.js.

This comment must be followed by an explanation of its purpose. I wrote a documentation on
[this topic](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/doc/tutorials/CODESTYLE.md#code-coverage).

### Fixing instrumentation

When using the source version, the library is
[loaded](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/boot.js#L277-L293) by concatenating all the
files in one big string and evaluating it.

The way sources are instrumented by istanbul

    Had to fix the instrumented files

    https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/tasks/istanbul.js#L5-L22

## Quality with Plato

[Plato](https://github.com/es-analysis/plato) is probably the tool that

![Total/Average Lines](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/Average number of lines.png)

![Average maintainability](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/Average maintainability.png)

## Documentation

My own [jsdoc plugin](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/doc/gpf.js) to avoid repetition
An article will come soon

## Development process

The grunt default task monitors the source folder.
Modified files are immediately checked (lint) and evaluated (plato)
Will be tested soon

## Build process

The library offers three flavors:
* Source version
* debug version
* release version

The debug version is almost generated by concatenating source files and wrapping them inside
Custom debug to release process

[esprima](http://esprima.org/index.html)
[escodegen](https://github.com/estools/escodegen)

    Plan for future optimization by manipulating the AST structure

### UglifyJS and wscript

An [issue](https://github.com/mishoo/UglifyJS2/issues/1397) was open on [UglifyJS2](https://github.com/mishoo/UglifyJS2)
project

## Time management

The reason why I love GitHub is that it keeps detailed statistics on my work.

![2013](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2013.png)
![2014](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2014.png)
![2015](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2015.png)
![2016](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2016.png)

Each file is pushed individually, I estimate I require 5 minutes per push and I probably developped 300 days over the last
year. This gives me an average of 4 pushes a day i.e. almost half an hour every day. When we look the punch card we see that pushes
are distributed between the night and mid day. Usually, it is around 15 minutes after lunch and more time every two nights.

![Last year contributions](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/contributions.png)

![Punch card](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/punch card.png)


## What's next

class definition
interfaces
attributes
parsing helpers
...

</code>
<!-- Drop those two lines -->
</div>
</div>