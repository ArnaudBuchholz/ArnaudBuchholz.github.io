<script src="../../../../Downloads/noUiSlider.9.0.0/nouislider.min.js"></script>
<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    Release 0.1.5
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/release.png" align="left">
    This new release delivers clean foundation to build the library in a proper (and faster?) way.
    In this article, I will detail all the tooling that were built and what is the road map
    for the next releases.
</div>
<code class="markdown">
## It's finally out !

Almost two years ago, I was experimenting [NPM publication](https://docs.npmjs.com/cli/publish) and the
version [0.1.4](https://www.npmjs.com/package/gpf-js) went out.

At that time, I had no clear road map or even a vision of what I wanted to do with the
[GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js).
Long story short, I was trying to consolidate my JavaScript know-how in order to re-create (in a better way) a library
that I started in a previous company.

If you check the [package.json history](https://github.com/ArnaudBuchholz/gpf-js/commits/master/package.json),
version 0.1.5 'officially' started on [November 26th, 2015](https://github.com/ArnaudBuchholz/gpf-js/commit/
f117eb8ba9f0c7aaf08ce65fb3c893e2b01e322b). This was after I added some [grunt packages](https://www.npmjs.com/) to
automate linting ([jshint](https://www.npmjs.com/package/grunt-contrib-jshint) and
[ESlint](https://www.npmjs.com/package/grunt-eslint)) as well as testing (mocha
[1](https://www.npmjs.com/package/grunt-mocha), [2](https://www.npmjs.com/package/grunt-mocha-test)
and istanbul [1](https://www.npmjs.com/package/grunt-istanbul),
[2] (https://www.npmjs.com/package/grunt-istanbul-coverage)).

Clearly, the goal shifted from coding to automating, testing and checking quality.
And that probably explains why I needed a full year to achieve this version.

## What's inside?

Well... that's embarrassing but... almost nothing.
Indeed, if you check the [documentation](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/index.html), only
[few functions](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/gpf.html) and one
[class](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/gpf.Error.html) are available for now.

![That's suspicious](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/futurama-suspicious.jpg)

At least, the library provides a
[compatibility layer](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/tutorial-COMPATIBILITY.html) for all
[supported environments](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/tutorial-LOADING.html).

But, still, you might wonder: what did I spend my year on?

To put it in a nutshell, I focused more on the how than on the what.

## From Grunt command line to Web interface

[Grunt](http://gruntjs.com/) has been implemented to automate lots of tasks.

When I use grunt --help, the following commands are listed:
`    concurrent  Run grunt tasks concurrently *
       connect  Start a connect web server. *
          copy  Copy files. *
        jshint  Validate files with JSHint. *
        uglify  Minify files with UglifyJS. *
         watch  Run predefined tasks whenever watched files change.
        eslint  Validate files with ESLint *
          exec  Execute shell commands. *
      htmllint  HTML5 linter and validator. *
    instrument  instruments a file or a directory tree
   reloadTasks  override instrumented tasks
 storeCoverage  store coverage from global
    makeReport  make coverage report
      coverage  check coverage thresholds *
         jsdoc  Generates source documentation using jsdoc *
         mocha  Run Mocha unit tests in a headless PhantomJS instance. *
     mochaTest  Run node unit tests with Mocha *
        notify  Show an arbitrary notification whenever you need. *
  notify_hooks  Config the automatic notification hooks.
        chrome  Alias for "connectIf", "exec:testChromeVerbose" tasks.
       firefox  Alias for "connectIf", "exec:testFirefoxVerbose" tasks.
            ie  Alias for "connectIf", "exec:testIeVerbose" tasks.
         check  Alias for "exec:globals", "concurrent:linters",
                "concurrent:quality", "exec:metrics" tasks.
     connectIf  Run connect if not detected
       default  Alias for "serve" task.
 fixInstrument  Custom task.
      istanbul  Alias for "instrument", "fixInstrument", "copy:sourcesJson",
                "mochaTest:coverage", "storeCoverage", "makeReport", "coverage"
                tasks.
          make  Alias for "exec:version", "check", "jsdoc:public", "connectIf",
                "concurrent:source", "exec:buildDebug", "exec:buildRelease",
                "uglify:buildRelease", "exec:fixUglify", "concurrent:debug",
                "concurrent:release", "uglify:buildTests",
                "copy:publishVersionPlato", "copy:publishVersion",
                "copy:publishVersionDoc", "copy:publishTest" tasks.
         plato  Alias for "copy:getPlatoHistory", "exec:plato" tasks.
          node  Custom task.
       phantom  Custom task.
         rhino  Custom task.
       wscript  Custom task.
     pre-serve  Custom task.
         serve  Alias for "pre-serve", "connect:server", "watch" tasks.`

As I am too lazy to remember (or even type) all the grunt tasks, I decided to create a small web interface that would
offer me all the commands I need in one click.

When you install the project and run grunt
(see [readme](https://github.com/ArnaudBuchholz/gpf-js#setup)),
a browser will pop to display this page:

![Welcome page](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/Welcome.png)

It will be empty at first but [this will be improved](https://github.com/ArnaudBuchholz/gpf-js/issues/114).

The magic happens when you click the buttons or links.
They are simple hyperlinks to URL like: <pre>http://localhost:8000/grunt/make</pre>
This one triggers the grunt task named make.

While being executed in the background, any output generated by the task is parsed for formatting and sent back
to the browser. As a result, you can trace the task execution in real time:

![grunt make](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/make.png)

If you are interested by the implementation, I added a
[middleware](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/connect-middleware/grunt.js) to the
[connect task](https://github.com/gruntjs/grunt-contrib-connect).

(...) This is not the code I am the most proud of... but it works.
I am planning to rework this code as soon as the library will offer decent parsing helpers.

### Source management

I briefly explained my issues with source management and the reason why I needed a
[template mechanism](http://gpf-js.blogspot.ca/2016/08/my-own-templates-implementation.html).
After implementing my [own template engine](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/res/tpl.js), I finally
created an editor that allows me to quickly enable / disable sources and reorganize them.

The tile titled "Sources" shows the number of active source compared to the total number of sources.

![Sources preview](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/sources.png)

As of today, only 28 are part of the library for a total of 100. Indeed, because quality is measure, I wanted a way to
easily exclude files without physically remove them from the project.

### TDD

Selenium

### Quality with Plato

![Total/Average Lines](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/Average number of lines.png)

![Average maintainability](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/Average maintainability.png)

### Time management

The reason why I love GitHub is that it keeps detailed statistics on my work.

![2013](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2013.png)
![2014](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2014.png)
![2015](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2015.png)
![2016](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/2016.png)

Each file is pushed individually, I estimate I require 5 minutes per push and I probably developped 300 days over the last
year. This gives me an average of 4 pushes a day i.e. almost half an hour every day. When we look the punch card we see that pushes
are distributed between the night and mid day. Usually, it is around 15 minutes after lunch and more time every two nights.

![Last year contributions](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/contributions.png)

![Punch card](https://arnaudbuchholz.github.io/blog/post/Release%200.1.5/punch card.png)


### What's next

</code>
<!-- Drop those two lines -->
</div>
</div>