<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own templates implementation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    What do you do when you need HTML templates but you don't want to include any heavy library or framework?
    You experiment and write your own implementation... Welcome to a journey within DOM, regular expressions and
    function builders.
</div>
<code class="markdown">
## It's been a long time...

OK, I have to admit that the blog is not really active... I should probably write more often. It's not because of
[procrastination](https://en.wikipedia.org/wiki/Procrastination) but rather a
[time management issue](https://youtu.be/zhAmug6Ts6o).

A [backlog](https://github.com/ArnaudBuchholz/ArnaudBuchholz.github.io/issues?q=is%3Aopen+is%3Aissue+label%3AArticle) of
articles I would like to write is maintained and I also created a task on my
[Habitica](https://habitica.com/static/front/#?memberId=54a5210c-0e2b-4e21-b99c-ee27062f1bd6) as a reminder to fill the
blog.

So you may wonder what do I spend my time on?

A lot of personal - good and bad - events, a new [framework](http://openui5.org/) to learn and a deep code refactoring
[to improve maintainability](https://github.com/ArnaudBuchholz/gpf-js/blob/master/make/metrics.js#L158-L193) are taking
most of it.

But in between everything I still have some rare occasions of fun and I started this
[microproject](https://en.wiktionary.org/wiki/microproject) one week ago.

## The need

In [the GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js), the source and test files are organised with the help
of one special configuration file:
[sources.json](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/sources.json).
It is the [vertebral column](https://en.wikipedia.org/wiki/Vertebral_column) of the project as all the tools related to
building, testing or even documenting are based on it.

(...) Documentation generation relies on [JSDoc](http://usejsdoc.org/) and a
[grunt plugin](https://www.npmjs.com/package/grunt-jsdoc) but the code base needs some additional cleanup.
Consequently only few files are currently considered.

This JSON storage lists files and associates properties to them:
* Textual description of the source content
* Flag to know if it has a test counterpart
* Optional flag to allow documentation extraction
* Optional documentation flags that stress out the most important parts of the source (such as class implementation,
main method name...)

Because concepts are isolated as much as possible, this file quickly grew from [134 lines in April](https://github.com/
ArnaudBuchholz/gpf-js/blob/7362fbc4685b5aefecb856aa5f984f59e7497411/src/sources.json) to
[334 lines in June](https://github.com/ArnaudBuchholz/gpf-js/blob/022ae58401e7415812d443dd9963cdd71f8efc77/src/
sources.json), all entered manually (with lots of errors leading to "what is going on?",
"oh no, nothing works again...").

At some point its content deserved a little bit of [control](https://en.wikipedia.org/wiki/Control_freak) not only to
enforce the syntax but also to have a better view on what it contains.

So I decided it would be nice to develop an HTML view on this one.

## Building HTML pages

Long story short, it all started with a simple list formatting the file content.
Updating will come later.
Hence a basic [HTML page](https://github.com/ArnaudBuchholz/gpf-js/blob/master/sources.html) was created to display a
table (not really responsive but this is not required for now).

Loading the JSON file using an [AJAX request](https://github.com/ArnaudBuchholz/gpf-js/blob/master/res/xhr.js) and
iterating over its content is easy but then...

Several solution exists:

### Build HTML nodes using script

Browsers [now](http://www.newyorker.com/tech/elements/the-evolution-of-the-web-in-a-blink) offer a complete
(and standardized) API to manipulate the
[Document Object Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model).
It allows you to programmatically fill the page the same way you would do with static HTML code.

**PROS**
* Fast
* Full control on the generation
* Can be debugged

**CONS**
* Exhaustive but complex API
* Takes more time to develop
* Long code for simple output
* Code is quite cryptic and hard to evolve
* Not easily maintainable

[Code sample](http://arnaudbuchholz.github.io/blog/post/My%20own%20templates%20implementation/Code.html)
`var data = {
    title: "Code sample",
    id: "test",
    checked: "checked",
    label: "it works"
};
var h1 = document.body.appendChild(document.createElement("h1"));
h1.innerHTML = data.title;
var input = document.body.appendChild(document.createElement("input"));
input.setAttribute("id", data.id);
input.setAttribute("type", "checkbox");
input.setAttribute("checked", "");
var label = document.body.appendChild(document.createElement("label"));
label.setAttribute("for", data.id);
label.setAttribute("title", data.label);
label.innerHTML = data.label;`

Further reading:
[Introduction to the DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)

### Use a template engine

Template engines usually rely on a static description of the final output.
The documented syntax proposes placeholders to represent substitution points.
Depending on the engine, there might be several ways to inject the values.
They are designed to be fast, offer common helpers (such as enumeration) and extensive bindings (with
typing, transformation...).

**PROS**
* Quite fast (depends on the engine)
* Less code to develop
* Easy to maintain
* Rapid learning curve

**CONS**
* Each engine has its conventions and API
* Debugging

[Mustache sample](http://arnaudbuchholz.github.io/blog/post/My%20own%20templates%20implementation/Mustache.html)
`var html = Mustache.to_html(document.getElementById("tpl").innerHTML, {
    title: "Mustache sample",
    id: "test",
    checked: "checked",
    label: "it works"
});
document.body.appendChild(document.createElement("div")).innerHTML = html;`

where the template is defined as:
<code class="html">&lt;</span><span class="element">script </span><span class="attribute">id=</span><span class="value">&quot;tpl&quot; </span><span class="attribute">type=</span><span class="value">&quot;text/template&quot;</span><span class="attribute">&gt;
    &lt;</span><span class="element">h1</span><span class="attribute">&gt;{{title}}&lt;/</span><span class="element">h1</span><span class="attribute">&gt;
    &lt;</span><span class="element">input </span><span class="attribute">id=</span><span class="value">&quot;{{id}}&quot; </span><span class="attribute">type=</span><span class="value">&quot;checkbox&quot; </span><span class="attribute">{{checked}}&gt;
    &lt;</span><span class="element">label </span><span class="attribute">for=</span><span class="value">&quot;{{id}}&quot; </span><span class="attribute">title=</span><span class="value">&quot;{{label}}&quot;</span><span class="attribute">&gt;{{label}}&lt;/</span><span class="element">label</span><span class="attribute">&gt;
&lt;/</span><span class="element">script</span><span class="attribute">&gt;</span></code>

(...) A quick note about the script tag with type="text/template", it is a trick that prevents the browser to actually
execute the content of the script tag. However, it remains available for any custom coding.

Sample reference:
[mustache.js](https://github.com/janl/mustache.js)

### Use a framework

To put it in a nutshell, a framework will convert any web page into a web application: it encapsulates more than just UI
definition and behaviors.

(...) I recommend reading this
[manifesto against frameworks](http://bitworking.org/news/2014/05/zero_framework_manifesto), it draws the line between
libraries and frameworks

This being said,
[each framework](https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks) has its
own specificities but, regarding UI building, I would distinguish 2 main types:
* Widget based frameworks (ExtJS, Open UI5...): each UI element is wrapped inside a control class.
Building the interface can be done either through static descriptions (such as XML) or code.
* HTML based frameworks (AngularJS, EmberJS...): based on HTML, it is then augmented with bindings

**PROS**
* Codebase (samples, documentation...)
* Application oriented (does more than templating)

**CONS**
* Heavy
* Long learning curve
* May become a nightmare to debug if anything goes wrong
* Design may look rigid

[Angular sample](http://arnaudbuchholz.github.io/blog/post/My%20own%20templates%20implementation/Angular.html)
`var myApp = angular.module('myApp',[]);

myApp.controller('SampleController', ['$scope', function($scope) {
    $scope.title = "Angular sample";
    $scope.id="test";
    $scope.checked=true;
    $scope.label="it works";
}]);`

where the body is defined as:
<code class="html"><span class="attribute">&lt;</span><span class="element">html </span><span class="attribute">ng-app=</span><span class="value">&quot;myApp&quot;</span><span class="attribute">&gt; 
    </span><span class="comment">&lt;!-- ... --&gt;</span><span class="attribute"> 
    &lt;</span><span class="element">body </span><span class="attribute">ng-controller=</span><span class="value">&quot;SampleController&quot;</span><span class="attribute">&gt; 
        &lt;</span><span class="element">h1</span><span class="attribute">&gt;{{title}}&lt;/</span><span class="element">h1</span><span class="attribute">&gt; 
        &lt;</span><span class="element">input </span><span class="attribute">id=</span><span class="value">&quot;{{id}}&quot; </span><span class="attribute">type=</span><span class="value">&quot;checkbox&quot; </span><span class="attribute">ng-checked=</span><span class="value">&quot;checked&quot;</span><span class="attribute">&gt; 
        &lt;</span><span class="element">label </span><span class="attribute">for=</span><span class="value">&quot;{{id}}&quot; </span><span class="attribute">title=</span><span class="value">&quot;{{label}}&quot;</span><span class="attribute">&gt;{{label}}&lt;/</span><span class="element">label</span><span class="attribute">&gt; 
    &lt;/</span><span class="element">body</span><span class="attribute">&gt; 
&lt;/</span><span class="element">html</span><span class="attribute">&gt;</span></code>

Sample reference:
[Angular JS](https://angularjs.org/)

## Building a simple template engine

A framework could be used but it's just too much with regards to what has to be achieved.
And, obviously, mustache is appropriate but I would have missed an opportunity to
[learn new things](http://www.lifehack.org/articles/featured/learn-something-new-every-day.html).

Regarding the requirements, the expected benefits of my template engine are:
* Flexible and easy way to define valid HTML
* Simple textual bindings
* JavaScript injection (see below)

### The checkbox case

Most of the content to generate simply consists in replacing placeholders with text coming from the data structure
(source name, description...). It can be either as a textual node (in between elements) or as an attribute value
(like for ids...). However, an unexpected challenge appeared when it came to boolean options.

Indeed, the simpler way to represent a boolean is to use an
[input with type=checkbox](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

But the checkbox will be ticked or not depending on the presence of the checked attribute, whatever its value.

So the template engine must offer a way to alter an element definition by adding attributes.

Working on the syntax, I tried different approaches and the simplest one is the following:
    <input type="checkbox" {%%}="JAVASCRIPT CODE">

Indeed, the following one generates issues mostly because it is not a valid HTML content

    <input type="checkbox" {% JAVASCRIPT CODE %>

### The template tag

In my opinion, declaration has to be preferred over implementation,
that's probably why I use [grunt](http://gruntjs.com/) instead of [gulp](http://gulpjs.com/).
One reason is that I believe that less code means less bugs.

Furthermore, when the [parser](https://en.wikipedia.org/wiki/Parsing) already exists (the browser in our case),
this enforces the syntax and eases a little bit more the implementation.

The [template element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) tag is an HTML element that
accepts any HTML content. It is parsed but not rendered. When you access it, this DOM element looks like a document
fragment and its content can be used or altered almost like any other element.
In particular, you can access the [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
member.



...Explain $item, $index and $write

<code class="html"><span class="attribute">&lt;</span><span class="element">template </span><span class="attribute">id=</span><span class="value">&quot;tpl_row&quot;</span><span class="attribute">&gt;
    &lt;</span><span class="element">tr</span><span class="attribute">&gt;
        &lt;</span><span class="element">td</span><span class="attribute">&gt;{name}&lt;/</span><span class="element">td</span><span class="attribute">&gt;
        &lt;</span><span class="element">td</span><span class="attribute">&gt;{description}&lt;/</span><span class="element">td</span><span class="attribute">&gt;
        &lt;</span><span class="element">td</span><span class="attribute">&gt;&lt;</span><span class="element">input </span><span class="attribute">type=</span><span class="value">&quot;checkbox&quot; </span><span class="attribute">{}=</span><span class="value">&quot;
        if ($item.load) {
            return 'checked=\'true\'';
        } else {
            return '';
        }&quot;</span><span class="attribute">&gt;&lt;/</span><span class="element">td</span><span class="attribute">&gt;
        &lt;</span><span class="element">td</span><span class="attribute">&gt;&lt;</span><span class="element">input </span><span class="attribute">type=</span><span class="value">&quot;checkbox&quot; </span><span class="attribute">{}=</span><span class="value">&quot;
        if ($item.load </span><span class="s3">&amp;amp;&amp;amp;</span><span class="value"> $item.test) {
            return 'checked=\'true\'';
        } else {
            return '';
        }&quot;</span><span class="attribute">&gt;&lt;/</span><span class="element">td</span><span class="attribute">&gt;
        &lt;</span><span class="element">td</span><span class="attribute">&gt;&lt;</span><span class="element">input </span><span class="attribute">type=</span><span class="value">&quot;checkbox&quot; </span><span class="attribute">{}=</span><span class="value">&quot;
        if ($item.doc) {
        return 'checked=\'true\'';
        } else {
            return '';
        }&quot;</span><span class="attribute">&gt;&lt;/</span><span class="element">td</span><span class="attribute">&gt;
    &lt;/</span><span class="element">tr</span><span class="attribute">&gt;
&lt;/</span><span class="element">template</span><span class="attribute">&gt;</span></code>

### Tokenizing

The first version of this helper was returning a function that was not only
[tokenizing](https://en.wikipedia.org/wiki/Tokenization_%28lexical_analysis%29) the HTML of the template but also
substituting the tokens. Then I realized that it would be faster to tokenize the content first and then returning a
function doing the substitution job only. Hence I rewrote it to dynamically build the template function based on the
template (I'll come to that after).

Until recently I was not a big fan of
[regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp).
I was under the impression that they were slow and useless
because they were only telling you if a string respects a given pattern. Then I read the book
[JavaScript The Good Parts](https://www.google.ca/search?q=Javascript+the+good+parts) from
[Douglas Crockford](https://en.wikipedia.org/wiki/Douglas_Crockford) and the chapter 7 was an eye opener.
Indeed, on top of matching a pattern it can also extract specific information from it using capturing groups
(parenthesis).

... So I created 3 patterns ... that I combine with | and a final matching all

https://regex101.com/?regex=\{([a-zA-Z_][a-zA-Z_0-9]+)\}#javascript

### Code generation

I have a real fascination for the process of generating code: the outcome is most of the time faster than the
traditional way of doing things because it produces highly specialized functions.

There are two ways to generate code:
- [eval](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [Function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

(...) There are other ways which are more elaborated such as loading dynamically generated sources either by inserting a
new script tag whose content is generated or by loading a script from a
[data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs). But let's keep things simple.

In general eval is a bad idea: it merges the content withing the global scope and it is an open door for code injection.
[Strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) brings some security
mechanisms but most linters will reject it anyway. And I agree: eval is evil.

On the other hand, the Function constructor builds the function in a isolated scope.

### Testing

</code>
<!-- Drop those two lines -->
</div>
</div>
