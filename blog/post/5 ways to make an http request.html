<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<!--
    5 ways to make an http request in JavaScript

    ...And the 5th is shocking :-)

-->
<h3 class="post-title entry-title">
    5 ways to make an http request
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The version 0.2.1 of the GPF-JS library delivers an HTTP request helper that can be used on all supported hosts.
    It was quite a challenge as it implied 5 different developments, here are the details.
</div>
<code class="markdown">

## The need for HTTP requests

In a world of [interoperability](https://en.wikipedia.org/wiki/Interoperability),
[internet of things](https://en.wikipedia.org/wiki/Internet_of_things) and
[microservices](https://en.wikipedia.org/wiki/Microservices), the - almost 30 years old -
[HTTP protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) defines a communication medium that is widely
known and implemented.

Originally designed for human-to-machine communication, this protocol also supports machine-to-machine communication
through standardized concepts and interfaces:
* Representational state transfer APIs ([REST](https://en.wikipedia.org/wiki/Representational_state_transfer))
* [Web services](https://en.wikipedia.org/wiki/Web_service)
* [OData](http://www.odata.org/)
* [JSONP](https://en.wikipedia.org/wiki/JSONP) (or [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing))
...

### Evolution of HTTP requests in browsers

[Web browsers](https://en.wikipedia.org/wiki/Web_browser) were the first applications implementing this protocol to
access the [World Wide Web](https://en.wikipedia.org/wiki/World_Wide_Web).

Before [AJAX](https://en.wikipedia.org/wiki/Ajax_%28programming%29) was conceptualized, web pages had to be fully
refreshed from the server to reflect any change. From a user experience point of view, it was OK (mostly because we had
no other choices) but this limited the development of user interfaces.

Then AJAX introduced new ways to design web pages: only the new information could be fetched from the server without
reloading the page. As a consequence, the pages were faster, crisper and fully asynchronous.

However, each browser had its own implementation of AJAX requests (not mentioning DOM, event handling and other
incompatibilities). And that's why [jQuery](https://jquery.com/), which was initially designed to offer a uniform API
that would work identically on any browser, became so popular.

Today, the situation has changed: almost all browsers are implementing the same APIs and, consequently, modern
libraries are considering browsers to be one environment only.

### GPF-JS

[GPF-JS](https://www.npmjs.com/package/gpf-js) obviously supports browsers and it clearly leverages AJAX requests to
implement HTTP requests. But the library is also compatible with [NodeJS](http://nodejs.org/) as well as other - less
common - command line hosts:
* [PhantomJS](http://phantomjs.org/)
* [cscript/wscript](http://technet.microsoft.com/en-us/library/bb490887.aspx)
* [Rhino](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino)

In order to design only one API that is compatible with all these hosts, I had to deal with each host specific tools.

## How to test HTTP request

When you follow the [TDD practice](https://en.wikipedia.org/wiki/Test-driven_development), you write tests before
writing any line of production code. But in that case, the first challenge was to figure out how the whole HTTP layer
could be tested. [Mocking](https://en.wikipedia.org/wiki/Mock_object) was not an option.

The project development environment heavily relies on the
[grunt connect](https://github.com/gruntjs/grunt-contrib-connect) task to deliver the dashboard: a place where
the developer can access all the tools (source list, tests, documentation...).

![dashboard](https://arnaudbuchholz.github.io/blog/post/Release%200.1.6/homepage.png)

(...) As a lazy developer, I just need one command line for my development (grunt).
Then all the tools are available within the dashboard.

Some middleware are plugged to add extra features such as:
* [cache](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/cache.js): introduced with
[version 0.1.7](http://gpf-js.blogspot.ca/2017/03/release-017.html), it is leveraged by the command line used to test
browsers when [Selenium](http://www.seleniumhq.org/) is not available. It implements a data storing service similar to
[Redis](https://redis.io/).
* [fs](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/fs.js): a file access service used
to read, create and delete files within the project storage. For instance, it is used by the browser test page to save
the coverage information.
* [grunt](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/grunt.js): a wrapper used to
generate and format the log of grunt tasks.

Based on this experience, it became obvious that the project needed another extension: the
[echo](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/echo.js) service.
It basically accepts any HTTP request and the response either reflects the request details or can be modified through
URL parameters.

[POSTMAN](https://www.getpostman.com/) was used to test the tool that will be used to test the HTTP layer...

![GET](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/echo%20test%20GET.png)

![GET 500](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/
echo%20test%20GET%20500.png)

![POST](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/echo%20test%20POST.png)

## One API to rule them all

Now that the HTTP layer can be tested, the API must be designed to write the tests.

### Input

An HTTP request starts with some parameters:
* The [Uniform Resource Locator](https://en.wikipedia.org/wiki/URL) which determines the web address you want to send
the request to
* The [request method](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) (also known as verb)
which specifies the kind of action you want to execute
* An optional list of [header fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
* The request body (data), mostly used for POST and PUT actions.

Even if the library supports the concept of
[streams](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.interfaces.IWritableStream.html), most of the expected use
cases imply sending an envelop that is already built (text, JSON, XML...). Also, JavaScript (in general) is not good at
handling binary data, hence a simple string is expected as a request body.

This leads to the definition of the
[httpRequestSettings](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.typedef.html#.httpRequestSettings) type.

### Output

On completion, the server sends back a response composed of:
* A [status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
* Response headers
* Response body

Regarding the response body, we could also use a
[readable stream](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.interfaces.IReadableStream.html). But, for the same
reasons, a simple string containing the whole response text will be returned.

This leads to the definition of the
[httpRequestResponse](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.typedef.html#.httpRequestResponse) type.

(...) If needed, the API may evolve later to introduce the possibility to use streams.

### Waiting for the completion

An HTTP request is asynchronous. To avoid the [callback hell](http://callbackhell.com/), a
[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) is used to
represent the eventual completion of the request.

This leads to the definition of the
[gpf.http.request](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.http.html#.request) API.

### Shortcuts

For simple requests such as a GET with no specific header, the API must be easy to use.
Shortcuts are defined to shorten the call, for instance:

`
gpf.http.get(baseUrl).then(function (response) {
    process(response.responseText);
}, handleError);
`

See [complete documentation](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.http.html).

## Handling different environments

Switch mechanism using a dictionary of request implementation
(promise encapsulation)

### Browsers

AJAX request
=> network communication is handled by the browser
=> callback is triggered only when the engine is free

Rely on the [XmlHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) object.

new XmlHttpRequest()

Building helpers _gpfHttpGenSetHeaders / _gpfHttpGenSend



### NodeJS

Beside being a JavaScript host, NodeJS offers a complete set of API for the most common tasks.
In particular, it comes with the [http feature](https://nodejs.org/api/http.html#http_http).

Using the [http.request](https://nodejs.org/api/http.html#http_http_request_options_callback) method, you can allocate
an [http.ClientRequest](https://nodejs.org/api/http.html#http_class_http_clientrequest).

URL parsing

Sending data with Content-Length
Don't use end (texT)

Response body reading through a stream


### WScript

WScript offers the possibility to reuse [COM components](https://en.wikipedia.org/wiki/Component_Object_Model).
In particular, the
[WinHttp.WinHttpRequest.5.1](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384106%28v=vs.85%29.aspx)

However, the object offers synchronous methods. => Asynchronous is mocked through the setTimeout polyfill
    => Requires a timer loop

Helpers could be used but does not support bind (had to change the way helper is built)

### Rhino

One of the most challenging implementation because it relies on JAVA API.

JAVA + Streams

Stream to send
Stream to read


new java.net.URL(request.url).openConnection();

If a status code 5 comes back from the server, the response stream differs.
This is handled specifically as the API has to succeed no matter what

### PhantomJS

PhantomJS is a command line simulating a browser...
I sometimes struggles with PhantomJS to decide if it
XHR + Security option

</code>
<!-- Drop those two lines -->
</div>
</div>
