<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<!--
    5 ways to make an http request in JavaScript

    ...And the 5th is shocking :-)

-->
<h3 class="post-title entry-title">
    5 ways to make an http request
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The version 0.2.1 of the GPF-JS library delivers an HTTP request helper that can be used on all supported hosts.
    It was quite a challenge as it implied 5 different developments, here are the details.
</div>
<code class="markdown">

## The need for HTTP requests

In a world of [interoperability](https://en.wikipedia.org/wiki/Interoperability),
[internet of things](https://en.wikipedia.org/wiki/Internet_of_things) and
[microservices](https://en.wikipedia.org/wiki/Microservices), the - almost 30 years old -
[HTTP protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) defines a communication medium that is widely
known and implemented.

Originally designed for human-to-machine communication, this protocol also supports machine-to-machine communication
through standardized concepts and interfaces:
* Representational state transfer APIs ([REST](https://en.wikipedia.org/wiki/Representational_state_transfer))
* [Web services](https://en.wikipedia.org/wiki/Web_service)
* [OData](http://www.odata.org/)
* [JSONP](https://en.wikipedia.org/wiki/JSONP) (or [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing))
...

### Evolution of HTTP requests in browsers

[Web browsers](https://en.wikipedia.org/wiki/Web_browser) were the first applications implementing this protocol to
access the [World Wide Web](https://en.wikipedia.org/wiki/World_Wide_Web).

Before [AJAX](https://en.wikipedia.org/wiki/Ajax_%28programming%29) was conceptualized, web pages had to be fully
refreshed from the server to reflect any change. From a user experience point of view, it was OK (mostly because we had
no other choices) but this limited the development of user interfaces.

Then AJAX introduced new ways to design web pages: only the new information could be fetched from the server without
reloading the page. As a consequence, the pages were faster, crisper and fully asynchronous.

However, each browser had its own implementation of AJAX requests (not mentioning DOM, event handling and other
incompatibilities). And that's why [jQuery](https://jquery.com/), which was initially designed to offer a uniform API
that would work identically on any browser, became so popular.

Today, the situation has changed: almost all browsers are implementing the same APIs and, consequently, modern
libraries are considering browsers to be one environment only.

### GPF-JS

[GPF-JS](https://www.npmjs.com/package/gpf-js) obviously supports browsers and it clearly leverages AJAX requests to
implement HTTP requests. But the library is also compatible with [NodeJS](http://nodejs.org/) as well as other - less
common - command line hosts:
* [PhantomJS](http://phantomjs.org/)
* [cscript/wscript](http://technet.microsoft.com/en-us/library/bb490887.aspx)
* [Rhino](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino)

In order to design only one API that is compatible with all these hosts, I had to deal with each host specific tools.

## How to test HTTP request

When you follow the [TDD practice](https://en.wikipedia.org/wiki/Test-driven_development), you write tests before
writing any line of production code. But in that case, the first challenge was to figure out how the whole HTTP layer
could be tested. [Mocking](https://en.wikipedia.org/wiki/Mock_object) was not an option.

The project development environment heavily relies on the
[grunt connect](https://github.com/gruntjs/grunt-contrib-connect) task to deliver the dashboard: a place where
the developer can access all the tools (source list, tests, documentation...).

![dashboard](https://arnaudbuchholz.github.io/blog/post/Release%200.1.6/homepage.png)

(...) As a lazy developer, I just need one command line for my development (grunt).
Then all the tools are available within the dashboard.

Some middleware are plugged to add extra features such as:
* [cache](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/cache.js): introduced with
[version 0.1.7](http://gpf-js.blogspot.ca/2017/03/release-017.html), it is leveraged by the command line used to test
browsers when [Selenium](http://www.seleniumhq.org/) is not available. It implements a data storing service similar to
[Redis](https://redis.io/).
* [fs](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/fs.js): a file access service used
to read, create and delete files within the project storage. For instance, it is used by the browser test page to save
the coverage information.
* [grunt](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/grunt.js): a wrapper used to
generate and format the log of grunt tasks.

Based on this experience, it became obvious that the project needed another extension: the
[echo](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/echo.js) service.
It basically accepts any HTTP request and the response either reflects the request details or can be modified through
URL parameters.

[POSTMAN](https://www.getpostman.com/) was used to test the tool that will be used to test the HTTP layer...

![GET](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/echo%20test%20GET.png)

![GET 500](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/
echo%20test%20GET%20500.png)

![POST](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/echo%20test%20POST.png)

## One API to rule them all

Now that the HTTP layer can be tested, the API must be designed to write the tests.

### Input

An HTTP request starts with some parameters:
* The [Uniform Resource Locator](https://en.wikipedia.org/wiki/URL) which determines the web address you want to send
the request to. There are several ways to specify this location: NodeJS offers an
[URL class](https://nodejs.org/api/url.html#url_class_url) which exposes the different parts of it (host, port ...).
However, the simplest representation remains the one everybody is used to: the string you can read inside the browser
location bar.

* The [request method](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) (also known as verb)
which specifies the kind of action you want to execute.

* An optional list of [header fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields). The simplest way to
provide this list is to use a key/value dictionary, meaning an
[object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object).

* The [request body](https://en.wikipedia.org/wiki/HTTP_message_body) (data), mostly used for POST and PUT actions.
Even if the library supports the concept of
[streams](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.interfaces.IWritableStream.html), most of the expected use
cases imply sending an envelop that is synchronously built (text, JSON, XML...). Also, JavaScript (in general) is not
good at handling binary data, hence a simple string is expected as a request body.

This leads to the definition of the
[httpRequestSettings](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.typedef.html#.httpRequestSettings) type.

### Output

On completion, the server sends back a [response](https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html) composed of:
* A [status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) that provides feedback about how the server
processed the request. Typically, 200 means everything went well. On the contrary, 4xx messages signal an error.

* A list of response headers. For instance, this is how [cookies](https://en.wikipedia.org/wiki/HTTP_cookie) are
transmitted by the server to the client (and, by the way, they are also sent back by the client to the server
through headers).

* The response body: depending on what has been requested, the response will contain the answer.
Regarding the response body, we could also use a
[readable stream](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.interfaces.IReadableStream.html). But, for the same
reasons, a simple string containing the whole response text will be returned.

This leads to the definition of the
[httpRequestResponse](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.typedef.html#.httpRequestResponse) type.

(...) If needed, the API may evolve later to introduce the possibility to use streams.

### Waiting for the completion

An HTTP request is asynchronous, hence the client has to wait for the server to answer.
To avoid the [callback hell](http://callbackhell.com/), a
[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) is used to
represent the eventual completion of the request.

This leads to the definition of the
[gpf.http.request](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.http.html#.request) API.

The promise is
[resolved](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) when the
server answered, whatever the status code
(including [500](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500)). The only way the promise would be rejected is when something wrong happened
during communication.

### Shortcuts

For simple requests such as a GET with no specific header, the API must be easy to use.
Shortcuts are defined to shorten the call, for instance:

`
gpf.http.get(baseUrl).then(function (response) {
    process(response.responseText);
}, handleError);
`

See the [documentation](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.http.html).

## Handling different environments

Inside the library, there are almost as many implementations as there are supported hosts.
Each one is inside a self-titled file below the
[http source folder](https://github.com/ArnaudBuchholz/gpf-js/tree/master/src/http).
This will be detailed right after.

Consequently, there are basically many ways to call the proper implementation depending on the host:

* Inside the request API, create an if / else condition that tests every possibility
`gpf.http.request = function (/*...*/) {
    if (_GPF_HOST.NODEJS === _gpfHost) {
        // call NodeJS implementation
    } else if (_GPF_HOST.BROWSER === _gpfHost) {
        // call Browser implementation
    } else /* ... */
};`

* Have a global variable receiving the proper implementation, using an if condition inside each implementation file
`// Inside src/host/nodejs.js
if (_GPF_HOST.NODEJS === _gpfHost) {
    _gpfHttpRequestImpl = function (/*...*/) {
        /* ... NodeJS implementation ... */
    };
}

// Inside src/http.js
gpf.http.request = function (/*...*/) {
    _gpfHttpRequestImpl(/*...*/);
};`

* Create a dictionary that index all implementations per host
`// Inside src/host/nodejs.js
_gpfHttpRequestImplByHost[_GPF_HOST.NODEJS] = function () {
    /* ... NodeJS implementation ... */
};

// Inside src/http.js
gpf.http.request = function (/*...*/) {
    _gpfHttpRequestImplByHost[_gpfHost](/*...*/);
};`


My preference goes to the last choice for several reasons:
* if / else conditions generates [cyclomatic complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity).
In general, the less if the better. For that particular case, they are useless because used to compare a variable (here
the current host) with a list of predefined values (the list of host names). A dictionary is more efficient.

* It is simpler to manipulate a dictionary to dynamically declare a new host or even update an existing implementation.
Indeed, we could imaging a plugin mechanism that would change the way requests are working by replacing the default
handler.

As a consequence, the internal library variable
[_gpfHttpRequestImplByHost](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.2.1/src/http.js#L48-L67) contains all
implementations indexed by host name. The request API calls the proper one by fetching the implementation at runtime.

### Browsers

As explained in the introduction, browsers provide AJAX requests. The implementation relies on the
[XmlHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) JavaScript class.

If needed, you will find thousands of examples on the web on how to use it.

In terms of processing, it is interesting to note that, once triggered from JavaScript, the network communication is
fully handled by the browser: it does not require the JavaScript engine. This means that the page may execute some code
while the request is being transmitted to the server as well as while waiting for the response.
However, to be able to process the result (i.e. trigger the callback), the JavaScript engine must be idle.

![Test preview](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/browser.png)

Browser implementation is done inside
[src/http/xhr.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/http/xhr.js).

Two helpers are defined inside
[src/http/helpers.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/http/helpers.js):
* [_gpfHttpGenSetHeaders](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.2.1/src/http/helpers.js#L31-L47)
* [_gpfHttpGenSend](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.2.1/src/http/helpers.js#L49-L65)

Setting the headers and sending request data is almost done the same way for three hosts.
To avoid [code duplication](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), those two functions generates
specialized functions capable of enumerating and setting the headers as well as sending data (if any).

### NodeJS

Beside being a JavaScript host, NodeJS offers a complete set of API for the most common tasks.
In particular, it comes with the [http feature](https://nodejs.org/api/http.html#http_http).

Using the [http.request](https://nodejs.org/api/http.html#http_http_request_options_callback) method, you can allocate
an [http.ClientRequest](https://nodejs.org/api/http.html#http_class_http_clientrequest).

URL parsing

Sending data with Content-Length
Don't use end (texT)

Response body reading through a stream


### WScript

WScript offers the possibility to reuse [COM components](https://en.wikipedia.org/wiki/Component_Object_Model).
In particular, the
[WinHttp.WinHttpRequest.5.1](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384106%28v=vs.85%29.aspx)

However, the object offers synchronous methods. => Asynchronous is mocked through the setTimeout polyfill
    => Requires a timer loop

Helpers could be used but does not support bind (had to change the way helper is built)

### Rhino

One of the most challenging implementation because it relies on JAVA API.

JAVA + Streams

Stream to send
Stream to read


new java.net.URL(request.url).openConnection();

If a status code 5 comes back from the server, the response stream differs.
This is handled specifically as the API has to succeed no matter what

### PhantomJS

PhantomJS is a command line simulating a browser...
I sometimes struggles with PhantomJS to decide if it
XHR + Security option

</code>
<!-- Drop those two lines -->
</div>
</div>
