<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<!--
    5 ways to make an http request in JavaScript

    ...And the 5th is shocking :-)

-->
<h3 class="post-title entry-title">
    5 ways to make an http request
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The version 0.2.1 of the GPF-JS library delivers an HTTP request helper that can be used on all supported hosts.
    It was quite a challenge as it implied 5 different developments, here are the details.
</div>
<code class="markdown">

## The need for HTTP requests

Almost all modern applications are split in two parts: the user interface and a data processing engine where
persistency and logic are implemented. More specifically, for web applications, the UI will be executed in the
browser and the engine is somewhere on the web server.

When the two communicate, the HTTP layer is : it abstracts the
HTTP offers connectivity with virtually all systems
    Web services / Microservices


At some point, the HTTP layer is even more useful than the file

jQuery was initially designed to offer APIs that would work the same way on any browser.
Today, most modern libraries are focusing on one environment only. Otherwise, they deliver feature that work both in
    browsers and NodeJS.
In my case, I added three additional hosts: PhantomJS, WScript and Rhino.


## How to test HTTP request

When you follow the [TDD practice](https://en.wikipedia.org/wiki/Test-driven_development), you write tests before
writing any line of production code. But in that case, the first challenge was to figure out how the whole HTTP layer
could be tested. [Mocking](https://en.wikipedia.org/wiki/Mock_object) was not an option.

The project itself heavily relies on the [grunt connect](https://github.com/gruntjs/grunt-contrib-connect) task to
deliver the dashboard: a place where you can access all the tools (source list, tests, documentation...).

![dashboard](https://arnaudbuchholz.github.io/blog/post/Release%200.1.6/homepage.png)

(...) As a lazy developper, I don't need any command line for my development, all the tools are available within the
dashboard.

Some middleware were also plugged to add extra features such as:
* [cache](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/cache.js): introduced with
[version 0.1.7](http://gpf-js.blogspot.ca/2017/03/release-017.html), it is leveraged by the command line used to test
browsers when [Selenium](http://www.seleniumhq.org/) is not available. It implements a data storing service similar to
[Redis](https://redis.io/).
* [fs](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/fs.js): a file access service used
to read, create and delete files within the project storage.
* [grunt](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/grunt.js): a wrapper used to
generate and format the log of grunt tasks.

Based on this experience, I thought of another extension: the
[echo](https://github.com/ArnaudBuchholz/gpf-js/blob/master/grunt/connect-middleware/echo.js) service.
It basically accepts any HTTP request and the response either reflects the request details or can be modified through
URL parameters.

Then, [POSTMAN](https://www.getpostman.com/) was used to test the tool that will be used to test the HTTP layer...

![GET](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/echo%20test%20GET.png)

![GET 500](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/
echo%20test%20GET%20500.png)

![POST](https://arnaudbuchholz.github.io/blog/post/5%20ways%20to%20make%20an%20http%20request/echo%20test%20POST.png)

    ## The different environments

The GPF-JS library is a project I started almost three years ago. Initially, it was a playground to learn how a big
JS project
Project architecture & coverage information

### NodeJS

Beside being a JavaScript host, NodeJS offers a complete set of API for the most common tasks.
In particular, it comes with the [http feature](https://nodejs.org/api/http.html#http_http).

Using the [http.request](https://nodejs.org/api/http.html#http_http_request_options_callback) method, you can allocate
an [http.ClientRequest](https://nodejs.org/api/http.html#http_class_http_clientrequest).

### Browsers

AJAX request
    => network communication is handled by the browser
    => callback is triggered only when the engine is free

Older browsers had different ways to trigger requests. This is where jQuery became so usefull by encapsulating browser
differences inside a single API.

Most recent browsers offer the [XmlHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) object.

new XmlHttpRequest()

Building helpers _gpfHttpGenSetHeaders / _gpfHttpGenSend

### WScript

WScript offers the possibility to reuse [COM components](https://en.wikipedia.org/wiki/Component_Object_Model).
In particular, the
[WinHttp.WinHttpRequest.5.1](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384106%28v=vs.85%29.aspx)

However, the object offers synchronous methods.

Helpers could be used but does not support bind (had to change the way helper is built)

### Rhino

One of the most challenging implementation because it relies on JAVA API.

JAVA + Streams

new java.net.URL(request.url).openConnection();

If a status code 5 comes back from the server, the response stream differs.
This is handled specifically as the API has to succeed no matter what

### PhantomJS

PhantomJS is a command line simulating a browser...
I sometimes struggles with PhantomJS to decide if it
XHR + Security option

</code>
<!-- Drop those two lines -->
</div>
</div>
