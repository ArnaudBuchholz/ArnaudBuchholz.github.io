<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own require implementation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The release 0.2.2 of GPF-JS delivers a polymorphic modularization mechanism that mimics RequireJS or CommonJS
    implementation inside NodeJS. It was surprisingly easy to make it happen now that the library offers all the
    basic services and it combines lots of technologies. Here are the implementation details.
</div>
<code class="markdown">
## Introduction

The [GPF-JS release 0.2.2](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.2) is finally
[out](https://gpf-js.blogspot.ca/2017/11/release-022-gpfrequire.html) and it contains
several improvements:
* Better code quality
* Better documentation
* Some tests were rewritten

But the exciting part of it is the new [gpf.require](https://arnaudbuchholz.github.io/gpf/0.2.2/doc/gpf.require.html)
namespace that exposes a [modularization helper](https://arnaudbuchholz.github.io/gpf/0.2.2/doc/tutorial-REQUIRE.html).

In this article, several topics will be covered:
* How modularity helps developers create better code
* What is dependency injection
* An overview of some existing modularization solutions
* gpf.require implementation
* Future of gpf.require

## Modularity

### Team work

Let's start with an edge case. An application which source code stands in one single file with a development team
composed of several developers. Assuming they all work simultaneously and a source control system is used to store the
file, this will lead to several problems:

* First of all, the source file will be large
* It also means that it will be harder to maintain
* Indeed, even if guidelines and comments are used, it will be hard to navigate inside the code file because of its
size
* Having several modifications being done in the same file usually leads to conflicts when pushing the code
* Some logic might be repeated because hard to find

Obviously, the same problems may appear on smaller files but, in general, the larger the file the more problems it
generates.

### Divide and rule

Code modularity is a good illustration of the [divide and rule](https://en.wikipedia.org/wiki/Divide_and_rule)
principle. Indeed, by splitting you application into smaller chunks, you have better granularity over your
modifications:
* People can work on separate files
* File organisation should reflect project structure

### Mocking

Code segregation & encapsulation / Services in Angular

[Single Responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)

### Maintainability

## Dependency injection

[Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)


## Existing implementations

### Browser includes


### NodeJs



### RequireJS

The [RequireJS](http://requirejs.org/) library is widely used

https://www.sitepoint.com/understanding-requirejs-for-effective-javascript-module-loading/

### Browserify

The [Browserify](http://browserify.org/) tool is capable of take

### WebPack

[WebPack](https://webpack.js.org/) is like browserify on steroids.

http://blog.namangoel.com/browserify-vs-webpack-js-drama



## NodeJS implementation of CommonJS

Find the presentation that allowed me to understand the whole thing
>> Simplification using Promises

## GPF-JS Implementation

### Context switching

require.define is redefined

### File loading

Switch between web and non web
    gpf.http.get / gpf.fs.load


### Caching

Caching the promises
Cache modification handler

### Detecting resource type

By file extension

### JavaScript module execution

Detecting module type
    Based on a regular expression to detect the use of require

    => Should probably be testing module.exports too...

Dealing with inner promises

If the module also uses gpf.require.define OR define itself, you must wait for this function to complete before
    completing the loading of the module (so that it can be used).
This was quite challenging but I found using promise wrapping

## Conclusion

Things to improve:
    - detect cross references
    - implement new file types (templates?)
    - implement module properties & hidden variables (https://nodejs.org/docs/latest/api/modules.html#modules_module_children)

</code>
<!-- Drop those two lines -->
</div>
</div>
