<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own require implementation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The release 0.2.2 of GPF-JS delivers a polymorphic modularization mechanism that mimics RequireJS or CommonJS
    implementation inside NodeJS. It was surprisingly easy to make it happen now that the library offers all the
    basic services and it combines lots of technologies. Here are the implementation details.
</div>
<code class="markdown">
## Introduction

The [GPF-JS release 0.2.2](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.2) is finally
[out](https://gpf-js.blogspot.ca/2017/11/release-022-gpfrequire.html) and it contains
several improvements:
* Better code quality
* Better documentation
* Some tests were rewritten

But the exciting part of it is the new [gpf.require](https://arnaudbuchholz.github.io/gpf/doc/gpf.require.html)
namespace that exposes a [modularization helper](https://arnaudbuchholz.github.io/gpf/doc/tutorial-REQUIRE.html).

To give a bit of context, the following topics will be explained:
* How modularity helps developers create better code
* What is dependency injection
* An overview of some existing modularization solutions

Finally, the implementation as well as the future of gpf.require will be explored.

## Modularity

### One file to rule them all

![One File to bring them all and in the darkness bind them](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/ring.png)

[In the Land of Mordor where the Shadows lie.](https://en.wikipedia.org/wiki/One_Ring)

To demonstrate the value of modularity, we will start with an extreme
[edge case](https://en.wikipedia.org/wiki/Edge_case): an application which source code stands in **one single file** and
a development team composed of **several developers**.
We will assume that **they all work simultaneously** and a version control system is used to store the file.

<svg width="100%" height="256"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <marker id="head" orient="auto" markerWidth="2" markerHeight="4" refX="0.1" refY="2">
            <path d="M0,0 V4 L2,2 Z" fill="red" />
        </marker>
    </defs>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/albert.png" x="0" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="16" width="32px" height="32px"/>
    <text x="106" y="34" text-anchor="middle">Z</text>
    <path
        marker-end="url(#head)"
        stroke-width="5" fill="none" stroke="red"
        d="M128,32 L232,104"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/britney.png" x="0" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="80" width="32px" height="32px"/>
    <text x="106" y="98" text-anchor="middle">Z</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,96 L232,120"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/charles.png" x="0" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="144" width="32px" height="32px"/>
    <text x="106" y="162" text-anchor="middle">Z</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,160 L232,136"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/denise.png" x="0" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="208" width="32px" height="32px"/>
    <text x="106" y="226" text-anchor="middle">Z</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,224 L232,152"
    />

    <rect x="256" y="64" width="128px" height="128px" strike="black" fill="silver"></rect>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/cloud database.png" x="256" y="64" width="128px" height="128px"/>

    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M400,128 L496,128"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="96" width="64px" height="64px"/>
    <text x="534" y="116" text-anchor="middle">Z</text>

</svg>

(*Each developer works on a local copy of the source file and pushes to the file control system*)


The first obvious concern is the resulting file size. Depending on the application complexity, and assuming no library
is used, **the source file will be big**.

And with size comes additional problems, leading to [maintainability](https://en.wikipedia.org/wiki/Maintainability)
issues. Even if guidelines are well established between the team members and comments are used, **it will be hard to
navigate through the lines of code**.

JavaScript offer [hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting) that basically allows the
developer to use a function before it is being declared.

`catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}

// The result of the code above is: "My cat's name is Chloe"`

But most linters will raise [an error](https://eslint.org/docs/rules/no-use-before-define) for the above code.
Indeed, it is a best practice to declare functions and variables before using them.

So the team will end up **cluttering the source file** to ensure declarations are made before use.

Not being able to navigate easily in the code also generates a more subtle problem:
**some logic might be repeated because it was hard to locate**.

Finally, having all developers work on a single file will generate
**[conflicts](https://betterexplained.com/articles/a-visual-guide-to-version-control/)** when pushing it to the
[version control system](https://en.wikipedia.org/wiki/Version_control).
Fortunately, most of those systems have mechanism to solve the conflicts either automatically or with the help of the
developer. But **this takes developer time and it is not risk free**.

Obviously, all these problems may appear on smaller files too but, in general, the larger the file the more problems.

Two questions are remaining:
* What could be the advantages of having a single source file?
* What is the maximum file size?

In the context of web applications, a single source file makes the application load faster as it reduces the number
of requests. It does not mean that it must be written manually, there are many tools capable of building it.

For instance:
* [UglifyJS](https://github.com/mishoo/UglifyJS2) is a command line tool that concatenates and
[minifies](https://en.wikipedia.org/wiki/Minification_%28programming%29) sources. It also exists as a
[grunt task](https://github.com/gruntjs/grunt-contrib-uglify).
* [Webpack](https://webpack.js.org/) goes even beyond JavaScript concatenation by handling resources and
[transpiling](https://www.stevefenton.co.uk/2012/11/compiling-vs-transpiling/) ES6 code.

Answering the second question is way more difficult.
From my experience, **any JavaScript source file bigger than 1000 lines is a problem**.
There might be good reasons to have a such a big file but it always comes with a cost.

In [GPF-JS](https://github.com/ArnaudBuchholz/gpf-js#metrics), the average number of lines per source file
is a little under 100. But it has not
[always been like this !](https://arnaudbuchholz.github.io/gpf/plato/index.html)

![Plato report on GPF-JS](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/plato%20average%20lines.png)

### Divide and rule

![Or divide and conquer](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/divide-and-conquer1.jpg)

Code splitting is a good illustration of the [divide and rule](https://en.wikipedia.org/wiki/Divide_and_rule)
principle. Indeed, **by slicing the application into smaller chunks, the developers have a better control over the
changes**.

<svg width="100%" height="256"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <marker id="head" orient="auto" markerWidth="2" markerHeight="4" refX="0.1" refY="2">
            <path d="M0,0 V4 L2,2 Z" fill="red" />
        </marker>
    </defs>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/albert.png" x="0" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="16" width="32px" height="32px"/>
    <text x="106" y="34" text-anchor="middle">A</text>
    <path
        marker-end="url(#head)"
        stroke-width="5" fill="none" stroke="red"
        d="M128,32 L232,104"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/britney.png" x="0" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="80" width="32px" height="32px"/>
    <text x="106" y="98" text-anchor="middle">B</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,96 L232,120"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/charles.png" x="0" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="144" width="32px" height="32px"/>
    <text x="106" y="162" text-anchor="middle">C</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,160 L232,136"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/denise.png" x="0" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="208" width="32px" height="32px"/>
    <text x="106" y="226" text-anchor="middle">D</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,224 L232,152"
    />

    <rect x="256" y="64" width="128px" height="128px" strike="black" fill="silver"></rect>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/cloud database.png" x="256" y="64" width="128px" height="128px"/>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="422" y="48" width="64px" height="64px"/>
    <text x="444" y="68" text-anchor="middle">A</text>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="48" width="64px" height="64px"/>
    <text x="534" y="68" text-anchor="middle">B</text>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="422" y="144" width="64px" height="64px"/>
    <text x="444" y="164" text-anchor="middle">C</text>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="144" width="64px" height="64px"/>
    <text x="534" y="164" text-anchor="middle">D</text>

</svg>

(*Each developer works on separate - smaller - source files*)

It sounds easy but it is not.

When it comes to deciding how to slice the application and organize the sources,
there must be **rules and discipline**.

For example, setting the level of granularity to one function per source will generate an overwhelming amount of files.
Or, **not having a clear file structure will make the architecture obscure** and will slow down the team.

There are many guidelines and howtos on the web depending on the type of project or technology.

For instance:
* [Best practices for Express app structure](https://www.terlici.com/2014/08/25/best-practices-express-structure.html)
* [AngularJS Best Practices: Directory Structure](https://scotch.io/tutorials/
angularjs-best-practices-directory-structure)
* [SAPUI5 application project structuring](http://www.sapui5tutors.com/2016/03/
sapui5-application-project-structuring.html)
* [Introduction to ExtJS Application Architecture](https://docs.sencha.com/extjs/6.0.0/guides/application_architecture/
application_architecture.html)
* [How to Structure Your React Project](https://daveceddia.com/react-project-structure/)

...

[Yeoman](http://yeoman.io/), a scaffolding tool for applications, contains
[thousands of project generators](http://yeoman.io/generators/).

Yet, once the basic structure is in place, developers are still confronted with choices when a new file must be created.

Here are some basic principles:
* Folders are used to qualify the sources they contain. Indeed, if a folder is named "controller", it is more than
expected to find only controllers inside it.
* Avoid folder names that are too generic: misc, util, helpers


Try to encapsulate features in files.  Back to the [SOLID](https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) principles,
    [Single Responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)


How do you load the source files (i.e. how do you expose the interface)


### Module loading


### Maintainability

Having smaller source files make them easier to maintain.
In terms of coverage it is also a good way to 'increase' the overall coverage of

### Mocking

Another subtle benefit of modularity is related to testing.

Let say that you have a module B depending on a module A. The last one is hard to test because it accesses critical
resources. Because of that, you can't really test B.

However, if your A has a well defined interface and if the modularization system offers you a way to substitute this
module by another one, you can then

    By isolating a critical feature in a module that has a
well defined interface, and provided that you can then replace it with a similar one mocking the functionality.

It gives you a total control on t

## Dependency injection

[Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)


## Existing implementations

### Browser includes

You must load them in the proper order
Interface exposure is done through global variables

You can create private scopes using IIFE


### NodeJs

require / module.exports
Synchronous loading
Scope is private

### RequireJS

The [RequireJS](http://requirejs.org/) library is widely used

https://www.sitepoint.com/understanding-requirejs-for-effective-javascript-module-loading/

asynchronous loading
Scope is private

### Browserify

The [Browserify](http://browserify.org/) tool is capable of take

### WebPack

[WebPack](https://webpack.js.org/) is like browserify on steroids.

http://blog.namangoel.com/browserify-vs-webpack-js-drama


## NodeJS implementation of CommonJS

Find the presentation that allowed me to understand the whole thing
>> Simplification using Promises

## GPF-JS Implementation

### Context switching

require.define is redefined

### File loading

Switch between web and non web
    gpf.http.get / gpf.fs.load


### Caching

Caching the promises
Cache modification handler

### Detecting resource type

By file extension

### JavaScript module execution

Detecting module type
    Based on a regular expression to detect the use of require

    => Should probably be testing module.exports too...

Dealing with inner promises

If the module also uses gpf.require.define OR define itself, you must wait for this function to complete before
    completing the loading of the module (so that it can be used).
This was quite challenging but I found using promise wrapping

## Future of gpf.require

### Handling cross references

(See how NodeJS and RequireJS handle them)

Pattern by setting the dependency
Principle of weak references: can be resolved after the module was loaded


## Conclusion

Things to improve:
    - detect cross references
    - implement new file types (templates?)
    - implement module properties & hidden variables (https://nodejs.org/docs/latest/api/modules.html#modules_module_children)

</code>
<!-- Drop those two lines -->
</div>
</div>
