<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own require implementation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The release 0.2.2 of GPF-JS delivers a polymorphic modularization mechanism that mimics RequireJS or CommonJS
    implementation inside NodeJS. It was surprisingly easy to make it happen now that the library offers all the
    basic services and it combines lots of technologies. Here are the implementation details.
</div>
<code class="markdown">
## Introduction

The [GPF-JS release 0.2.2](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.2) is finally
[out](https://gpf-js.blogspot.ca/2017/11/release-022-gpfrequire.html) and it contains
several improvements:
* Better code quality
* Better documentation
* Some tests were rewritten

But the exciting part of it is the new [gpf.require](https://arnaudbuchholz.github.io/gpf/0.2.2/doc/gpf.require.html)
namespace that exposes a [modularization helper](https://arnaudbuchholz.github.io/gpf/0.2.2/doc/tutorial-REQUIRE.html).

In this article, several topics will be covered:
* How modularity helps developers create better code
* What is dependency injection
* An overview of some existing modularization solutions
* gpf.require implementation
* Future of gpf.require

## Modularity

### Team work

Let's start with an edge case: an application which source code stands in one single file and a development team
composed of several developers. We will assume that they all work simultaneously and a source control system is used to
store the file.

<svg width="100%" height="256"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <marker id="head" orient="auto" markerWidth="2" markerHeight="4" refX="0.1" refY="2">
            <path d="M0,0 V4 L2,2 Z" fill="red" />
        </marker>
    </defs>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/albert.png" x="0" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="16" width="32px" height="32px"/>
    <path
        marker-end="url(#head)"
        stroke-width="5" fill="none" stroke="red"
        d="M128,32 L232,104"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/britney.png" x="0" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="80" width="32px" height="32px"/>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,96 L232,120"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/charles.png" x="0" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="144" width="32px" height="32px"/>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,160 L232,136"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/denise.png" x="0" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="208" width="32px" height="32px"/>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,224 L232,152"
    />

    <rect x="256" y="64" width="128px" height="128px" strike="black" fill="silver"></rect>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/cloud database.png" x="256" y="64" width="128px" height="128px"/>

    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M400,128 L496,128"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="96" width="64px" height="64px"/>

</svg>

Let's start by talking about the file size. Depending on the application complexity, and assuming no library is used,
the file will be big.

The first obvious problem generated by this situation is the size of the unique source file. It will be large.
With the size of the file comes other problems, such as maintainability issues.


This kind of situation leads to several problems:
* First of all, the source file will be large
* It also means that it will be harder to maintain
* Even if guidelines are respected and comments are used, it might be hard to navigate inside the code file because of its
size
* Having several modifications being done in the same file usually leads to conflicts when pushing the code
* Some logic might be repeated because hard to find

Obviously, the same problems may appear on smaller files but, in general, the larger the file the more problems it
generates.

Advantages of a big file:
- Version control simplified
- No dependencies

Then, you might ask yourself: what is the maximum file size? In GPF-JS, the average number of lines per source file
is a little under 100 lines.

![Plato report on GPF-JS](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/plato%20average%20lines.png)

### Divide and rule

Code modularity is a good illustration of the [divide and rule](https://en.wikipedia.org/wiki/Divide_and_rule)
principle. Indeed, by splitting you application into smaller chunks, you have better granularity over your
modifications:
* Developers can work simultaneously on separate files
* File organisation should reflect project structure: it forces the team to agree on

There are easy rule that can be applied to organize your code: usually, encapsulating ...
For instance,     Services in Angular
    Code segregation & encapsulation /

Back to the [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) principles,
    [Single Responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)



### Maintainability


### Mocking

Another subtle benefit of modularity is related to testing.

Let say that you have a module B depending on a module A. The last one is hard to test because it accesses critical
resources. Because of that, you can't really test B.

However, if your A has a well defined interface and if the modularization system offers you a way to substitute this
module by another one, you can then

    By isolating a critical feature in a module that has a
well defined interface, and provided that you can then replace it with a similar one mocking the functionality.

It gives you a total control on t

## Dependency injection

[Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)


## Existing implementations

### Browser includes


### NodeJs1



### RequireJS

The [RequireJS](http://requirejs.org/) library is widely used

https://www.sitepoint.com/understanding-requirejs-for-effective-javascript-module-loading/

### Browserify

The [Browserify](http://browserify.org/) tool is capable of take

### WebPack

[WebPack](https://webpack.js.org/) is like browserify on steroids.

http://blog.namangoel.com/browserify-vs-webpack-js-drama



## NodeJS implementation of CommonJS

Find the presentation that allowed me to understand the whole thing
>> Simplification using Promises

## GPF-JS Implementation

### Context switching

require.define is redefined

### File loading

Switch between web and non web
    gpf.http.get / gpf.fs.load


### Caching

Caching the promises
Cache modification handler

### Detecting resource type

By file extension

### JavaScript module execution

Detecting module type
    Based on a regular expression to detect the use of require

    => Should probably be testing module.exports too...

Dealing with inner promises

If the module also uses gpf.require.define OR define itself, you must wait for this function to complete before
    completing the loading of the module (so that it can be used).
This was quite challenging but I found using promise wrapping

## Future of gpf.require

### Handling cross references

(See how NodeJS and RequireJS handle them)

Pattern by setting the dependency
Principle of weak references: can be resolved after the module was loaded


## Conclusion

Things to improve:
    - detect cross references
    - implement new file types (templates?)
    - implement module properties & hidden variables (https://nodejs.org/docs/latest/api/modules.html#modules_module_children)

</code>
<!-- Drop those two lines -->
</div>
</div>
