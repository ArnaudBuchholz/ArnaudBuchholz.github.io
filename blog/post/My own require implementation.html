<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own require implementation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    The release 0.2.2 of GPF-JS delivers a polymorphic modularization mechanism that mimics RequireJS or CommonJS
    implementation inside NodeJS. It was surprisingly easy to make it happen now that the library offers all the
    basic services and it combines lots of technologies. Here are the implementation details.
</div>
<code class="markdown">
## Introduction

The [GPF-JS release 0.2.2](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.2) is finally
[out](https://gpf-js.blogspot.ca/2017/11/release-022-gpfrequire.html) and it contains
several improvements:
* Better code quality
* Better documentation
* Some tests were rewritten

But the exciting part of it is the new [gpf.require](https://arnaudbuchholz.github.io/gpf/doc/gpf.require.html)
namespace that exposes a [modularization helper](https://arnaudbuchholz.github.io/gpf/doc/tutorial-REQUIRE.html).

To give a bit of context, the following topics will be explained:
* How modularity helps developers create better code
* What is dependency injection
* An overview of some existing modularization solutions

Finally, the implementation as well as the future of gpf.require will be explored.

## Modularity

### One file to rule them all

![One File to bring them all and in the darkness bind them](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/ring.png)

[In the Land of Mordor where the Shadows lie.](https://en.wikipedia.org/wiki/One_Ring)

To demonstrate the value of modularity, we will start with an extreme
[edge case](https://en.wikipedia.org/wiki/Edge_case): an application which source code stands in **one single file** and
a development team composed of **several developers**.
We will assume that **they all work simultaneously** and a version control system is used to store the file.

<svg width="100%" height="256"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <marker id="head" orient="auto" markerWidth="2" markerHeight="4" refX="0.1" refY="2">
            <path d="M0,0 V4 L2,2 Z" fill="red" />
        </marker>
    </defs>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/albert.png" x="0" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="16" width="32px" height="32px"/>
    <text x="106" y="34" text-anchor="middle">Z</text>
    <path
        marker-end="url(#head)"
        stroke-width="5" fill="none" stroke="red"
        d="M128,32 L232,104"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/britney.png" x="0" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="80" width="32px" height="32px"/>
    <text x="106" y="98" text-anchor="middle">Z</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,96 L232,120"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/charles.png" x="0" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="144" width="32px" height="32px"/>
    <text x="106" y="162" text-anchor="middle">Z</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,160 L232,136"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/denise.png" x="0" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="208" width="32px" height="32px"/>
    <text x="106" y="226" text-anchor="middle">Z</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,224 L232,152"
    />

    <rect x="256" y="64" width="128px" height="128px" strike="black" fill="silver"></rect>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/cloud database.png" x="256" y="64" width="128px" height="128px"/>

    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M400,128 L496,128"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="96" width="64px" height="64px"/>
    <text x="534" y="116" text-anchor="middle">Z</text>

</svg>

(*Each developer works on a local copy of the source file and pushes to the file control system*)


The first obvious concern is the resulting file size. Depending on the application complexity, and assuming no library
is used, **the source file will be big**.

And with size comes additional problems, leading to [maintainability](https://en.wikipedia.org/wiki/Maintainability)
issues. Even if guidelines are well established between the team members and comments are used, **it will be hard to
navigate through the lines of code**.

JavaScript offer [hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting) that basically allows the
developer to use a function before it is being declared.

`catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}

// The result of the code above is: "My cat's name is Chloe"`

But most linters will raise [an error](https://eslint.org/docs/rules/no-use-before-define) for the above code.
Indeed, it is a best practice to declare functions and variables before using them.

So the team will end up **cluttering the source file** to ensure declarations are made before use.

Not being able to navigate easily in the code also generates a more subtle problem:
**some logic might be repeated because it was hard to locate**.

Finally, having all developers work on a single file will generate
**[conflicts](https://betterexplained.com/articles/a-visual-guide-to-version-control/)** when pushing it to the
[version control system](https://en.wikipedia.org/wiki/Version_control).
Fortunately, most of those systems have mechanism to solve the conflicts either automatically or with the help of the
developer. But **this takes developer time and it is not risk free**.

Obviously, all these problems may appear on smaller files too but, in general, the larger the file the more problems.

Two questions are remaining:
* What could be the advantages of having a single source file?
* What is the maximum file size?

In the context of web applications, a single source file makes the application load faster as it reduces the number
of requests. It does not mean that it must be written manually, there are many tools capable of building it.

For instance:
* [UglifyJS](https://github.com/mishoo/UglifyJS2) is a command line tool that concatenates and
[minifies](https://en.wikipedia.org/wiki/Minification_%28programming%29) sources. It also exists as a
[grunt task](https://github.com/gruntjs/grunt-contrib-uglify).
* [Webpack](https://webpack.js.org/) goes even beyond JavaScript concatenation by handling resources and
[transpiling](https://www.stevefenton.co.uk/2012/11/compiling-vs-transpiling/) ES6 code.

Answering the second question is way more difficult.
From my experience, **any JavaScript source file bigger than 1000 lines is a problem**.
There might be good reasons to have a such a big file but it always comes with a cost.

In [GPF-JS](https://github.com/ArnaudBuchholz/gpf-js#metrics), the average number of lines per source file
is a little under 100. But it has not
[always been like this !](https://arnaudbuchholz.github.io/gpf/plato/index.html)

![Plato report on GPF-JS](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/plato%20average%20lines.png)

### Divide and rule

![Or divide and conquer](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/divide-and-conquer1.jpg)

Code splitting is a good illustration of the [divide and rule](https://en.wikipedia.org/wiki/Divide_and_rule)
principle. Indeed, **by slicing the application into smaller chunks, the developers have a better control over the
changes**.

<svg width="100%" height="256"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <marker id="head" orient="auto" markerWidth="2" markerHeight="4" refX="0.1" refY="2">
            <path d="M0,0 V4 L2,2 Z" fill="red" />
        </marker>
    </defs>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/albert.png" x="0" y="0" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="16" width="32px" height="32px"/>
    <text x="106" y="34" text-anchor="middle">A</text>
    <path
        marker-end="url(#head)"
        stroke-width="5" fill="none" stroke="red"
        d="M128,32 L232,104"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/britney.png" x="0" y="64" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="80" width="32px" height="32px"/>
    <text x="106" y="98" text-anchor="middle">B</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,96 L232,120"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/charles.png" x="0" y="128" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="144" width="32px" height="32px"/>
    <text x="106" y="162" text-anchor="middle">C</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,160 L232,136"
    />

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/coding.png" x="32" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/denise.png" x="0" y="192" width="64px" height="64px"/>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document edit.png" x="96" y="208" width="32px" height="32px"/>
    <text x="106" y="226" text-anchor="middle">D</text>
    <path
            marker-end="url(#head)"
            stroke-width="5" fill="none" stroke="red"
            d="M128,224 L232,152"
    />

    <rect x="256" y="64" width="128px" height="128px" strike="black" fill="silver"></rect>
    <image xlink:href="http://ArnaudBuchholz.github.io/blog/cloud database.png" x="256" y="64" width="128px" height="128px"/>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="422" y="48" width="64px" height="64px"/>
    <text x="444" y="68" text-anchor="middle">A</text>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="48" width="64px" height="64px"/>
    <text x="534" y="68" text-anchor="middle">B</text>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="422" y="144" width="64px" height="64px"/>
    <text x="444" y="164" text-anchor="middle">C</text>

    <image xlink:href="http://ArnaudBuchholz.github.io/blog/document locked.png" x="512" y="144" width="64px" height="64px"/>
    <text x="534" y="164" text-anchor="middle">D</text>

</svg>

(*Each developer works on separate - smaller - source files*)

It sounds easy but it is not.

When it comes to deciding how to slice the application and organize the sources,
there must be **rules and discipline**.

For example, maximizing the **level of granularity** by having one function per source will generate an overwhelming
amount of files. Or, **not having a clear file structure will make the architecture obscure** and will slow down the
team.

#### Files organization

There are many guidelines and howtos on the web depending on the type of project or technology.

For instance:
* [Best practices for Express app structure](https://www.terlici.com/2014/08/25/best-practices-express-structure.html)
* [AngularJS Best Practices: Directory Structure](https://scotch.io/tutorials/
angularjs-best-practices-directory-structure)
* [SAPUI5 application project structuring](http://www.sapui5tutors.com/2016/03/
sapui5-application-project-structuring.html)
* [Introduction to ExtJS Application Architecture](https://docs.sencha.com/extjs/6.0.0/guides/application_architecture/
application_architecture.html)
* [How to Structure Your React Project](https://daveceddia.com/react-project-structure/)

On the other hands, some tools offers the possibility to instantiate new projects with a predefined structure.
Such as [Yeoman](http://yeoman.io/) which contains [thousands of project generators](http://yeoman.io/generators/).

<iframe width="560" height="315" src="https://www.youtube.com/embed/zBt2g9ekiug" frameborder="0" allowfullscreen></iframe>

Yet, once the basic structure is in place, developers are still **confronted with choices when new files must be
created.**

So, regarding files organization, here are some basic principles (in no particular order):

* Document the structure and make it known: ask people to [Read The Fabulous Manual](https://en.wikipedia.org/wiki/RTFM)

* Folder names are used to qualify the files they contain.
Indeed, if a folder is named "controller", it is more than expected to find only
[controllers](https://en.wikipedia.org/wiki/Model–view–controller) in it.
The same way, for a web application, a "public" folder usually indicates that its content is exposed

* The folder qualification can be technical ("sources", "tests", "public") or functional ("controllers", "views",
"dialogs", "stream") but mixing at the same level should be avoided. For one technology stack, if dialogs are
implemented with controllers:
it makes sense to see "dialogs" below "controllers" but having both in the same folder will be confusing

* Try to stick to widely accepted (and understood) names: use "public" instead "www", use "dist" or "release" instead
of "shipping"...

* Try to avoid names that are too generic: "folder" *(true story)*, "misc", "util", "helpers", "data"...

* Stick to one language *(don't mix French and English)*


* Select and stick to a naming formalism, such as [Camel Case](https://en.wikipedia.org/wiki/Camel_case)

* Forget about the [8.3](https://en.wikipedia.org/wiki/8.3_filename) or
[MAX_PATH](https://support.microsoft.com/fr-ca/help/177665/path-too-long-error-message-when-exceeding-max-path)
limitations, names can be as long as necessary

#### Level of granularity

Once the structure is clearly defined, the only difficulty remaining is to figure out what to put inside the files.
Obviously, their names must be self explanatory about purpose and content.

**Struggling to choose the right file name is usually a good sign that it contains more than necessary**: splitting may help.

In case of doubts, just associate:
* folders to [namespaces](https://en.wikipedia.org/wiki/Namespace)
* files to [classes](https://en.wikipedia.org/wiki/Class_%28computer_programming%29)

Then, try to stick to the [SOLID](https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29)
![principles](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/SOLID.jpg)

In particular, **the [Single Responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)
should drive the choices when creating a new file**.

Here is a shamelessly modified copy of the wikipedia definition as it summarizes the idea:*

"The single responsibility principle is a computer programming principle that states that every module should have
responsibility over a single part of the functionality provided by the software, and that responsibility should be
entirely encapsulated by the module. All its services should be narrowly aligned with that responsibility."*


(...) Referring to the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
and the [Dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle) may look weird
when considering source files but the following two sections (loading and mocking) will shed some light on the analysis
behind this statement.

Basically, because of this definition, a source file is no more a senseless bunch of lines of codes but rather a
**self-contained feature**. Hence, it will be referred as a **module**.

#### Modules

The advantages of modules are multiple:

* **Testability**: it is sometimes difficult to draw the line between
[unit testing](https://en.wikipedia.org/wiki/Unit_testing) and
[integration testing](https://en.wikipedia.org/wiki/Integration_testing). Long story short, if you need several modules
to run a test, it sounds like integration. On the other hand, if the module can be tested with no or very few
dependencies (maybe through mocking), this is unit testing.

* **Maintainability**: combining the file size and the testability increases the module's
[maintainability](https://en.wikipedia.org/wiki/Maintainability). This means that it is easier (in terms of complexity
and effort) to improve or fix.

* **Reusability**: modules are an indisputable alternative to copy & paste.

<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>

### Loading

The way modules are loaded **varies for each host** and some examples will be shown in the 'Existing implementations'
section. This is where **GPF-JS brings value by offering one uniform solution** for all supported hosts.

The purpose of this part is not to explain each mechanism but rather describe the overall philosophy when it
comes to loading the sources of an application.

#### Everything at once

![Load all the files](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/X-All-The-Y.jpg)

As already mentioned before, there are tools designed to concatenate and minify all sources in order to generate
a single application file. This file is consequently **self-sufficient**.

Another alternative is to maintain a **list of sources to load**... in the correct order so that **dependencies are
loaded before their dependant modules**.
For instance, in an HTML page, you may have a big list of script tags to include all sources.

Advantages are:
* Sequence is managed by a list, this gives a clear understanding of the loading process and allows the developers to
fully control it

Disadvantages are:
* Every time a new source is created, it must be added to the list in the correct order
* The more files, the bigger the list
* Some files may be loaded even if they are not used anymore

(...) This is not the preferred solution but this is how the source version of GPF-JS is
[handled](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/sources.json). The lazy me has created some tools
to maintain this list in the dashboard.

#### Lazy loading

If a module declare its dependencies

To make it work, dependencies bet

CON:
    Detecting missing dependencies
    speed? ==> caching

PRO:
    No big list to maintain
    speed?

    list of dependencies

![The lazy me is happy](http://localhost:63342/ArnaudBuchholz.github.io/blog/post/
My%20own%20require%20implementation/nolist.jpg)

#### Dependency handling

    Dependency injection

    [Dependency injection](https://en.wikipedia.org/wiki/Dependency_injection)
    alias between module and its path

    Angular uses pre-loading then injection


### Mocking

Another subtle benefit of modularity is related to testing.

Let say that you have a module B depending on a module A. The last one is hard to test because it accesses critical
resources. Because of that, you can't really test B.

However, if your A has a well defined interface and if the modularization system offers you a way to substitute this
module by another one, you can then

    By isolating a critical feature in a module that has a
well defined interface, and provided that you can then replace it with a similar one mocking the functionality.

It gives you a total control on t

## Existing implementations

### Browser includes


You must load them in the proper order: this
Interface exposure is done through global variables

You can create private scopes using IIFE but exposing the module interface has to be done either through globals or
    using a global methods


### NodeJs

require / module.exports
Synchronous loading
Scope is private

### RequireJS

The [RequireJS](http://requirejs.org/) library is widely used

https://www.sitepoint.com/understanding-requirejs-for-effective-javascript-module-loading/

asynchronous loading
Scope is private

### Browserify

The [Browserify](http://browserify.org/) tool is capable of take

### WebPack

[WebPack](https://webpack.js.org/) is like browserify on steroids.

http://blog.namangoel.com/browserify-vs-webpack-js-drama


## NodeJS implementation of CommonJS

Find the presentation that allowed me to understand the whole thing
>> Simplification using Promises

## GPF-JS Implementation

### Context switching

require.define is redefined

### File loading

Switch between web and non web
    gpf.http.get / gpf.fs.load


### Caching

Caching the promises
Cache modification handler

### Detecting resource type

By file extension

### JavaScript module execution

Detecting module type
    Based on a regular expression to detect the use of require

    => Should probably be testing module.exports too...

Dealing with inner promises

If the module also uses gpf.require.define OR define itself, you must wait for this function to complete before
    completing the loading of the module (so that it can be used).
This was quite challenging but I found using promise wrapping

## Future of gpf.require

### Handling cross references

(See how NodeJS and RequireJS handle them)

Pattern by setting the dependency
Principle of weak references: can be resolved after the module was loaded


## Conclusion

Things to improve:
    - detect cross references
    - implement new file types (templates?)
    - implement module properties & hidden variables (https://nodejs.org/docs/latest/api/modules.html#modules_module_children)

</code>
<!-- Drop those two lines -->
</div>
</div>
