<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    Release 0.2.8: Serialization attributes
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/release.png" align="left">
    This release took longer as it was developped in parallel with several side projects.
    It includes new asynchronous helpers, new classes designed to validate attributes usage and
    a brand new mechanism to serialize classes.
</div>
<code class="markdown">
## Release 0.2.8: Serialization attributes

* [Stories and bugs](https://github.com/ArnaudBuchholz/gpf-js/milestone/16?closed=1) implemented
* [Sources](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.8)
* [Documentation](https://arnaudbuchholz.github.io/gpf/doc/index.html)
* [NPM package](https://www.npmjs.com/package/gpf-js)

## Release content

### A longer release

As explained in the [last release notes](http://gpf-js.blogspot.com/2018/08/release-027-quality-and-xml.html), I am
concentrating on a [side project](https://github.com/ArnaudBuchholz/bubu-cms) and the library evolved to **support
its development**.

In the meantime, other projects ([mockserver-server](https://github.com/ArnaudBuchholz/mockserver-server) and
[node-ui5](https://www.npmjs.com/package/node-ui5)) were started since **interesting challenges** were
submitted over the last month. Not to mention that **more documentation** was requested on the linting rules but also on
the evolution of the library statistics.

As a consequence, this release took **more time than usual** (around 4 months).

### Asynchronous helpers

#### Interface wrappers

When the XML serialization was introduced, a [generic wrapper](https://github.com/ArnaudBuchholz/gpf-js/issues/272) was
**required to simplify** the use of the
[IXmlContentHandler interface](https://arnaudbuchholz.github.io/gpf/doc/gpf.interfaces.IXmlContentHandler.html).

The new function
[gpf.interfaces.promisify](https://arnaudbuchholz.github.io/gpf/doc/gpf.interfaces.html#.promisify__anchor)
builds a **factory method** that takes an object implementing the given interface. This method returns a wrapper
exposing the interface methods but returning **chainable
[promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**.

To put it in a nutshell, it converts this code:

`const
    writer = new gpf.xml.Writer(),
    output = new gpf.stream.WritableString();
gpf.stream.pipe(writer, output).then(() => {
    console.log(output.toString());
});
writer.startDocument()
    .then(() => writer.startElement("document"))
    .then(() => writer.startElement("a"))
    .then(() => writer.startElement("b"))
    .then(() => writer.endElement())
    .then(() => writer.endElement())
    .then(() => writer.startElement("c"))
    .then(() => writer.endElement())
    .then(() => writer.endElement())
    .then(() => writer.endDocument());`

into this code:

`const
    writer = new gpf.xml.Writer(),
    output = new gpf.stream.WritableString(),
    IXmlContentHandler = gpf.interfaces.IXmlContentHandler,
    xmlContentHandler = gpf.interfaces.promisify(IXmlContentHandler),
    promisifiedWriter = xmlContentHandler(writer);
gpf.stream.pipe(writer, output).then(() => {
    console.log(output.toString());
});
promisifiedWriter.startDocument()
    .startElement("document")
    .startElement("a")
    .startElement("b")
    .endElement()
    .endElement()
    .startElement("c")
    .endElement()
    .endElement()
    .endDocument();`

When using this wrapper, it quickly appeared that **something was missing**.
It sometimes happens that the chain is broken by a **normal promise**.
The wrapper was modified to deal with it.

`/*...*/
promisifiedWriter.startDocument()
    .startElement("document")
    .startElement("a")
    .startElement("b")
    .then(() => anyMethodReturningAPromise())
    .endElement()
    .endElement()
    .startElement("c")
    .endElement()
    .endElement()
    .endDocument();`

The best example of use is
[$metadata implementation](https://github.com/ArnaudBuchholz/bubu-cms/blob/77240f29513b359cd22ba15f46adfa5ad67be1b9/
api/metadata.js) of the side project.

#### gpf.forEachAsync

There are many [solutions](https://stackoverflow.com/questions/40328932/javascript-es6-promise-for-loop) to handle
**loops with promises**.

Since the library offers **iteration helpers**
([gpf.forEach](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.forEach__anchor)), it made sense to provide the
equivalent for asynchronous callbacks:
[gpf.forEachAsync](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.forEachAsync__anchor).
It obviously returns a promise **resolved when the loop is over**.

### $singleton

Among the [design patterns](https://en.wikipedia.org/wiki/Software_design_pattern),
the **[singleton](https://en.wikipedia.org/wiki/Singleton_pattern)** is probably the most easy
to describe and implement.

Here again, there are many ways to create a singleton in JavaScript.

In the library, an entity definition may include the
**[$singleton](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html) property**.
When used, any attempt to instantiate a new instance of the entity will return the same instance.

The singleton is allocated the **first time it is instantiated**.

For instance:
`var counter = 0,
    Singleton = gpf.define({
        $class: "mySingleton",
        $singleton: true,

        constructor: function () {
            this.value = ++counter;
        }
    });
var instance1 = new Singleton();
var instance2 = new Singleton();
assert(instance1.value === 1); // true
assert(instance2.value === 1); // true
assert(instance1 === instance2); // true`

### Serialization and validation attributes

<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>

It is pretty hard to describe these new features without giving a high level view of what the side project is made of.

Simply put, it consists in a full stack application with an [OpenUI5](https://openui5.org/) interface and a custom made
[ODATA](https://www.odata.org/) server where the
[schema](https://www.odata.org/documentation/odata-version-2-0/overview/#MetadataForODataServices) is
**extracted from classes defining
[entities](https://www.odata.org/documentation/odata-version-2-0/overview/#EntityDataModel)**.

Indeed, since I am a [lazy developer](https://www.linkedin.com/pulse/lazy-arnaud-buchholz/) prototyping a backend,
flexibility is mandatory so that adding a new entity / property does not need changes all across the project.

#### gpf.attributes.Serializable

The simplest way consists in putting all the necessary information directly inside the entity definition.
It means that the class also includes information about **which members are exposed and how**.

This is a perfect use case for attributes.

For instance, on the [Record](https://github.com/ArnaudBuchholz/bubu-cms/blob/master/api/Record.js#L30) class, the
_name property is qualified with a
[gpf.attributes.Serializable](https://arnaudbuchholz.github.io/gpf/doc/gpf.attributes.Serializable.html) attribute.
It describes the name, type and indicates that the property is required.

(...)  The required part is actually not used yet.

These members are defined in the type
[gpf.typedef.serializableProperty](https://arnaudbuchholz.github.io/gpf/doc/gpf.typedef.html#.serializableProperty).

Today, only three [types](https://arnaudbuchholz.github.io/gpf/doc/gpf.serial.html#.types__anchor) are supported:
* string
* integer
* date/time

#### gpf.serial

Helpers to list Serializable attributes of a class definition

[gpf.serial.fromRaw](https://arnaudbuchholz.github.io/gpf/doc/gpf.serial.html#.fromRaw__anchor)
and [gpf.serial.toRaw](https://arnaudbuchholz.github.io/gpf/doc/gpf.serial.html#.toRaw__anchor)

#### attributes restrictions

Checking again the [gpf.attributes.Serializable](https://arnaudbuchholz.github.io/gpf/doc/gpf.attributes.Serializable.html)
atttribute definition, it comes with **Usage restriction**
* Only for member level (see [gpf.attributes.MemberAttribute](https://arnaudbuchholz.github.io/gpf/doc/gpf.attributes.MemberAttribute.html))
* Only once (see [gpf.attributes.UniqueAttribute](https://arnaudbuchholz.github.io/gpf/doc/gpf.attributes.UniqueAttribute.html))

This means that some attributes were designed to qualify attributes

### Project metrics reporting

Two years ago, the [release 0.1.5 named "The new core"](http://gpf-js.blogspot.com/2016/12/release-015.html) marked the
beginning of **a new development start for the library**. There are few traces of what happened before as the project
was **not structured**. Since then, the project metrics were **systematically** added to the
[Readme](https://github.com/ArnaudBuchholz/gpf-js#metrics).

With [release 0.2.3](https://gpf-js.blogspot.com/2017/12/release-023-streams-and-pipes.html), all these metrics were
**consolidated into one single file**:
[releases.json](https://github.com/ArnaudBuchholz/gpf-js/blob/master/build/releases.json). This file is **automatically
updated** by the [release script](https://github.com/ArnaudBuchholz/gpf-js/blob/master/make/release.js).

Using [chartist.js](https://gionkunz.github.io/chartist-js/), the dashboard tiles were modified to render a chart
showing the **progression of the metrics over the releases**.

![sources](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/sources.png)

![plato](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/plato.png)

![coverage](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/coverage.png)

![tests](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/tests.png)

### Documentation of ESLint rules

#### Automated documentation

[Linting](https://en.wikipedia.org/wiki/Lint_%28software%29) is used to **statically validate the source code** since
the beginning of the project. The set of [eslint](https://eslint.org/) rules has been **refined over the releases** and
**critical settings** framed the way the sources look like.

Furthermore, the linter also evolves with time (and feedback) and **some rules become obsolete as new ones are
introduced**.

In the end, it is really challenging to **stay up-to-date** and provide **clear and complete explanations** on the
different rules that are configured (and why they are configured this way).

These are the problems that were adressed with the [task #280](https://github.com/ArnaudBuchholz/gpf-js/issues/280).

As a result, a [script](https://github.com/ArnaudBuchholz/gpf-js/blob/master/doc/linting.js) leverages
eslint's [rules documentation](https://eslint.org/docs/rules/) to **extract and validate** the library settings.
When needed, some [details](https://github.com/ArnaudBuchholz/gpf-js/tree/master/doc/linting) are provided.

The final result appears in the documentation in the
[Tutorials\Linting](https://arnaudbuchholz.github.io/gpf/doc/tutorial-LINTING.html) menu

#### no-magic-numbers

While documenting the rules, the [no-magic-numbers](https://eslint.org/docs/rules/no-magic-numbers). one stood out.

I wanted to understand how this rule would **improve the code** so it was enabled to see how many magic numbers were
used. Realizing that this generates a **huge amount of errors**, the check was turned off for test files *(to start
with)*.

(...) Some people like to distinguish warnings and errors. However warnings **do not call for action**. As a result,
they tend to last forever leading to the [broken window](https://en.wikipedia.org/wiki/Broken_windows_theory) effect. I
prefer a binary approach meaning it is either OK or not OK.

It took almost one month of refactoring to remove magic numbers.

(...) This also demonstrated the value of having 100% of test coverage.

## Lessons learned

Using the library as a support for a new application gives immediate feedback on how the API are developped.


Huge refactoring due to no-magic-numbers forced me to reconsider some of the patterns I was using regularly.
For instance:
`if (string.indexOf(otherString) === 0)`
was in fact
`if (string.startsWith(otherString))`

or
`if (string.indexOf(otherString) !== -1)`
was indeed
`if (string.includes(otherString))`

## Next release

The [next release content](https://github.com/ArnaudBuchholz/gpf-js/milestone/17) is not even defined.
For the next months, I will focus on a side project that requires all my attention.

</code>
<!-- Drop those two lines -->
</div>
</div>
