<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    Release 0.2.8: Serialization attributes
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/release.png" align="left">
    This release took longer as it was developped in parallel with several side projects.
    It includes new asynchronous helpers, new classes designed to validate attributes usage and
    a brand new mechanism to serialize classes.
</div>
<code class="markdown">
## Release 0.2.8: Serialization attributes

* [Stories and bugs](https://github.com/ArnaudBuchholz/gpf-js/milestone/16?closed=1) implemented
* [Sources](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.8)
* [Documentation](https://arnaudbuchholz.github.io/gpf/doc/index.html)
* [NPM package](https://www.npmjs.com/package/gpf-js)

## Release content

### A longer release

As explained in the [last release notes](http://gpf-js.blogspot.com/2018/08/release-027-quality-and-xml.html), I am
concentrating on a [side project](https://github.com/ArnaudBuchholz/bubu-cms) and the library evolved to **support
its development**.

In the meantime, other projects ([mockserver-server](https://github.com/ArnaudBuchholz/mockserver-server) and
[node-ui5](https://www.npmjs.com/package/node-ui5)) were started since **interesting challenges** were
submitted over the last month. Not to mention that **more documentation** was requested on the linting rules but also on
the evolution of the library statistics.

As a consequence, this release took **more time than usual** (around 4 months).

### Asynchronous helpers

#### Interface wrappers

When the XML serialization was introduced, a [generic wrapper](https://github.com/ArnaudBuchholz/gpf-js/issues/272) was
**required to simplify** the use of the
[IXmlContentHandler interface](https://arnaudbuchholz.github.io/gpf/doc/gpf.interfaces.IXmlContentHandler.html).

The new function
[gpf.interfaces.promisify](https://arnaudbuchholz.github.io/gpf/doc/gpf.interfaces.html#.promisify__anchor)
builds a **factory method** that takes an object implementing the given interface. This method returns a wrapper
exposing the interface methods but returning **chainable
[promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)**.

To put it in a nutshell, it converts this code:

`const
    writer = new gpf.xml.Writer(),
    output = new gpf.stream.WritableString();
gpf.stream.pipe(writer, output).then(() => {
    console.log(output.toString());
});
writer.startDocument()
    .then(() => writer.startElement("document"))
    .then(() => writer.startElement("a"))
    .then(() => writer.startElement("b"))
    .then(() => writer.endElement())
    .then(() => writer.endElement())
    .then(() => writer.startElement("c"))
    .then(() => writer.endElement())
    .then(() => writer.endElement())
    .then(() => writer.endDocument());`

into this code:

`const
    writer = new gpf.xml.Writer(),
    output = new gpf.stream.WritableString(),
    IXmlContentHandler = gpf.interfaces.IXmlContentHandler,
    xmlContentHandler = gpf.interfaces.promisify(IXmlContentHandler),
    promisifiedWriter = xmlContentHandler(writer);
gpf.stream.pipe(writer, output).then(() => {
    console.log(output.toString());
});
promisifiedWriter.startDocument()
    .startElement("document")
    .startElement("a")
    .startElement("b")
    .endElement()
    .endElement()
    .startElement("c")
    .endElement()
    .endElement()
    .endDocument();`

When using this wrapper, it quickly appeared that **something was missing**.
It sometimes happens that the chain is broken by a **normal promise**.
The wrapper was modified to deal with it.

`/*...*/
promisifiedWriter.startDocument()
    .startElement("document")
    .startElement("a")
    .startElement("b")
    .then(() => anyMethodReturningAPromise())
    .endElement()
    .endElement()
    .startElement("c")
    .endElement()
    .endElement()
    .endDocument();`

The best example of use is
[$metadata implementation](https://github.com/ArnaudBuchholz/bubu-cms/blob/77240f29513b359cd22ba15f46adfa5ad67be1b9/
api/metadata.js) of the side project.

#### gpf.forEachAsync

There are many [solutions](https://stackoverflow.com/questions/40328932/javascript-es6-promise-for-loop) to handle
**loops with promises**.

Since the library offers **iteration helpers**
([gpf.forEach](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.forEach__anchor)), it made sense to provide the
equivalent for asynchronous callbacks:
[gpf.forEachAsync](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.forEachAsync__anchor).
It obviously returns a promise **resolved when the loop is over**.

### $singleton

Among the [design patterns](https://en.wikipedia.org/wiki/Software_design_pattern),
the **[singleton](https://en.wikipedia.org/wiki/Singleton_pattern)** is probably the most easy
to describe and implement.

Here again, there are many ways to create a singleton in JavaScript.

In the library, an entity definition may include the
**[$singleton](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html) property**.
When used, any attempt to instantiate a new instance of the entity will return the same instance.

The singleton is allocated the **first time it is instantiated**.

For instance:
`var counter = 0,
    Singleton = gpf.define({
        $class: "mySingleton",
        $singleton: true,

        constructor: function () {
            this.value = ++counter;
        }
    });
var instance1 = new Singleton();
var instance2 = new Singleton();
assert(instance1.value === 1); // true
assert(instance2.value === 1); // true
assert(instance1 === instance2); // true`

### Serialization attributes

The side

#### gpf.serial

#### attributes restrictions

### Project metrics reporting

![sources](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/sources.png)

![plato](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/plato.png)

![coverage](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/coverage.png)

![tests](http://arnaudbuchholz.github.io/blog/post/Release%200.2.8/tests.png)

### Documentation of ESLint rules

https://arnaudbuchholz.github.io/gpf/doc/tutorial-LINTING.html

Spent almost one monthn refactoring to enable no-magic-numbers !

## Lessons learned

Huge refactoring due to no-magic-numbers forced me to reconsider some of the patterns I was using regularly.
For instance:
`if (string.indexOf(otherString) === 0)`
was in fact
`if (string.startsWith(otherString))`

or
`if (string.indexOf(otherString) !== -1)`
was in fact
`if (string.includes(otherString))`

## Next release

The [next release content](https://github.com/ArnaudBuchholz/gpf-js/milestone/17) is not even defined.
For the next months, I will focus on a side project that requires all my attention.

</code>
<!-- Drop those two lines -->
</div>
</div>
