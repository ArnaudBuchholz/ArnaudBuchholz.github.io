<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    Release 0.2.1: Side project support
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/release.png" align="left">
    This new release introduces the http request helper on all supported hosts and improves the coverage measurement.
    It is also the first version to be published again as an NPM package.
</div>
<code class="markdown">
## New version

Here comes the new version:
* [Stories and bugs](https://github.com/ArnaudBuchholz/gpf-js/milestone/9?closed=1) implemented
* [Sources](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.1)
* [Documentation](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/index.html)
* [NPM package](https://www.npmjs.com/package/gpf-js)

### NPM Publishing

Starting from this version, the library will be published as an [NPM](https://www.npmjs.com/) package on every release.

The package was already existing since it was first published for version
[0.1.4](https://github.com/ArnaudBuchholz/gpf-js/tree/cdd69ac0459904c0096853dd5402a33d4b242065).
However, the library has since been redesigned in a way that is not backward compatible.
That's the reason why I increased the MINOR version number.

(...) It is violating the normal [backward compatibility rule](http://semver.org/) but, actually, nobody was
really using it... And I didn't want to increase the MAJOR number to 1 until the library is ready.

An [.npmignore](https://github.com/ArnaudBuchholz/gpf-js/blob/master/.npmignore) file instructs NPM which files should
be included or not. The package is almost limited to the build folder.

### HTTP Requests

The prominent feature of this version is the
[gpf.http.request](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.http.html#.request__anchor) helper.
With it, you can trigger [HTTP requests](https://developer.mozilla.org/en-US/docs/Web/HTTP) from any supported host
using only one API. The response is given back to the script asynchronously through
[Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).

(...) The promise is resolved when the server provides a response, whatever the status code.

Some shortcuts are also defined to improve code readability:

`
gpf.http.get(requestUrl).then(function (response) {
    if (response.status === 500) {
        return Promise.reject(new Error("Internal Error"));
    }
    return process(response.responseText);
})
.catch(function (reason) {
    onError(reason);
});
`

The supported (and tested) features are:
* Most common [HTTP verbs](https://arnaudbuchholz.github.io/gpf/0.2.1/doc/gpf.http.html#.methods__anchor)
* Possibility to provide request headers
* Possibility to access response headers
* Possibility to submit textual payload (on POST and PUT)
* Access to response text

Other features will be added depending on the needs but this is enough to make it fully functional.

(...) I will soon write an article about this very specific part as I had lot of challenges to test and implement it.

### Improved coverage


Because each host has its own implementation, it was important to be sure of the code coverage.
Before this version, coverage was based on instanbul and a mochaTest task.

After analyzing the way istanbul generates, stores and consolidates the coverage information, I found a way to
trigger instrumented code on all host (and use http request to save the collected information).

A new [task](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.2.1/grunt/tasks/istanbul.js#L46-L58) consolidate all hosts
data into the global one.

## Lessons learned

### ECHO service

To be able to test the HTTP helpers, I needed a server which I could control the answers.

    More details will come in a future article.

### Some code was definitely not tested

Once coverage was applied to all the sources I discovered untested code.
This leaded to some simplifications (boot for instance) but also to new tests.

### Incomplete design for ending a stream

## Next release

For now the project is on pause because of vacations. I will take some time to plan the next iteration more carefully
but, still, I have to support my side project by creating a CSV reader as well as a record container.

</code>
<!-- Drop those two lines -->
</div>
</div>