<script language="javascript" src="../include.js"></script>
<h3 class="post-title entry-title">
    Timeout and WebWorker
</h3>
<div class="post-body">
<!-- The above must be replaced with -->
<!-- <script language="javascript"
     src="http://ArnaudBuchholz.github.io/blog/include.js"></script> -->

<h2>The context</h2>

<p>Working on a complex JavaScript implementation, I am currently developing
a library that extensively uses asynchronous executions controlled by
<a href="https://www.promisejs.org/" target="_blank">promises</a>.</p>

<p>To work appropriately, the promise must defer its completion execution to let
the caller build first the chain of callbacks.</p>

<p>As a result, the code deeply relies on the <a
href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout"
target="_blank">setTimeout</a> function</p>

<code class="javascript">function myPromiseBasedFunction() {
    var promise = new Promise();
    /*
        Execute the content of the function and signal the completion with
        promise.resolve()
    */
    return promise;
}

// An example of use:
myPromiseBasedFunction().then(function() {
    // Triggered only when the promise is fulfilled (i.e. resolve was called)
});
</code>

<p>On top of the library, I designed the user interface with the desire to
provide the best user experience. It means that long JavaScript operations are
split into chunks and sequenced using setTimeout to prevent any UI freeze and
get rid of the annoying long-script running message.</p>

<h2>setTimeout in an inactive tab</h2>

<p>Chrome and FireFox share a particularity that I discovered when using
several tabs (later, I found that Opera was doing the same but IE and Safari are
safe).
At some point, the application appeared to be 'frozen' when the tab was not
active.</p>

<p>For instance, have a look to the following <a target="_blank"
href="http://arnaudbuchholz.github.io/blog/post/2014-11-21/timeout.html">example
page</a>.<br/>
It was designed to print the current time every 100 milliseconds both in the
page title and in the page content. If the tab is not active, you will notice
that it seems to refresh slower (nearly every second).<br/>
I also added a real-time monitor that displays red dots if the interval between
two calls is greater than 120 ms.</p>

<p>You can find good explanations of the reasons why as well as some possible
workarounds by <a target="_blank"
href="https://www.google.ca/search?q=settimeout+inactive+tab">crawling the web
</a>:
<ul>
    <li><a target="_blank" href="http://stackoverflow.com/questions/6032429/
chrome-timeouts-interval-suspended-in-background-tabs">Chrome: timeouts/interval
suspended in background tabs?</a></li>
    <li><a target="_blank" href="http://pivotallabs.com/
chrome-and-firefox-throttle-settimeout-setinterval-in-inactive-tabs/">Chrome and
Firefox throttle setTimeout/setInterval in inactive tabs</a></li>
</ul></p>

<p>As it seems that the setTimeout function works fine in a Web Worker thread, I
decided to explore this possibility.</p>

<h2>Timeout project</h2>

<p>I created a new <a target="_blank"
href="https://github.com/ArnaudBuchholz/timeout">GitHub repository</a> and
started to work on a small library that would solve the issue.</p>

<h3>Hooking the APIs</h3>

<p>First of all, the JavaScript language is really flexible and, depending on
the host, you can even redefine some of the 'built-in' APIs.</p>

<p>In a browser, the main context object (the one that contains everything)
is the <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/Window">window
object</a>.
Keep that information in mind, this will be important for the next part.</p>

<p>Hence it is possible to redefine window.setTimeout by assigning a new
handler. I decided to cover the whole timer API, that's why I <a target="_blank"
href="https://github.com/ArnaudBuchholz/timeout/blob/master/timeout.js#L244">
redefined</a> the followings:
<ul>
    <li><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/
API/WindowTimers.setTimeout">setTimeout</a></li>
    <li><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/
API/WindowTimers.clearTimeout">clearTimeout</a></li>
    <li><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/
API/WindowTimers.setInterval">setInterval</a></li>
    <li><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/
API/WindowTimers.clearInterval">clearInterval</a></li>
</ul></p>

<h3>Creating a Web Worker</h3>

<p>To create an <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">HTML5 Web Worker
</a> you need several things:
<ol>
    <li>An HTML5 browser (most <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/
Worker#AutoCompatibilityTable">modern browsers</a> are)</li>
    <li>An URL to load
<div class="note">WARNING: the <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">
same-origin policy</a> applies to this URL, you should read the documentation
</div>
    </li>
    <li>A JavaScript code to create it:
<code class="javascript">var worker = new Worker("source.js");
</code>
    </li>
    <li>A way to communicate with the worker (will be covered in the next part)
</li>
</ol>
</p>

<p>Regarding the point 2,
one challenge that I started with is that I wanted the same script to be
used not only to redefine the APIs in the main context but also to implement
the Web Worker (so that only one file must be distributed).<br/>
But it is impossible for a script to know how it has been loaded (you don't
have its 'current' URL).<br/>
So I created the <a target="_blank"
href="https://github.com/ArnaudBuchholz/timeout/blob/master/timeout.js#L209">
<b>_getTimeoutURL</b></a> method to extract this URL:<ul>
<li>It checks if a script tag with the id "timeout" exists</li>
<li>Or it checks all script tags for the one finishing with "timeout.js"</li>
<li>Or it returns "timeout.js"</li>
</ul></p>

<p>Regarding the point 3, as the same script is used for the main context as
well as the web worker, I needed a way to distinguish the two situations.<br/>
This is where the <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/Window">window
object</a> can help. Indeed, a worker thread can't access it.<br/>
That explains why the distinction is made by <a target="_blank"
href="https://github.com/ArnaudBuchholz/timeout/blob/master/timeout.js#L235">
checking the window typeof</a>.</p>

<h3>Main thread / WebWorker communication</h3>

<p>The communication between the main thread and the web worker is based on
<a target="_blank" href="https://developer.mozilla.org/en/docs/Web/API/
Worker.postMessage">messages</a>: they are asynchronous by nature.</p>

<p>Unless you start messing with the transferList parameter, you can only
transmit types that are convertible to a JSON representation (this is a highly
simplified truth. To be exact, HTML5 introduces the notion of
<a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/
The_structured_clone_algorithm">structured clone algorithm</a> used for
serializing complex objects).</p>

<p>To receive messages, you must register on the "message" event using
<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/
EventTarget.addEventListener">addEventListener</a><ul>
<li>Either on the worker object to listen to messages sent from the worker to
the main thread</li>
<li>Or on
    object to listen to its messages in the main thread</li>
</ul></p>

<h3>Other implementation details</h3>

<p>To make a long story short, every time you call setTimeout or setInterval,
a new record is created in the corresponding dictionary (_timeouts or
_intervals) to store the parameters of the call.<br/>
Its key is a number that is allocated (incremented) from _timeoutID or
_intervalID.<br/>
Then a message is sent to the worker thread to execute the timeout function:
only the key and the delay are transmitted.<br/>
On timeout, the worker sends back a message with the key to the main thread
which retrieves the parameters and executes the callback.</p>

<h2>Possible improvements</h2>

<p>Several aspects of this implementation can be improved:
<ul>
    <li><b>Startup time</b>: sometimes, the web worker requires several seconds
to run. Because of that, all timeouts may be delayed more than necessary during
this phase.<br/>
An improvement would consist in switching to the new API only when the new
thread is ready.</li>
    <br/>
    <li><b>URL to load</b>: digging on the net, I found a sample where the web worker
was initialised using a <a target="_blank"
href="http://dataurl.net/#about">data: URL</a>. This clearly reduces the
dependency with the source script but, then, we need a bootstrap to load the
code inside the web worker.</li>
</ul></p>


<h2>Conclusion</h2>

<p>It works! please check the following <a target="_blank"
href="http://arnaudbuchholz.github.io/blog/post/2014-11-21/timeout.html?fix">
example page</a>.</p>

<!-- Drop those two lines -->
</div>