<script language="javascript" src="../include.js"></script>
<h3 class="post-title entry-title">
    Timeout and WebWorker
</h3>
<div class="post-body">
<!-- The above must be replaced with -->
<!-- <script language="javascript"
     src="http://ArnaudBuchholz.github.io/blog/include.js"></script> -->
<code class="markdown">

## The context

I am currently working on a complex JavaScript application divided into several
layers. On one hand, the communication with the server is centralized in a
dedicated framework that extensively uses asynchronous executions controlled by
[promises](https://www.promisejs.org/). On the other hand, the application is
contained inside a [SPA](http://en.wikipedia.org/wiki/Single-page_application)
and is designed to provide the best user experience.

### Promises

To make a long story short, a promise represents the result of an asynchronous
operation. It can be pending (by default), fulfilled (i.e. succeeded) or
rejected (i.e. the operation failed).

The most common usage is to wait for the operation completion and chain it with
a callback. This is done by calling the method **then** with one parameter: the
function to call on completion.

For instance:
<code class="javascript">
// An example of function that uses a promise to signal its completion
function myPromiseBasedFunction() {
    var promise = new Promise();
    /*
        Execute the content of the function and signal the completion using
        promise.resolve(). This can be asynchronous (for instance, using an AJAX
        call) or synchronous. The caller does not need to know.
    */
    return promise;
}

// An example of use:
myPromiseBasedFunction().then(function() {
    // Triggered only when the promise is fulfilled (i.e. resolve was called)
});
</code>

This offers a convenient way to write asynchronous code that can be chained
easily. When the promise is created, the execution starts and even if the
result is available immediately (or synchronously), the promise allows you to
register the callback function **before** it signals the completion.

Hence, to work appropriately, a promise must defer its completion execution to
let the caller build first the chain of callbacks.

![Promise asynchronous](http://arnaudbuchholz.github.io/blog/post/
Timeout and WebWorker/Promise asynchronous.png)

![Promise synchronous](http://arnaudbuchholz.github.io/blog/post/
Timeout and WebWorker/Promise synchronous.png)

The only reliable way to implement such a code sequence is to use the
[setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers
.setTimeout) function in order to have the resolve method implementation be
called after the registration of the callback function (i.e. calls of method
**then**).

### Responsive user interface

As any user interface, the design is polished to provide the best user
experience possible.
It means that long JavaScript operations are split into chunks and sequenced
using setTimeout to prevent any interface freeze and get rid of the annoying
long-script running message.

## setTimeout in an inactive tab

Chrome and FireFox share a particularity that I discovered when using
several tabs (later, I found that Opera was doing the same but Internet Explorer
and Safari are safe).
At some point, the application appeared to be 'frozen' when the tab was not
active.

For instance, have a look to the following [example page](http://arnaudbuchholz.
github.io/blog/post/Timeout and WebWorker/timeout.html).
It was designed to print the current time every 100 milliseconds both in the
page title and in the page content. If the tab is not active, you will notice
that it seems to refresh slower (nearly every second).
I also added a real-time monitor that displays red dots if the interval between
two calls is greater than 120 ms.

You can find good explanations of the reasons why as well as some possible
workarounds by [crawling the web](https://www.google.ca/search
?q=settimeout+inactive+tab):

* [Chrome: timeouts/interval suspended in background tabs?](http://
stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-
background-tabs)
* [Chrome and Firefox throttle setTimeout/setInterval in inactive tabs](http://
pivotallabs.com/chrome-and-firefox-throttle-settimeout-setinterval-in-inactive-
tabs/)

As it seems that the setTimeout function works fine in a Web Worker thread, I
decided to explore this possibility.

##Timeout project

I created a new [GitHub repository](https://github.com/ArnaudBuchholz/
timeout) and started to work on a small library that would solve the issue.

### Hooking the APIs

<!-- TODO talk about binding -->

First of all, the JavaScript language is really flexible and, depending on
the host, you can even redefine some of the 'built-in' APIs.

In a browser, the main context object (the one that contains everything)
is the [window object](https://developer.mozilla.org/en-US/docs/Web/API/Window).
Keep that information in mind, this will be important for the next part.

Hence it is possible to redefine window.setTimeout by assigning a new
handler. I decided to cover the whole timer API, that's why I [redefined](https:
//github.com/ArnaudBuchholz/timeout/blob/
8bd8e05556d6cc1cf4f8310b24ab23f024a663f7/timeout.js#L244) the followings:
* [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers
.setTimeout)
* [clearTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers
.clearTimeout)
* [setInterval](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers
.setInterval)
* [clearInterval](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers
.clearInterval)

<h3>Creating a Web Worker</h3>

<p>To create an <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">HTML5 Web Worker
</a> you need several things:
<ol>
    <li>An HTML5 browser (most <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/
Worker#AutoCompatibilityTable">modern browsers</a> are)</li>
    <li>An URL to load
<div class="note">WARNING: the <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">
same-origin policy</a> applies to this URL, you should read the documentation
</div>
    </li>
    <li>A JavaScript code to create it:
<code class="javascript">var worker = new Worker("source.js");
</code>
    </li>
    <li>A way to communicate with the worker (will be covered in the next part)
</li>
</ol>
</p>

<p>Regarding the point 2,
one challenge that I started with is that I wanted the same script to be
used not only to redefine the APIs in the main context but also to implement
the Web Worker (so that only one file must be distributed).<br/>
But it is impossible for a script to know how it has been loaded (you don't
have its 'current' URL).<br/>
So I created the <a target="_blank"
href="https://github.com/ArnaudBuchholz/timeout/blob/8bd8e05556d6cc1cf4f8310b24ab23f024a663f7/timeout.js#L209">
<b>_getTimeoutURL</b></a> method to extract this URL:<ul>
<li>It checks if a script tag with the id "timeout" exists</li>
<li>Or it checks all script tags for the one finishing with "timeout.js"</li>
<li>Or it returns "timeout.js"</li>
</ul></p>

<p>Regarding the point 3, as the same script is used for the main context as
well as the web worker, I needed a way to distinguish the two situations.<br/>
This is where the <a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/API/Window">window
object</a> can help. Indeed, a worker thread can't access it.<br/>
That explains why the distinction is made by <a target="_blank"
href="https://github.com/ArnaudBuchholz/timeout/blob/8bd8e05556d6cc1cf4f8310b24ab23f024a663f7/timeout.js#L235">
checking the window typeof</a>.</p>

<h3>Main thread / WebWorker communication</h3>

<p>The communication between the main thread and the web worker is based on
<a target="_blank" href="https://developer.mozilla.org/en/docs/Web/API/
Worker.postMessage">messages</a>: they are asynchronous by nature.</p>

<p>Unless you start messing with the transferList parameter, you can only
transmit types that are convertible to a JSON representation (this is a highly
simplified truth. To be exact, HTML5 introduces the notion of
<a target="_blank"
href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/
The_structured_clone_algorithm">structured clone algorithm</a> used for
serializing complex objects).</p>

<p>To receive messages, you must register on the "message" event using
<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/
EventTarget.addEventListener">addEventListener</a><ul>
<li>Either on the worker object to listen to messages sent from the worker to
the main thread</li>
<li>Or on
    object to listen to its messages in the main thread</li>
</ul></p>

<h3>Other implementation details</h3>

<p>To make a long story short, every time you call setTimeout or setInterval,
a new record is created in the corresponding dictionary (_timeouts or
_intervals) to store the parameters of the call.<br/>
Its key is a number that is allocated (incremented) from _timeoutID or
_intervalID.<br/>
Then a message is sent to the worker thread to execute the timeout function:
only the key and the delay are transmitted.<br/>
On timeout, the worker sends back a message with the key to the main thread
which retrieves the parameters and executes the callback.</p>

<h2>Possible improvements</h2>

<p>Several aspects of this implementation can be improved:
<ul>
    <li><b>Startup time</b>: sometimes, the web worker requires several seconds
to run. Because of that, all timeouts may be delayed more than necessary during
this phase.<br/>
An improvement would consist in switching to the new API only when the new
thread is ready.</li>
    <br/>
    <li><b>URL to load</b>: digging on the net, I found a sample where the web worker
was initialised using a <a target="_blank"
href="http://dataurl.net/#about">data: URL</a>. This clearly reduces the
dependency with the source script but, then, we need a bootstrap to load the
code inside the web worker.</li>
</ul></p>


<h2>Conclusion</h2>

<p>It works! please check the following <a target="_blank"
href="http://arnaudbuchholz.github.io/blog/post/Timeout and WebWorker/
timeout.html?fix">
example page</a>.</p>

</code>
<!-- Drop those two lines -->
</div>