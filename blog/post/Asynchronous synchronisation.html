<script language="javascript" src="../include.js"></script>
<div class="post">
<h3 class="post-title entry-title">
    Asynchronous synchronisation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/coding.png" align="left">
    In this article, I would like to talk about a problem that is typical
    whenever you have to deal with asynchronous APIs (such as AJAX requests):
    how do you synchronize your calls to trigger an action when everything
    completed?
    <br/>
    There are great tools to address this issue (such as promises) but I want to
    explore a different (and simplest?) path.
</div>
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Asynchronous synchronisation",
    "author": {
        "@type": "Person",
        "name": "Arnaud Buchholz",
        "image": "https://en.gravatar.com/userimage/57789459/524bdffdc1fa6e86619b548c2ed70cac.jpg",
        "url": "http://gpf-js.blogspot.ca/"
    },
    "headline": "Asynchronous synchronisation",
    "url": "http://gpf-js.blogspot.ca/asynchronous-synchronisation.html",
    "datePublished": "",
    "dateModified": "",
    "description": "In this article, I would like to talk about a problem that is typical whenever you have to deal with asynchronous APIs (such as AJAX requests): how do you synchronize your calls to trigger an action when everything completed? There are great tools to address this issue (such as promises) but I want to explore a different (and simplest?) path."}
</script>
<code class="markdown">
## Promises

I already talked about [promises](http://gpf-js.blogspot.ca/2015/01/
timeout-and-webworker.html) and this is clearly one of the best solution to
handle sequencing of events.

I also recommend reading this awesome presentation from
[Trevor Burnham](https://twitter.com/trevorburnham):
[Flow control with promises](http://trevorburnham.com/presentations/
flow-control-with-promises/)

However, not all APIs are using promises and, sometimes, you have to be creative
to workaround the lack of helpers.

## NodeJS folder exploration

One example I recently came through was that I had to recursively list all files
of a folder in order to find specific ones.

NodeJS exposes its [file API](http://nodejs.org/api/fs.html) in two flavors:
* Synchronous version (for instance: [fs.statSync](http://nodejs.org/api/
fs.html#fs_fs_statsync_path), [fs.readFileSync](http://nodejs.org/api/
fs.html#fs_fs_readfilesync_filename_options))
* Asynchronous version (for instance: [fs.stat](http://nodejs.org/api/
fs.html#fs_fs_stat_path_callback), [fs.readFile](http://nodejs.org/api/
fs.html#fs_fs_readfile_filename_options_callback))

### Synchronous version

Obviously, the synchronous version is easier to develop as you can use the
result of each file API immediately after the call.
This simplifies a lot the folder exploration function.

[download](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample1.js)
`var fs = require("fs"),/*gpf:apply-jshint*/
    path = require("path"),
    start = new Date(),
    files,
    key,
    count;

function exploreSync(currentPath, result) {
    "use strict";
    var stat = fs.statSync(currentPath);
    if (undefined === result) {
        // Allocate result dictionary that will be passed to the sub calls
        result = {};
    }
    if (stat.isDirectory()) {
        // Folder
        var list = fs.readdirSync(currentPath),
            len,
            idx;
        len = list.length;
        for (idx = 0; idx < len; ++idx) {
            exploreSync(path.join(currentPath, list[idx]), result);
        }
    } else {
        // File
        result[currentPath] = fs.readFileSync(currentPath);
    }
    return result;
}

files = exploreSync(process.argv[2]);

console.log("Here we can use files dictionary:");
count = 0;
for (key in files) {
    if (files.hasOwnProperty(key)) {
        ++count;
        console.log(key + " " + files[key].length);
    }
}
console.log("Count: " + count);
console.log("Spent " + (new Date() - start) + "ms");`

(...) You might notice that there is no result testing in the above example.
It is because an exception would be thrown by nodeJS if an error occurs.

![sample 1](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample1.png)

### Synchronous vs Asynchronous

While it is so easy to develop the algorithm with the synchronous APIs,
why does nodeJS exposes asynchronous ones?

There are two main reasons:
* As expressed above, in the synchronous version, error management is done
through exceptions. Even if it is my preferred way (as it simplifies the code
writing), it complexifies error filtering. Indeed, filtering some errors would
be made by catching all exceptions and throwing again those you want to
be thrown. Less practical but not a big deal.

* On the other hand, you must remember that the JavaScript engine is
mono-threaded. If you develop a nodeJS web server that needs - whatever the
reason - to use the above exploreSync function, then your server won't
be available to process any other request until the folder exploration is done.
This is clearly bad and not scalable.

The asynchronous versions of the file APIs rely on a simple idea: file access is
done by the operating system. While doing that, the JavaScript engine could be
used to do something else!

As a consequence, asynchronous versions of the API allow time sharing and -
somehow - simulates multi-threading.

### Asynchronous version

[download](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample2.js)
`var fs = require("fs"),/*gpf:apply-jshint*/
    path = require("path"),
    start = new Date(),
    files,
    key,
    count;

function exploreAsync(currentPath, result) {
    "use strict";
    if (undefined === result) {
        // Allocate result dictionary that will be passed to the sub calls
        result = {};
    }
    fs.stat(currentPath, function (err, stat) {
        if (err) {
            console.error(err);
        } else if (stat && stat.isDirectory()) {
            // Folder
            fs.readdir(currentPath, function (err, list) {
                var
                    len,
                    idx;
                if (err) {
                    console.error(err);
                } else {
                    len = list.length;
                    for (idx = 0; idx < len; ++idx) {
                        exploreAsync(path.join(currentPath, list[idx]), result);
                    }
                }
            });
        } else {
            fs.readFile(currentPath, function (err, data) {
                if (err) {
                    console.error(err);
                } else {
                    result[currentPath] = data;
                }
            });
        }
    });
}

files = exploreAsync(process.argv[2]);

console.log("Here we can use files dictionary?");
count = 0;
for (key in files) {
    if (files.hasOwnProperty(key)) {
        ++count;
        console.log(key + " " + files[key].length);
    }
}
console.log("Count: " + count);
console.log("Spent " + (new Date() - start) + "ms");`

(...) As you can see here, for each API used, a callback function is needed to
receive the result as well as the error (if any).

![sample 2](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample2.png)

Hold on a second, why don't I get any result?

Let put some traces

[download](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample3.js)
`var fs = require("fs"),/*gpf:apply-jshint*/
    path = require("path"),
    start = new Date(),
    files,
    key,
    count;

function exploreAsync(currentPath, result) {
    "use strict";
    if (undefined === result) {
        // Allocate result dictionary that will be passed to the sub calls
        result = {};
    }
    console.log(">> fs.stat(" + currentPath + ")");
    fs.stat(currentPath, function (err, stat) {
        console.log("<< fs.stat(" + currentPath + ")");
        if (err) {
            console.error(err);
        } else if (stat && stat.isDirectory()) {
            // Folder
            console.log(">> fs.readdir(" + currentPath + ")");
            fs.readdir(currentPath, function (err, list) {
                console.log("<< fs.readdir(" + currentPath + ")");
                var
                    len,
                    idx;
                if (err) {
                    console.error(err);
                } else {
                    len = list.length;
                    for (idx = 0; idx < len; ++idx) {
                        exploreAsync(path.join(currentPath, list[idx]), result);
                    }
                }
            });
        } else {
            console.log(">> fs.readFile(" + currentPath + ")");
            fs.readFile(currentPath, function (err, data) {
                console.log("<< fs.readFile(" + currentPath + ")");
                if (err) {
                    console.error(err);
                } else {
                    result[currentPath] = data;
                }
            });
        }
    });
}

files = exploreAsync(process.argv[2]);

console.log("Here we can use files dictionary?");
count = 0;
for (key in files) {
    if (files.hasOwnProperty(key)) {
        ++count;
        console.log(key + " " + files[key].length);
    }
}
console.log("Count: " + count);
console.log("Spent " + (new Date() - start) + "ms");`

![sample 3 (beginning)](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample3a.png)
![sample 3 (end)](https://ArnaudBuchholz.github.io/blog/post/
Asynchronous synchronisation/sample3b.png)

See? as those file API are asynchronous, the file dictionary is used before it
is actually filled. But the filling **does** occur.

So the question is: how do you know the exploration ended?

## The good old way



</code>
<!-- Drop those two lines -->
</div>
</div>