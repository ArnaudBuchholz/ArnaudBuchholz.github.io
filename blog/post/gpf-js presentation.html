<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
    <h3 class="post-title entry-title">
        GPF-JS Presentation
    </h3>
    <div class="post-header">
        <div class="post-header-line-1"></div>
    </div>
    <div class="post-body">
        <!-- Copy from the next line -->
        <div class="summary">
            <img src="http://ArnaudBuchholz.github.io/blog/coding.png" align="left">
            I have been developing the GPF-JS library for a while and I recently realized that I never took the
            time to explain the reasons why I started this whole thing and what I am trying to achieve here.
            Welcome to my utopia where a perfectionist is trying to re-invent the wheel.
        </div>
        <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Javascript and development",
    "author": {
        "@type": "Person",
        "name": "Arnaud Buchholz",
        "image": "https://en.gravatar.com/userimage/57789459/524bdffdc1fa6e86619b548c2ed70cac.jpg",
        "url": "http://gpf-js.blogspot.ca/"
    },
    "headline": "GPF-JS Presentation",
    "url": "http://gpf-js.blogspot.com/2015/11/gpf-js-presentation.html",
    "datePublished": "2015-11-04T04:14:00.000Z",
    "dateModified": "2015-11-04T04:14:00.000Z",
    "description": ""
}
</script>
<code class="markdown">
(...) Since I work for a big company, I must explain that I take the entire responsibility for the information and views
that are set out in this article.
Also, ["Back to the Future"](http://www.backtothefuture.com/) pictures were gathered from the web.
They are copyrights of Universal City Studios, Inc. and U-Drive Joint Venture.

## Happy New Year 2016 !
!/[2015 was already the future, imagine what will happen in 2016 !](https://ArnaudBuchholz.github.io/blog/post/
gpf-js presentation/oct21-2015.jpg)

First of all, I'd like to wish you an happy new year 2016 ! May your lives, studies, careers, projects and everything
that makes sense to you be successful.

This is a good time to look back and ponder on what happened in order to take new resolutions for the coming year.
Talking about me, I would like to present you a personal project that I have been working on for the last 2 years and
that was greatly improved over the last months.

!/[GPF-JS GitHub contributions](https://ArnaudBuchholz.github.io/blog/post/gpf-js presentation/contributions.png)

## First, let's set the context
This is a pretty long story but I will try to make it short for the sake of your network bandwidth.

### Work experience with JavaScript

If you look into [my profile](https://ca.linkedin.com/in/arnaudbuchholz), you will read that my longest experience was
in a French company as a software engineer and this is where I learnt most of what I know today regarding coding.
In the beginning *(i.e. 15 years ago)*, we were using JavaScript as a middleware language to glue C/C++ components
together. Because I was surrounded by skilled people, advanced notions like prototype inheritance and code generation
were known and wisely used.

Moving to the cloud, the company created an ASP.NET web application and scripting was used to implement small behaviors
as the HTML was generated on server side.

But in the last years, I witnessed the growing importance of JavaScript as it was used both on Back-End and Front-End.

### Personal experience with JavaScript

I would not pretend I had a natural preference for this language: I have also coded in C, C++, Pascal (... remember
Delphi?), VBA (yuck!), C# and a little bit of Java...

However, I quickly identified three main advantages of the JavaScript language over the other ones:
* No specific IDE or compilation is needed: use notepad to edit the source and run the file. There is no better way to
quickly develop... and this is what I did for a very long time.

* [Windows Script Host](https://en.wikipedia.org/wiki/Windows_Script_Host). Indeed, this host lets you instantiate COM
component (using new ActiveXObject) and, from there, you could then access critical Windows features
([file system](https://msdn.microsoft.com/en-us/library/6tkce7xa.aspx),
[registry](https://msdn.microsoft.com/en-us/library/x05fawxd.aspx),
[http](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384106.aspx),
[wmi](https://en.wikipedia.org/wiki/Windows_Management_Instrumentation) ...)

* Compatibility: within browsers, JavaScript is available almost everywhere. I will discover later that
[NodeJS](https://nodejs.org/) also provides compatibility through command lines.

I decided to invest my personal time learning more about the language.

!/[You want me to buy a subscription to the 'JavaScript Journal'?](https://ArnaudBuchholz.github.io/blog/post/
gpf-js presentation/docbrownb61406.jpg)

Because I am a [lazy developer](http://threevirtues.com/), I created a series of command line tools (using cscript) to
automate some of my tasks. This later became a unified toolkit that was adopted by several teams to help them in
their daily job.

Also, as I am curious and my son likes Pokemon, I started to create a
[card game simulator](http://buchholz.free.fr/PokeMul/).

From the tools I obtained a collection of JavaScript helpers (consolidated in a library), a good understanding of the
language basics and a nice sense of debugging with printouts. On the other hand, the game helped me to experiment object
oriented programming with JavaScript and all the troubles (...I mean fun stuff...) related to web development.

So far, I had not been exposed to any framework: I started with jQuery on the game development but I quickly realized
I was using only the query selector API. I have to say that it has been a chance: I forced myself to learn all the
basics of web development with [vanilla JavaScript](http://vanilla-js.com/).

### Canadian experience with JavaScript

Then, I had to quit my job to move to Canada.

!/[It's cold out there](https://ArnaudBuchholz.github.io/blog/post/gpf-js presentation/20130403-234545.jpg)

As I have been quite successful with my card game simulator, I found a job as a web developer in a startup.
This is where I discovered [ExtJS](https://www.sencha.com/products/extjs/) and its
[build process](https://www.sencha.com/products/extjs/cmd-download/). I also got familiar with NodeJS by creating tools
to analyzes the code or to mock the server.

Later I moved to another company that was relying on [AngularJS](https://angularjs.org/).
Quickly, I became fluent with the framework and the tooling associated to the web development (such as
[grunt](http://gruntjs.com/)).

Now I work for a big company where I use my JavaScript expertise to build cloud solutions.

### The idea

From these experiences, I learned a lot. I have also been frustrated because I knew I was only scratching the surface
of something bigger. When you look at the number of [libraries and frameworks](https://en.wikipedia.org/wiki/
List_of_JavaScript_libraries)  that exist now, you realize how much the JavaScript language is versatile and powerful.
During my researches, I had some ideas that I wanted to put in action in order to see if they would really be helpful
or valuable.

!/[The idea](https://ArnaudBuchholz.github.io/blog/post/gpf-js presentation/docs idea.jpg)

Basically, my flux capacitor is composed of:
* A unified class definition formalism ([gpf.define](https://github.com/ArnaudBuchholz/gpf-js/blob/
e6982dd33568f9d2a6fc6d9ee919ab0fae96bfa9/test/define.js#L16-L28))
* Attributes to configure / alter those classes in a declarative way ([gpf.attributes.Attribute](https://github.com/
ArnaudBuchholz/gpf-js/blob/e6982dd33568f9d2a6fc6d9ee919ab0fae96bfa9/test/attributes.js#L15-L36))
* A unified [event handling](https://github.com/ArnaudBuchholz/gpf-js/blob/master/test/events.js) mechanism (callbacks
or [promises](https://github.com/ArnaudBuchholz/gpf-js/blob/28191a4bebb294fd2a244f0974402a434b554245/test/
events.js#L358-L390))
* Interfaces ([gpf.interfaces.Interface](https://github.com/ArnaudBuchholz/gpf-js/blob/
e6982dd33568f9d2a6fc6d9ee919ab0fae96bfa9/test/interfaces.js#L52-L81)): in particular the
[stream ones](https://github.com/ArnaudBuchholz/gpf-js/blob/master/test/interfaces/stream.js).

So I started to develop a library (not a framework, reasons detailed below) that would help me implement these.

Because it is my own project, I also wanted to come through the following challenges:
* A real source repository ([GitHub](https://github.com/ArnaudBuchholz/gpf-js/))
* [Interoperability](https://en.wikipedia.org/wiki/Software_portability) with different hosts (NodeJS, browser, cscript
and later Rhino...) and versions of JavaScript (through [polyfills](https://en.wikipedia.org/wiki/Polyfill))
* A custom [minification](https://en.wikipedia.org/wiki/Minification_(programming) process to experiment optimizations
* [TDD, TDD, TDD](https://en.wikipedia.org/wiki/Test-driven_development)

## Building a library

### Framework vs library

First of all, I would like to clarify my vision of the difference between a framework and a library.

(...) Please note that it is a personal interpretation based on my experience. Don't read it as a universal definition
to all existing frameworks or libraries.

On one hand, a framework is designed to simplify complex tasks with the objective of building a given result (such as
a single page application). Usually, it helps you building something faster but at the cost of forcing the developer to
understand and apply its specific logic. As soon as you want to escape from the expected structure, things are
getting ugly. This last sentence is obviously moderated by the capacity of the framework to accepts these changes but
some simply don'). In that sense, [ExtJS](https://www.sencha.com/products/extjs/) and
[AngularJS](https://angularjs.org/) are frameworks.

On the other hand, a library solves a problem with a narrowed scope: it doesn't try to do everything.
In that sense, [jQuery](https://jquery.com/) and [backbone.js](http://backbonejs.org/) are libraries.

Looking at what I want to achieve, I am trying to create a collection of helpers to simplify the JavaScript development
in general.

### Organizing sources

!/[Let's rock !](https://ArnaudBuchholz.github.io/blog/post/gpf-js presentation/Amplifier.jpg)

The very first library I created in JavaScript was a big mess (script.lib.js, for those who still use it... sorry):

* Everything was written in a single - huge - file... maintained on my drive (versioning was done by zipping the file
and renaming it manually)
* I had no clue about the minification tools so I named my variables with single letters and a comment to know what
they were used for (the worst thing to do). Then, a simple command line was stripping the comments as well as the
unnecessary formatting characters to generate the 'release' build.

For instance, I wrote:
`function capitalize(s/*string*/) {
    return s/*string*/[0].toUpperCase() + s/*string*/.substr(1);
}
`

To generate:
`function capitalize(s) {return s[0].toUpperCase()+s.substr(1);}`

    * I had no clear understanding of private scoping so everything was created globally (and easily 'hackable')

I learned by making mistakes and, after several attempts, I came up with a better organization:

* Features are grouped by modules, a module is a single JavaScript source file (for instance:
[error](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/error.js))
* Modules are not using any private context (using classical [IIFE](https://en.wikipedia.org/wiki/
Immediately-invoked_function_expression)), this is injected afterward by the build process (see next part)
* Each module may import and export 'internals': the [linters global & exported keywords](https://github.com/
ArnaudBuchholz/gpf-js/blob/3f950527beb10ef44e999da391d71a61d0f76f0e/src/error.js#L3-L6) are leveraged to consolidate
(and check) the list of dependencies and update the documentation within each module (this is done with
[make/globals.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/make/globals.js))
* The list of modules is consolidated in a unique [source file](https://github.com/ArnaudBuchholz/gpf-js/blob/master/
src/sources.js): a [marker](https://github.com/ArnaudBuchholz/gpf-js/blob/
3f950527beb10ef44e999da391d71a61d0f76f0e/src/sources.js#L42) decides which modules are in the library.

I even wrote a [coding guideline](https://github.com/ArnaudBuchholz/gpf-js/blob/master/CODESTYLE.md) !

### Minification & build process

When you develop a library, you must think about its publication (or at least the way you want to use it):
ideally, you produce a single file that has been minified (to reduce its size) and possibly obfuscated (you may want to
protect some of your code).

(...) A quick note about obfuscation: it is impossible to fully obfuscate the JavaScript code.
At least, you can make it really hard to read for someone who wants to reverse engineer it but, in the end, the browser
needs a valid JavaScript source to run it.

Once the sources are organized, a workflow must be set up to concatenate them and generate the result.

A long time ago, I documented my thoughts in an article about
[Release and debug versions](http://gpf-js.blogspot.ca/2013/04/release-and-debug-versions.html).

Here again, I made several mistakes regarding the build process:

* I did not automate this process from the beginning... this was addressed later using [grunt](http://gruntjs.com/)
(I will come to that later)
* I had troubles with the first results: how do you validate that the generated file works as expected? I had to build
a complete test database (TDD!)
* I wanted to experiment conditional building (#ifdef) & optimizations (inlines - not done yet)
* Initially, I wanted to do the minification by myself... but how do you parse JavaScript? I first tried to parse it
manually. Indeed, I have a working tokenizer (that is used for syntax highlighting) but the
[JavaScript grammar](https://github.com/pegjs/pegjs/blob/master/examples/javascript.pegjs) is complex. That's why I
now rely on AST generation done by [esprima](http://esprima.org/index.html). The structure is manipulated and the code
rewrote using [escodegen](https://github.com/estools/escodegen). However, the list of transformations to apply in order
to reach a good ratio is huge... for a very small benefit if you think that some tools already exist.
So I integrated the [Google Closure Compiler](https://developers.google.com/closure/compiler/) to compress the release
version.

The AST transformation is also used to inject the different modules inside an
[Universal Module Definition](https://github.com/umdjs/umd) [adapted](https://github.com/ArnaudBuchholz/gpf-js/blob/
master/make/UMD.js) for my needs.
As a consequence, the library can be used in all the environment in the most natural way:

* require for [NodeJS](https://nodejs.org/api/modules.html) and [PhantomJS](http://phantomjs.org/api/system/)
* as a [script tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) for browsers
* using [load ](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino/Shell#load.28.5Bfilename.2C_....5D.29]
in Rhino
* as an include inside WSG

In end, the library comes in three flavors:
* The **source** version: done by loading the [boot.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/
boot.js) module
* The **[debug](https://github.com/ArnaudBuchholz/gpf-js/blob/master/build/gpf-debug.js)** version: the non-minified
concatenated-like version
* The **[release](https://github.com/ArnaudBuchholz/gpf-js/blob/master/build/gpf.js)** version: the minified & optimized
concatenated-like version

## Javascript Development (with a capital D)

### Linters

A [linter](https://en.wikipedia.org/wiki/Lint_(software%29) is a tool that validates the code while you are typing it.
It identifies common errors (undeclared or unused variables, missing semi-column characters... and many more) and
preferences can be defined through [configuration](https://github.com/ArnaudBuchholz/gpf-js/blob/master/.jshintrc).

The first time I have been exposed to [JSHint](http://jshint.com/) it was in a professional environment (my first
Canadian experience). I was annoyed by the tool as it blocked most of my pushes to the repository.
At that time, I was convinced that my code style was perfect and I saw the errors as meaningless (they were mainly
styling errors).

But, after some time, I understood (and acknowledged) the two great advantages of using it:

* It eliminates common errors: as the JavaScript code does not require compilation to be used, this step checks the
code. Otherwise, until the faulty line is evaluated, you have no clue about the error.
* When working in a team, this tool ensures that everybody applies the same formatting rules and conventions. You may
also forbid specific syntaxes such as the use of the [ternary operator](https://en.wikipedia.org/wiki/%3F:).
It is a way to produce uniform code (and it is also useful when working alone on a big project).

So I integrated JShint at the beginning of 2014 and it actually took me a long time to adapt the code accordingly.

Sooner this year, I wrote an article about [Code analysis](http://gpf-js.blogspot.ca/2015/01/code-analysis.html).

Actually, I discovered [ESLint](http://eslint.org/) after writing this article. I was interested in building custom
rules (as you can read in the above link) and I checked what I could do with ESLint. This tool offers more options
and it has a unique custom rule mechanism based on AST parsing.
All [rules](http://eslint.org/docs/rules/) are clearly documented and, for each of them, you may decide either:
* to ignore it
* to generate a warning
* to generate an error

To be honest, I am not convinced with the value of generating warnings if they are not blocking the build process.
The only reason would be to raise attention to specific issues that can be addressed later but, in the end, you need
to force the developer to act or you will suffer the [broken window effect](https://en.wikipedia.org/wiki/
Broken_windows_theory).

Enabling ESlint also took me a while because I had to review all rules to [configure it](https://github.com/
ArnaudBuchholz/gpf-js/blob/master/.eslintrc) and then modify the code (again).

(...) Also, at that time, I drastically refined the complexity settings ([max-depth](http://eslint.org/docs/rules/
max-depth), [max-params](http://eslint.org/docs/rules/max-params) and [max-statements](http://eslint.org/docs/rules/
max-statements)) in order to improve the code quality.

### Grunt

It is all about automation.

**http://backtothefuture.wikia.com/wiki/Automatic_dog_feeder**

As a lazy developer, I don't like to do the same thing twice. Hence, I try to automate my tasks as much as possible.
It all started with DOS command lines but I was concerned about the portability of the project.
When looking at free [Continuous Integration](https://en.wikipedia.org/wiki/Continuous_integration)
platforms (like [Travis CI](https://travis-ci.org/)), they expect standard tools to be configured.

So I started to integrate [grunt](http://gruntjs.com/) in may 2015: I started with JSHint and then I automated the tests
execution.

Now, these tasks are automated through Grunt:

* JSHint & ESLint code validation
* Code coverage evaluation and statistics update into the [README.md](https://github.com/ArnaudBuchholz/gpf-js/blob/
master/README.md) with [metrics.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/make/metrics.js)
* Plato execution (see below)
* Tests execution (NodeJS, PhantomJS, Rhino, cscript)
* Build process ([make.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/make/make.js))
* Publication to the [public repository](https://github.com/ArnaudBuchholz/ArnaudBuchholz.github.io)

By the way, I recommend reading [Supercharging your Gruntfile](http://www.html5rocks.com/en/tutorials/tooling/
supercharging-your-gruntfile/).

I also learned how to generate the configuration 'on the fly'.
Indeed, the power of Grunt comes from the fact that the configuration file ([gruntfile.js](https://github.com/
ArnaudBuchholz/gpf-js/blob/master/gruntfile.js)) is a JavaScript file that is evaluated within NodeJS.

(...) Some may protest that Gulp is way better than Grunt. I checked some articles (just google [Grunt vs Gulp](https://
www.google.com/search?q=Grunt+vs+Gulp)) but it reminds me the good old debates (Atari vs Amiga, Nintendo vs Sega,
PC vs Console...). It may be true but Grunt does the job.

### Test Driven Development

One of my last article was about [My own BDD implementation](http://gpf-js.blogspot.ca/2015/10/
my-own-bdd-implementation.html).

I won't repeat here the benefits of testings but his actually came late in my project.
Coverage

    BDD

    Mocha

    Jasmine

    qUnit

    My Own BDD implementation

### Code coverage

    Once the code is tested, how do you make sure that every line of code is actually tested? On the contrary, are sure
    that every line of code you wrote makes sense? The only way to know is to use tools that measure the code coverage.

    Istanbul with a hack for generated functions (interesting part)

### Code analysis

    How do you quantify the quality of your code? using code coverage or making sure that your linters do not generate
    any error? Is it really enough?

    Plato is a tool that go over your library and computes intersting stats such as the maintanability factor or the
    bugs ratio.

### GitHub

    Do I have to present GitHub?

## Lessons learnt

Document your code: you will learn about yourself !

Clean code & clean coder lessons
    [software craftsmanship](https://en.wikipedia.org/wiki/Software_craftsmanship).

Time management (personal time & GitHub)

I remember a comic strip I read a long time ago with this cartoonist being asked what he did to learn drawing (and
being like accused of having a gift). His answer was really funny as he just said that it was a matter of practicing and
working. Actually, this is the same for any kind of activity.

"C'est en forgeant que l'on devient forgeron" with the best translation I found being "You have to do your craft".

This is so true.


</code>
<!-- Drop those two lines -->
</div>
</div>
