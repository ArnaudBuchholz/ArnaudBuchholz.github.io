<script language="javascript" src="../include.js"></script>
<script language="javascript" src="../export.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    How I learned from a crazy idea
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>
<div class="summary">
    <img src="https://ArnaudBuchholz.github.io/blog/student.png" align="left">
</div>
<code class="markdown">

## The idea

I have **millions of ideas**: some are stupid *(and it's ok)* and some may be interesting.
Sadly, for most of them, **time and resources are missing** to shape them properly.
Somehow, we all have to **choose our battles**.

But, from time to time, **that crazy idea which doesn't make sense** comes up and it would be really **cool to try** it.

This is more or less **how the [GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js) project started**.
Building a library supporting most of the hosts existing at that time and that would allow experimenting some cool
concepts with JavaScript was appealing (classes, interfaces, streams, documentation generation, TDD, code
coverage, backward compatibility testing...).

So far, it is a success since **a lot was learned from that experience**.

Today, I am working on a side project that requires a backend to publish data. Obviously, the
implementation started with NodeJS and it was and good opportunity to push my ES6 knowledge a little bit further.

The project reached the point where **some features of the library could be leveraged**.

This means that it needs to **[support ES6 code](https://github.com/ArnaudBuchholz/gpf-js/issues/303)**.

However, since the library is designed to support many hosts (and some of them are deprecated), it somehow
sets the language support to quite a low standard (some may say 'old' JavaScript).

(...) [Transpiling](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them) could have been
an option but some hosts are not even supporting the resulting code.

Among the [exposed api](https://arnaudbuchholz.github.io/gpf/doc/index.html), there is an entry point to **define
classes: [gpf.define](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.define__anchor)**.
Inheritance is specified by setting the $extend property in the
[entity definition](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html).

The library even offers a [$super](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html) helper to
**facilitate calling the base class method** whenever it makes sense.

So far so good.

But what would happen if one applies this helper with an ES6 class?

`const gpf = require("gpf-js")

class A {
  constructor () {
    this._a = "A"
  }
}

const B = gpf.define({
  $class: "B",
  $extend: A,
  constructor: function () {
    this.$super()
    this._b = "B"
  }
})

const b = new B();`

The result is: TypeError: Class constructor A cannot be invoked without 'new'

[See it on runkit](https://runkit.com/arnaudbuchholz/5c3f75a55e78ac001246366b)

And then starts the journey...

## How do we build a JavaScript class

There are many ways to build a class and implement inheritance in JavaScript but
here is the pattern used in GPF-JS
function NewClass () {}
NewClass.prototype = Object.create(BaseClass.prototype)

calling base class: BaseClass.apply(this, arguments)
or make use of GPF-JS $super

This leverages prototype inheritance and ensures proper results when using instanceof operator

## How do we build an ES6 class

class NewClass extends BaseClass {
}

calling base class: super()

NewClass is actually a function

## How do we build an ES6 class extending a JavaScript class

Very simply

Does super works?

## How do we build a JavaScript class extending an ES6 class

    Problems

    Constructor can't be call without the keyword new
    Reflect.construct => returns a new object
    Tried to create a new class and use super

Working code:

window.onerror = e => alert(e)

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

alert(B.toString())

function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

const C = (function () {
  function C () {
    let instance
    const $super = function () {
        instance = Reflect.construct(B, arguments, C)
    }
    const proxy = new Proxy({}, {
    	get: function (obj, property) {
        if (property === '$super') {
          return $super
        }
        return instance[property]
      },
      set: function (obj, property, value) {
        instance[property] = value
      }
    })
    constructorOfC.apply(proxy, arguments)
    return instance
  }
  C.prototype = Object.create(B.prototype)
  return C
}())

var c = new C("test2");

alert([
  "OK",
  "_a: " + c._a,
  "is A: " + (c instanceof A),
  "_b: " + c._b,
  "is B: " + (c instanceof B),
  "_c: " + c._c,
  "is C: " + (c instanceof C),
  "_param: " + c._param,
  "_param2: " + c._param2
].join("\n\t"))

</code>
</div>
</div>
