<script language="javascript" src="../include.js"></script>
<script language="javascript" src="../export.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    How I learned from a crazy idea
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<div class="summary">
    <img src="https://ArnaudBuchholz.github.io/blog/student.png" align="left">
    According to wikipedia, a particle accelerator is a machine that uses eletromagnetic fields to propel charged
    particles to very high speed and energies. A collider accelerator causes them to collide head-on, creating
    observable results scientists can learn from.
    <br/>
    Sometimes, I feel like an idea collider accelerator producing interesting experiments I can learn from.
</div>
<code class="markdown">

![CERN / LHC tunnel](https://arnaudbuchholz.github.io/blog/post/How%20I%20learned%20from%20a%20crazy%20idea/5680466430_fb62b00e17_b.jpg)
(photo of CERN / LHC tunnel from [Ars Electronica](https://www.flickr.com/photos/arselectronica/5680466430))

## The idea

I have **millions of ideas**: some are stupid *(and it's ok)* and some may be interesting.
Sadly, for most of them, **time and resources are missing** to shape them properly.
Somehow, we all have to **choose our battles**.

On rare occasions, **that crazy idea which doesn't make sense** comes up... and it would be really **cool to try** it.

This is more or less **how the [GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js) project started** several
years ago.
Building a library supporting most of the hosts existing at that time and that would allow experimenting some cool
concepts with JavaScript was appealing (classes, interfaces, streams, documentation generation, TDD, code
coverage, backward compatibility testing...).

So far, it is a success since **a lot was learned from that experience**:
* [My own require implementation](https://gpf-js.blogspot.com/2018/01/my-own-require-implementation.html)
* [5 ways to make an http request](https://gpf-js.blogspot.com/2017/06/5-ways-to-make-http-request.html)
* [My own super implementation](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html)
* [My own jsdoc plugin](https://gpf-js.blogspot.com/2016/12/my-own-jsdoc-plugin.html)
* [My own templates implementation](https://gpf-js.blogspot.com/2016/08/my-own-templates-implementation.html)
* [Date override](https://gpf-js.blogspot.com/2016/02/date-override.html)
* [My own BDD implementation](https://gpf-js.blogspot.com/2015/10/my-own-bdd-implementation.html)
* And all the [release notes](https://github.com/ArnaudBuchholz/gpf-js/releases) of the library

Today, I am working on a side project that requires **a backend to hold the data**. Obviously, the
implementation started with NodeJS as it is good opportunity to push my **ES6 knowledge** a little bit further.

The project reached the point where **some features of the library could be leveraged**.

This means that it needs to **[support ES6 code](https://github.com/ArnaudBuchholz/gpf-js/issues/303)**.

However, since the library is designed to be compatible with so many hosts (and some of them are deprecated), it somehow
sets the language support to quite a low standard (some may say 'old' JavaScript).

(...) [Transpiling](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them) could have been
an option but some hosts are not even supporting the resulting ES5 code.

Among the [exposed api](https://arnaudbuchholz.github.io/gpf/doc/index.html), there is an entry point to **define
classes: [gpf.define](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.define__anchor)**.
Inheritance is specified by setting the $extend property in the
[entity definition](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html).

The library even offers a [$super](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html) helper to
**facilitate calling the base class method** whenever it makes sense.

So far so good.

But **what would happen if** one applies this helper with an ES6 class?

`const gpf = require("gpf-js");

class A {
  constructor () {
    this._a = "A";
  }
}

const B = gpf.define({
  $class: "B",
  $extend: A,
  constructor: function () {
    this.$super();
    this._b = "B";
  }
})

const b = new B();`

The result is:

`TypeError: Class constructor A cannot be invoked without 'new'`

[See it on runkit](https://runkit.com/arnaudbuchholz/5c3f75a55e78ac001246366b)

Two **colliding ways of creating classes** producing sparks...
Let see what we can **learn** from that observable result.

## Building JavaScript classes

### The 'old' way

There are many ways to build a class and leverage
**[prototype inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)** in JavaScript
but here is **the pattern used in GPF-JS**.

A class is represented by its **constructor function**.
Every function exposes the **prototype property**, an object which members will be inherited by all instances created
with this function.

<!-- How I learned from a crazy idea / The 'old' way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/8bhgLqt6/7/embed/js,result/"></script>

To create a subclass, **a new function is needed**.

Calling the base constructor requires the **base function to be
[applied](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)** on the
newly created instance.
Also the new prototype is initialized with a **new object that 'inherits' from the base class prototype**.

<!-- How I learned from a crazy idea / The 'old' way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");

function OldB () {
  OldA.apply(this, arguments);
  this._b = "B";
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = function () {
  return this._b;
};

var b = new OldB();
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof OldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/8bhgLqt6/embed/js,result/"></script>

As mentionned previously, The **GPF-JS library facilitates calling the base class using
[this.$super()]([$super](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html)**.

### The ES6 way

The [class keyword](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class) was introduced
and the syntax is **self explanatory**.

<!-- How I learned from a crazy idea / The ES6 way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

class Es6B extends Es6A {
  constructor () {
    super();
    this._b = "B";
  }

  b () {
    return this._b;
  }
}

var b = new Es6B();
assert(() => b instanceof Es6A);
assert(() => b.a() === "A");
assert(() => b instanceof Es6B);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/b81aesr5/embed/js,result"></script>

It is interesting to verify that **Es6A and Es6B are also functions**.

<!-- How I learned from a crazy idea / The ES6 way (2)
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor (value) {
    this._a = value;
  }

  a () {
    return this._a;
  }
}

assert(() => typeof Es6A === "function");
assert(() => Es6A.length === 1);
assert(() => typeof Es6A.apply === "function");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/dtrayepf/embed/js,result"></script>

### Subclassing an 'old' class in an ES6 class

Based on the previous examples, the following code **works smoothly**.

<!-- How I learned from a crazy idea / Subclassing an 'old' class in an ES6 class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

class ExtendOldWithEs6B extends OldA {
    constructor () {
      super();
      this._b = "B";
    }

    b () {
      return this._b;
    }
}

var b = new ExtendOldWithEs6B();
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof ExtendOldWithEs6B);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/hqb490wL/embed/js,result"></script>

### Subclassing an ES6 class in an 'old' class

So the code presented in the introduction almost **looks like the following**.
It obviously leads to the **same error**.

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

function ExtendEs6WithOldB () {
  Es6A.apply(this, arguments);
  this._b = "B";
}

ExtendEs6WithOldB.prototype = Object.create(Es6A.prototype);

ExtendEs6WithOldB.prototype.b = function () {
  return this._b;
};

var b = new ExtendEs6WithOldB();
assert(() => b instanceof Es6A);
assert(() => b.a() === "A");
assert(() => b instanceof ExtendEs6WithOldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/1kbozc3w/embed/js,result"></script>

## Class constructor cannot be invoked without 'new'

If you think twice about the old way of creating classes, this error fully makes sense.
Indeed, in the old way, there is **no difference between a normal function and a class constructor**.
As a result, both could be either invoked or called with the
[new keyword](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).

However, all JavaScript functions are not **constructors**.

Indeed, most **native methods** are secured:

<!-- How I learned from a crazy idea / all functions are not constructors
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
const substring = String.prototype.substring;
assert(() => typeof substring === "function");
const instance = new substring();
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/a96gfdm1/embed/js,result"></script>

When it comes to the new syntax, **the intention of the developper** is to build a function that will be used to create
instances. As a consequence, **the language doesn't expect this function to be invoked for a simple function call**.

### Reproduce the behavior in the 'old' way

Actually, it is possible to reproduce this behavior with the 'old' syntax.
The new operator will instantiate a new object and pass it to the function invocation.
This means that **testing [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with
[instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) will do the
trick**.

<!-- How I learned from a crazy idea / Reproduce the behavior in the 'old' way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  if (!(this instanceof OldA)) {
    throw new TypeError("Class constructor cannot be invoked without 'new'");
  }
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");
assert(() => OldA());

function OldB () {
  OldA.apply(this, arguments);
  this._b = "B";
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = function () {
  return this._b;
};

var b = new OldB();cd
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof OldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/tauek0pL/embed/js,result/"></script>

Note that, in this case, the base constructor call works since **any instance of OldB is also an instance of OldA**.

(...) This behavior is already
[implemented](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.2.8/src/define/class/constructor.js#L59) in GPF-JS.

(...) Again, there were many ways to create classes before the introduction of the class keyword. Some may disagree with
the use of instanceof. To be fair and complete, I invite you to check the article [JavaScript Factory Functions vs
Constructor Functions vs Classes](https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor
-functions-vs-classes-2f22ceddf33e) from Eric Elliott.

### Notable differences between the two ways of creating class

As explained previously in the 'Old' way of creating classes, the base constructor is called by applying the base
function on this. However, there is **no limitation on when the base constructor can be applied**. Actually, you can
start leveraging the newly created instance even **before it was properly built**.

<!-- How I learned from a crazy idea / Notable differences (Old way)
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");

function OldB () {
  this._b = "B"; // Use this before it was properly built
  OldA.apply(this, arguments);
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = function () {
  return this._b;
};

var b = new OldB();
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof OldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/t8ef1p5y/embed/js,result/"></script>

That's something that has been enforced in ES6 since **it is not possible to use this before calling the
[super](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) constructor**.

<!-- How I learned from a crazy idea / Notable differences (ES6 way)
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

class Es6B extends Es6A {
  constructor () {
    this._b = "B";  // Use this before it was properly built
    super();
  }

  b () {
    return this._b;
  }
}

var b = new Es6B();
assert(() => b instanceof Es6A);
assert(() => b.a() === "A");
assert(() => b instanceof Es6B);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/wxa30178/embed/js,result"></script>

The result shows:
`Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor`

### Detecting an ES6 class constructor

Since the library will have to deal with ES6, it needs **a safe way to detect such constructors**.
Actually, this is done by **converting the function to string and by checking it contains the class keyword**.

<!-- How I learned from a crazy idea / Detecting an ES6 class constructor
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

function isES6Constructor (constructor) {
  return constructor.toString().startsWith("class");
}

assert(() => !isES6Constructor(OldA));
assert(() => isES6Constructor(Es6A));
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/prg4L5mk/embed/js,result"></script>

<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>

## Subclassing an ES6 class in an 'old' class

Now that we understand why it does not work, let's **try to find a way to make it work in the GPF-JS**.

### ConstructorOfB

Let start by setting the right expectations, we will assume that:
* gpf.define will be used with a dictionary specifying the $extend property pointing to a class constructor
* a constructor property will be provided implemented in 'Old' JavaScript
* this.$super will be called to invoke the base constructor
* If this.$super is not called before any use of this, the construction should fail

To validate the implementation, we will start with the following statements:

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
function C () { }

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");

### Non-sense idea

'convert' constructorOfC into a class definition and replace this.$super(...) with super(...)

Could have worked *but* we loose the enclosed context of constructorOfC

### Attempt number 1

class C extends B {
    $super () {
        super
    }
    constructor (param2) {
        constructorOfC.apply(this, arguments)
    }
}

## Attempt number 2

Since we can dynamically build a class, we could simply inject the content of the constructor in the class constructor.

Pr

## Attempt number 3

Wait for $super to be evaluated, throw an exception and re-execute the constructor with the proper this

## Attempt number 4

Create a wrapper that

function Ces6 () {
  var that;
  function $super() {
    that = Reflect.construct(B, arguments, C)
  }
  var newC = Object.create(C.prototype);
  newC.$super = $super;
  Object.defineProperty(newC, "_c", {
    get: function () {
      return that._c
    },
    set: function (value) {
      that._c = value
    }
  })
  C.apply(newC, arguments);
  return that;
}




## Attempt number 5

The Proxy object

window.onerror = e => alert(e)

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

alert(B.toString())

function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

const C = (function () {
  function C () {
    let instance
    const $super = function () {
        instance = Reflect.construct(B, arguments, C)
    }
    const proxy = new Proxy({}, {
    	get: function (obj, property) {
        if (property === '$super') {
          return $super
        }
        return instance[property]
      },
      set: function (obj, property, value) {
        instance[property] = value
      }
    })
    constructorOfC.apply(proxy, arguments)
    return instance
  }
  C.prototype = Object.create(B.prototype)
  return C
}())

var c = new C("test2");

alert([
  "OK",
  "_a: " + c._a,
  "is A: " + (c instanceof A),
  "_b: " + c._b,
  "is B: " + (c instanceof B),
  "_c: " + c._c,
  "is C: " + (c instanceof C),
  "_param: " + c._param,
  "_param2: " + c._param2
].join("\n\t"))

</code>
</div>
</div>
