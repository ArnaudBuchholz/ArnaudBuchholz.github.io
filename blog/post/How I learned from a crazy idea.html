<script language="javascript" src="../include.js"></script>
<script language="javascript" src="../export.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    How I learned from a crazy idea
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<div class="summary">
    <img src="https://ArnaudBuchholz.github.io/blog/student.png" align="left">
    According to wikipedia, a particle accelerator is a machine that uses eletromagnetic fields to propel charged
    particles to very high speed and energies. A collider accelerator causes them to collide head-on, creating
    observable results scientists can learn from.
    <br/>
    Sometimes, I feel like an idea collider producing experiments I can learn from.
</div>
<code class="markdown">

![CERN / LHC tunnel](https://arnaudbuchholz.github.io/blog/post/How%20I%20learned%20from%20a%20crazy%20idea/5680466430_fb62b00e17_b.jpg)
(photo of CERN / LHC tunnel from [Ars Electronica](https://www.flickr.com/photos/arselectronica/5680466430))

## The idea

I have **millions of ideas**: some are stupid *(and it's ok)* and some *may* be interesting.
Sadly, for most of them, **time and resources are missing** to shape them properly.
Somehow, we all have to **choose our battles**.

On rare occasions, **that crazy idea which doesn't make sense** comes up... and it would be really **cool to try** it.

This is more or less **how the [GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js) project started** several
years ago.
Building a library supporting most of the hosts existing at that time and that would allow experimenting some cool
concepts with JavaScript was appealing (classes, interfaces, streams, documentation generation, TDD, code
coverage, backward compatibility testing...).

So far, it is a success since **a lot was learned from that experience**:
* [My own require implementation](https://gpf-js.blogspot.com/2018/01/my-own-require-implementation.html)
* [5 ways to make an http request](https://gpf-js.blogspot.com/2017/06/5-ways-to-make-http-request.html)
* [My own super implementation](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html)
* [My own jsdoc plugin](https://gpf-js.blogspot.com/2016/12/my-own-jsdoc-plugin.html)
* [My own templates implementation](https://gpf-js.blogspot.com/2016/08/my-own-templates-implementation.html)
* [Date override](https://gpf-js.blogspot.com/2016/02/date-override.html)
* [My own BDD implementation](https://gpf-js.blogspot.com/2015/10/my-own-bdd-implementation.html)
* And all the [release notes](https://github.com/ArnaudBuchholz/gpf-js/releases) of the library

Today, I am working on a side project that requires **a backend to hold the data**. Obviously, the
implementation started with NodeJS as it is good opportunity to push my **ES6 knowledge** a little bit further.

The project reached the point where **some features of the GPF-JS library could be leveraged**.

This means that the library needs to **[support ES6 code](https://github.com/ArnaudBuchholz/gpf-js/issues/303)**.

However, since it is designed to be compatible with so many hosts *(and some of them are deprecated)*, it somehow
sets the language support to quite a **low standard (some may say 'old' JavaScript)**.

(...) [Transpiling](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them) could have been
an option but some hosts are not even supporting the resulting ES5 code.

Among the [exposed api](https://arnaudbuchholz.github.io/gpf/doc/index.html), there is an entry point to **define
classes: [gpf.define](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.define__anchor)**.
Inheritance is specified by setting the *$extend* property in the
[entity definition](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html).

The library even offers a [$super](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html) helper to
**facilitate calling the base class method** whenever it makes sense.

So far so good.

But **what would happen if** one applies this helper with an ES6 class?

`const gpf = require("gpf-js");

class A {
  constructor () {
    this._a = "A";
  }
}

const B = gpf.define({
  $class: "B",
  $extend: A,
  constructor: function () {
    this.$super();
    this._b = "B";
  }
})

const b = new B();`

The result is:

`TypeError: Class constructor A cannot be invoked without 'new'`

(...) Before going any further, it is important to check that your browser supports the ES6 syntax. If you are using
Internet Explorer please switch to a different application.

[See it on runkit](https://runkit.com/arnaudbuchholz/5c3f75a55e78ac001246366b)

Two **colliding ways of creating classes** producing sparks...
Let see what can be **learned** from that.

## Building JavaScript classes

### The 'old' way

There are many ways to build a class and leverage
**[prototype inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)** in JavaScript
but here is **the pattern used in GPF-JS**.

A class is represented by its **constructor function**.
Every function exposes the **prototype property**, an object which members will be inherited by all instances created
with this function.

<!-- How I learned from a crazy idea / The 'old' way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/8bhgLqt6/7/embed/js,result/"></script>

To create a subclass, **a new function is needed**.

Calling the base constructor requires the **base function to be
[applied](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)** on the
newly created instance.
The new prototype is initialized with an **object that 'inherits' from the base class prototype** thanks
to [Object.create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).

<!-- How I learned from a crazy idea / The 'old' way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");

function OldB () {
  OldA.apply(this, arguments);
  this._b = "B";
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = function () {
  return this._b;
};

var b = new OldB();
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof OldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/8bhgLqt6/embed/js,result/"></script>

As mentionned previously, The **GPF-JS library facilitates calling the base class using
[this.$super()]([$super](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html)**.

### The ES6 way

The [class keyword](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class) was introduced
and the syntax is **self explanatory**.

<!-- How I learned from a crazy idea / The ES6 way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

class Es6B extends Es6A {
  constructor () {
    super();
    this._b = "B";
  }

  b () {
    return this._b;
  }
}

var b = new Es6B();
assert(() => b instanceof Es6A);
assert(() => b.a() === "A");
assert(() => b instanceof Es6B);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/b81aesr5/embed/js,result"></script>

It is interesting to observe that **Es6A and Es6B are also functions**.

<!-- How I learned from a crazy idea / The ES6 way (2)
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor (value) {
    this._a = value;
  }

  a () {
    return this._a;
  }
}

assert(() => typeof Es6A === "function");
assert(() => Es6A.length === 1);
assert(() => typeof Es6A.apply === "function");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/dtrayepf/embed/js,result"></script>

### Subclassing an 'old' class in an ES6 class

Good news, based on the previous examples, the following code **works smoothly**.

<!-- How I learned from a crazy idea / Subclassing an 'old' class in an ES6 class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

class ExtendOldWithEs6B extends OldA {
    constructor () {
      super();
      this._b = "B";
    }

    b () {
      return this._b;
    }
}

var b = new ExtendOldWithEs6B();
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof ExtendOldWithEs6B);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/hqb490wL/embed/js,result"></script>

### Subclassing an ES6 class in an 'old' class

So the code presented in the introduction almost **looks like the following snippet**.
It obviously leads to the **same error**.

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

function ExtendEs6WithOldB () {
  Es6A.apply(this, arguments);
  this._b = "B";
}

ExtendEs6WithOldB.prototype = Object.create(Es6A.prototype);

ExtendEs6WithOldB.prototype.b = function () {
  return this._b;
};

var b = new ExtendEs6WithOldB();
assert(() => b instanceof Es6A);
assert(() => b.a() === "A");
assert(() => b instanceof ExtendEs6WithOldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/1kbozc3w/embed/js,result"></script>

## Class constructor cannot be invoked without 'new'

If you think about the old way of creating classes, this error fully makes sense.
Indeed, in the old way, there is **no stntaxic difference between a normal function and a class constructor**.
As a result, both could be either invoked or called with the
[*new* keyword](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).

However, all JavaScript functions are not **constructors**.

Indeed, most **native methods** are secured:

<!-- How I learned from a crazy idea / all functions are not constructors
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
const substring = String.prototype.substring;
assert(() => typeof substring === "function");
const instance = new substring();
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/a96gfdm1/embed/js,result"></script>

When it comes to the new syntax, **the intention of the developper** is to build a function that will be used to create
instances. As a consequence, **the language doesn't expect this function to be invoked for a simple function call**.

### Reproduce the behavior in the 'old' way

It is possible to reproduce this behavior with the 'old' syntax.
The *new* operator will instantiate an object and pass it during the **function invocation**.
This means that **testing [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with
[instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) will do the
trick**.

<!-- How I learned from a crazy idea / Reproduce the behavior in the 'old' way
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  if (!(this instanceof OldA)) {
    throw new TypeError("Class constructor cannot be invoked without 'new'");
  }
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");
assert(() => OldA());

function OldB () {
  OldA.apply(this, arguments);
  this._b = "B";
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = function () {
  return this._b;
};

var b = new OldB();cd
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof OldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/tauek0pL/embed/js,result/"></script>

Note that, in this implementation pattern, the base constructor call works because **any instance of OldB is also an
instance of OldA**.

(...) This behavior is already
[implemented](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.2.8/src/define/class/constructor.js#L59) in GPF-JS.

(...) Again, there were many ways to create classes before the introduction of the class keyword. Some may disagree with
the use of instanceof. To be fair and complete, I invite you to check the article [JavaScript Factory Functions vs
Constructor Functions vs Classes](https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor
-functions-vs-classes-2f22ceddf33e) from Eric Elliott who exposes a different point of view.

### Notable differences between the two ways of creating class

As explained previously in the 'Old' way of creating classes, the base constructor is called by applying the base
function on *this*. However, there is **no limitation on when the base constructor can be applied**. Futhermore, it is
**not even required to call it**.

Actually, you can start leveraging the newly created instance even **before it was properly built**.

<!-- How I learned from a crazy idea / Notable differences (Old way)
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

var a = new OldA();
assert(() => a instanceof OldA);
assert(() => a.a() === "A");

function OldB () {
  this._b = "B"; // Use this before it was properly built
  OldA.apply(this, arguments);
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = function () {
  return this._b;
};

var b = new OldB();
assert(() => b instanceof OldA);
assert(() => b.a() === "A");
assert(() => b instanceof OldB);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/t8ef1p5y/embed/js,result/"></script>

It has been enforced in ES6 since **it is not possible to use *this* before calling the
[super](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) constructor**.

<!-- How I learned from a crazy idea / Notable differences (ES6 way)
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

class Es6B extends Es6A {
  constructor () {
    this._b = "B";  // Use this before it was properly built
    super();
  }

  b () {
    return this._b;
  }
}

var b = new Es6B();
assert(() => b instanceof Es6A);
assert(() => b.a() === "A");
assert(() => b instanceof Es6B);
assert(() => b.b() === "B");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/wxa30178/embed/js,result"></script>

The result shows:
`Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor`

### Detecting an ES6 class constructor

Since the library will have to deal with ES6, it needs **a safe way to detect such constructors**.
Actually, this can be done by **converting the function to string and by checking if it starts with the *class*
keyword**.

<!-- How I learned from a crazy idea / Detecting an ES6 class constructor
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js
function OldA () {
  this._a = "A";
}

OldA.prototype.a = function () {
  return this._a;
};

class Es6A {
  constructor () {
    this._a = "A";
  }

  a () {
    return this._a;
  }
}

function isES6Constructor (constructor) {
  return constructor.toString().startsWith("class");
}

assert(() => !isES6Constructor(OldA));
assert(() => isES6Constructor(Es6A));
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/prg4L5mk/embed/js,result"></script>

## Subclassing an ES6 class in an 'old' class

The 'old' pattern does not work because the **ES6 constructor can't be applied like a normal function**.
What can be done to create an 'old' class that would subclass an ES6 one?

### ConstructorOfB

First, let set the right **context and expectations**:
* *gpf.define* is used with a dictionary having the *$extend* property set to an ES6 class constructor
* a *constructor* property points to a JavaScript function
* *this.$super* is called to invoke the base constructor
* *this.$super* must be called before any use of this or the construction should fail

**To validate the implementation**, we will place it within the following statements:

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
function C () { }

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/zg70m9of/embed/js,result"></script>

### Attempt number 1

Since it is possible to **build a function from a string source**, one option consists in generating a new ES6 class
with the **constructor being filled from the content of constructorOfC**. As the constructor function is rewritten, we
can replace the use of *this.$super* with *super*.

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
var C = new Function("B", `

  return class C extends B {
    constructor ${
      /\((?:.|\n)*}$/.exec(constructorOfC)
        .toString()
        .replace("this.$super", "super")
    }
  }

`)(B);

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/zg70m9of/13/embed/js,result"></script>

(...) In the previous code, an ES6 template literal has been used to build the constructor string. This syntax would not
be allowed in the library because it would not compile on older hosts.

**It works !**

But...

You may notice that **we must pass the base class B while evaluating the dynamically created function**. This is because
the new function **does not have any context**. And this is the major drawback of this solution: If *constructorOfC* is
a closure with a specific context (for instance: accessing a global variable), **this context would be lost**.

### Attempt number 2

Considering we must keep and call constructorOfC as-is, **what happens if we can call it directly ?**.

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
class C extends B {
  $super () {
    super.construtor();
  }
  constructor (param2) {
    constructorOfC.apply(this, arguments);
  }
}

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/zg70m9of/16/embed/js,result"></script>

As *this* is called **before** *super*, it fails with:
`Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor`

## Attempt number 3

Assuming that **the base class supports instanciation with no parameters**, since we must call *super* before using
*this*, what happens if we call it first with no parameters ?

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
class C extends B {
  $super () {
    super.constructor.apply(this, arguments);
  }
  constructor (param2) {
    super();
    constructorOfC.apply(this, arguments);
  }
}

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/zg70m9of/19/embed/js,result"></script>

However, we come back to the error:
`Uncaught TypeError: Class constructor B cannot be invoked without 'new'`

## Attempt number 4

None of the previous attempts are working.

The major blocker comes from the fact that **the ES6 constructor *must* be called with *new*.**
Doing so would create a new instance of the base class but we wouldn't be able to transform it to an upper class.

After doing some research on the web, the
[Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) object came to my
attention.

In particular, the
[construct method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)
acts like the new operator, but as a function. **It is equivalent to calling new target(...args)**.
It also gives the added option to **specify a different prototype**.

So not only this helper **solves the problem of forwarding parameters during the construction** but it also allocates
a **new object with the right prototype chain**.

The method **returns a new instance: it can't be applied on an existing one**.

So I got this idea of creating a **wrapper** that would expose the **same interface than a new instance of C** but would
redirect all properties access to the right instance using [Object.defineProperties](https://developer.mozilla.org/
en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties).
On the wrapper, a *$super* method is added to call **Reflect.construct**.

As the **real instance is not created unless this.$super has been called**, this validates that super must be called
first.

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
function C () {
  var newC;
  function $super() {
    newC = Reflect.construct(B, arguments, C);
  }
  var wrapper = Object.create(C.prototype);
  wrapper.$super = $super;
  Object.defineProperty(wrapper, "_c", {
    get: function () {
      return newC._c;
    },
    set: function (value) {
      newC._c = value;
    }
  });
  Object.defineProperty(wrapper, "_param2", {
    get: function () {
      return newC._param2;
    },
    set: function (value) {
      newC._param2 = value;
    }
  });
  constructorOfC.apply(wrapper, arguments);
  return newC;
}
C.prototype = Object.create(B.prototype);

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/zg70m9of/27/embed/js,result"></script>

**It works !**

But...

The problem is that we must **redirect properties access being made on the wrapper to the instance**.
In this example, it is easy because we already know the content of the object (and its constructors).

In the library, we won't.

<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>

## Attempt number 5

So I searched again on the web to find a way to define generic properties on the wrapper.
The [Proxy object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) can be
used to define custom behavior for fundamental operations (like property lookup).

<!-- How I learned from a crazy idea / Subclassing an ES6 class in an 'old' class
// https://arnaudbuchholz.github.io/blog/jsfiddle-assert.js

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

// This is the constructor that would be provided in the gpf.define dictionary
function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

// We need a way to create a class C that inherits from B calling constructorOfC
function C () {
  let instance;
  const $super = function () {
    instance = Reflect.construct(B, arguments, C);
  }
  const proxy = new Proxy({}, {
	  get: function (obj, property) {
      if (property === '$super') {
        return $super;
      }
      return instance[property];
    },
    set: function (obj, property, value) {
      instance[property] = value;
    }
  });
  constructorOfC.apply(proxy, arguments);
  return instance;
}
C.prototype = Object.create(B.prototype);

// Validation
var c = new C("test2");
assert(() => c instanceof A);
assert(() => c._a === "A");
assert(() => c instanceof B);
assert(() => c._b === "B");
assert(() => c._param === "test");
assert(() => c instanceof C);
assert(() => c._c === "C");
assert(() => c._param2 === "test2");
-->
<script async src="//jsfiddle.net/ArnaudBuchholz/zg70m9of/30/embed/js,result"></script>

**It works !**

And I didn't find any drawback yet.

## Conclusion

As useless as it may sound, the library will not support ES6 class. But besides this feature, this small experience
introduced me to two objects which, at first sight, had no interest but that are really helpfull to solve the problems
I faced.

Regarding the support of this objects, they will be used only when an ES6 class is detected. To be able to use an ES6
class you must be on a host that also support these two objects.

</code>
</div>
</div>
