<script language="javascript" src="../include.js"></script>
<script language="javascript" src="../export.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    How I learned from a crazy idea
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>
<div class="summary">
    <img src="https://ArnaudBuchholz.github.io/blog/student.png" align="left">
</div>
<code class="markdown">

## The idea

I am currently working on a side project that requires that I integrate ES6 code with the GPF-JS library.
However, the library is designed to support many hosts (and some of them are deprecated) so I sticked to pretty 'old'
JavaScript.

The library offers many tools and some of them require a new class to be created.
The main entry point is gpf.define and one can specify the base class using the $extend property.

It even offers a $super member to facilitate calling the base class whenever it makes sense.

So far so good.

Back to the project, it is implementing a backend API with NodeJS so I decided to stick to ES6.
But then I want to subclass an ES6 class using gpf.define.

This means I need to be able to create an JavaScript class (or function) that inherits from an ES6 class.

DISCLAIMER: this obviously does not make sense and I will clearly NOT do that in production but I wanted to check if it
was possible.

## How do we build a JavaScript class

There are many ways to build a class and implement inheritance in JavaScript but
here is the pattern used in GPF-JS
function NewClass () {}
NewClass.prototype = Object.create(BaseClass.prototype)

calling base class: BaseClass.apply(this, arguments)
or make use of GPF-JS $super

This leverages prototype inheritance and ensures proper results when using instanceof operator

## How do we build an ES6 class

class NewClass extends BaseClass {
}

calling base class: super()

NewClass is actually a function

## How do we build an ES6 class extending a JavaScript class

Very simply

Does super works?

## How do we build a JavaScript class extending an ES6 class

    Problems

    Constructor can't be call without the keyword new
    Reflect.construct => returns a new object
    Tried to create a new class and use super

Working code:

window.onerror = e => alert(e)

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

alert(B.toString())

function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

const C = (function () {
  function C () {
    let instance
    const $super = function () {
        instance = Reflect.construct(B, arguments, C)
    }
    const proxy = new Proxy({}, {
    	get: function (obj, property) {
        if (property === '$super') {
          return $super
        }
        return instance[property]
      },
      set: function (obj, property, value) {
        instance[property] = value
      }
    })
    constructorOfC.apply(proxy, arguments)
    return instance
  }
  C.prototype = Object.create(B.prototype)
  return C
}())

var c = new C("test2");

alert([
  "OK",
  "_a: " + c._a,
  "is A: " + (c instanceof A),
  "_b: " + c._b,
  "is B: " + (c instanceof B),
  "_c: " + c._c,
  "is C: " + (c instanceof C),
  "_param: " + c._param,
  "_param2: " + c._param2
].join("\n\t"))

</code>
</div>
</div>
