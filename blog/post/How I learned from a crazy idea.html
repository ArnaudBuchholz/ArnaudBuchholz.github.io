<script language="javascript" src="../include.js"></script>
<script language="javascript" src="../export.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    How I learned from a crazy idea
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>
<div class="summary">
    <img src="https://ArnaudBuchholz.github.io/blog/student.png" align="left">
</div>
<code class="markdown">

## The idea

I have **millions of ideas**: some are stupid *(and it's ok)* and some may be interesting.
Sadly, for most of them, **time and resources are missing** to shape them properly.
Somehow, we all have to **choose our battles**.

But, from time to time, **that crazy idea which doesn't make sense** comes up and it would be really **cool to try** it.

This is more or less **how the [GPF-JS library](https://github.com/ArnaudBuchholz/gpf-js) project started**.
Building a library supporting most of the hosts existing at that time and that would allow experimenting some cool
concepts with JavaScript was appealing (classes, interfaces, streams, documentation generation, TDD, code
coverage, backward compatibility testing...).

So far, it is a success since **a lot was learned from that experience**.

Today, I am working on a side project that requires a backend to publish data. Obviously, the
implementation started with NodeJS and it was and good opportunity to push my ES6 knowledge a little bit further.

The project reached the point where **some features of the library could be leveraged**.

This means that it needs to **[support ES6 code](https://github.com/ArnaudBuchholz/gpf-js/issues/303)**.

However, since the library is designed to support many hosts (and some of them are deprecated), it somehow
sets the language support to quite a low standard (some may say 'old' JavaScript).

(...) [Transpiling](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them) could have been
an option but some hosts are not even supporting the resulting code.

Among the [exposed api](https://arnaudbuchholz.github.io/gpf/doc/index.html), there is an entry point to **define
classes: [gpf.define](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.define__anchor)**.
Inheritance is specified by setting the $extend property in the
[entity definition](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html).

The library even offers a [$super](https://gpf-js.blogspot.com/2017/02/my-own-super-implementation.html) helper to
**facilitate calling the base class method** whenever it makes sense.

So far so good.

But what would happen if one applies this helper with an ES6 class?

`const gpf = require("gpf-js")

class A {
  constructor () {
    this._a = "A"
  }
}

const B = gpf.define({
  $class: "B",
  $extend: A,
  constructor: function () {
    this.$super()
    this._b = "B"
  }
})

const b = new B();`

The result is: TypeError: Class constructor A cannot be invoked without 'new'

[See it on runkit](https://runkit.com/arnaudbuchholz/5c3f75a55e78ac001246366b)

And there starts the journey...

## Building JavaScript classes

### The 'old' way

There are many ways to build a class and leverage
[prototype inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance) in JavaScript but
here is the pattern used in GPF-JS.

A class is represented by its **constructor function**.
Every function exposes the **prototype object** which members will be inherited by all instances created with this
function.

`function OldA () {
  this._a = "A";
}

OldA.prototype.a = method () {
  return this._a;
};

var a = new OldA();
console.log(a instanceof OldA); // true
console.log(a.a()); // A`

To create a subclass, a new function is required.

Calling the base constructor requires a manual use of the base class function like in the next example
Also the prototype must be initialized with a new object that 'inherits' from the base class.

`function OldB () {
  OldA.apply(this, arguments);
  this._b = "B"
}

OldB.prototype = Object.create(OldA.prototype);

OldB.prototype.b = method () {
  return this._b;
};

var b = new OldB();
console.log(b instanceof OldA); // true
console.log(b.a()); // A
console.log(b instanceof OldB); // true
console.log(b.b()); // B`

The GPF-JS library facilitates calling the base class using the syntax this.$super().

### The ES6 way

The class keyword was introduced and the syntax is self explanatory.

`class Es6A {
  constructor () {
    this._a = "A"
  }

  a () {
    return this._a
  }
}

class Es6B extends Es6A {
    constructor () {
      super()
      this._b = "B"
    }

    b () {
      return this._b
    }
}

var b = new Es6B();
console.log(b instanceof Es6A); // true
console.log(b.a()); // A
console.log(b instanceof Es6B); // true
console.log(b.b()); // B`

As a result, A and B are also functions.

## How do we build an ES6 class extending a JavaScript class

Very simply

Does super works?

## How do we build a JavaScript class extending an ES6 class

    Problems

    Constructor can't be call without the keyword new
    Reflect.construct => returns a new object
    Tried to create a new class and use super

Working code:

window.onerror = e => alert(e)

class A {
  constructor () {
    this._a = "A"
  }
}

class B extends A {
  constructor (param) {
    super()
    this._b = "B"
    this._param = param
  }
}

alert(B.toString())

function constructorOfC (param2) {
  this.$super("test")
  this._c = "C"
  this._param2 = param2
}

const C = (function () {
  function C () {
    let instance
    const $super = function () {
        instance = Reflect.construct(B, arguments, C)
    }
    const proxy = new Proxy({}, {
    	get: function (obj, property) {
        if (property === '$super') {
          return $super
        }
        return instance[property]
      },
      set: function (obj, property, value) {
        instance[property] = value
      }
    })
    constructorOfC.apply(proxy, arguments)
    return instance
  }
  C.prototype = Object.create(B.prototype)
  return C
}())

var c = new C("test2");

alert([
  "OK",
  "_a: " + c._a,
  "is A: " + (c instanceof A),
  "_b: " + c._b,
  "is B: " + (c instanceof B),
  "_c: " + c._c,
  "is C: " + (c instanceof C),
  "_param: " + c._param,
  "_param2: " + c._param2
].join("\n\t"))

</code>
</div>
</div>
