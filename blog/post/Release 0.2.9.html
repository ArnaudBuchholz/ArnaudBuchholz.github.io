<script language="javascript" src="../include.js"></script>
<script language="javascript" src="../export.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    Release 0.2.9: ES6 Support
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<a href="#todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a><br />
<div class="summary">
    <img src="https://ArnaudBuchholz.github.io/blog/release.png" align="left">
    This release mainly introduces ES6 support as well as improvements to the serialization helpers.
    A new flavor is created for Node.js users.
</div>
<code class="markdown">
## Release 0.2.9: ES6 Support

* [Stories and bugs](https://github.com/ArnaudBuchholz/gpf-js/milestone/17?closed=1) implemented
* [Sources](https://github.com/ArnaudBuchholz/gpf-js/tree/v0.2.9)
* [Documentation](https://arnaudbuchholz.github.io/gpf/doc/index.html)
* [NPM package](https://www.npmjs.com/package/gpf-js)

## Release content

### ES6 support

While working on a side project which is based on Node.js, I realized that **the library did not support ES6 classes**.
Not only the gpf.define API was not able to extend any of them (even if it does not really make sense) but
it was also **impossible to add attributes** to a class that was not previously created with gpf.define (which is more
problematic).

After doing a quick test, a solution was drafted to detect and handle these classes the right way.
It is all explained in the article
[How I learned from a crazy idea](http://gpf-js.blogspot.com/2019/01/how-i-learned-from-crazy-idea.html).

The [$singleton and $abstract](https://arnaudbuchholz.github.io/gpf/doc/tutorial-DEFINE.html) syntaxes were adapted
accordingly.

(...) It is clearly **not recommended** to extend ES6 class using
[gpf.define](https://arnaudbuchholz.github.io/gpf/doc/gpf.html#.define__anchor).

In order to integrate attributes properly, a quick look in the **coming ES6 features** pointed out the fact that
**[decorators](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841)** are used to qualify class
members. Hence, an
[attribute decorator](https://arnaudbuchholz.github.io/gpf/doc/gpf.attributes.html#.decorator__anchor) was created.

Last but not least, since decorators are not yet supported without
[transpiling](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them),
the library allows **[preprocessing](https://arnaudbuchholz.github.io/gpf/doc/gpf.typedef.html#.requireOptions) of
resources** so that decorators can be subsituted with
[manual call of the decorator](https://github.com/ArnaudBuchholz/gpf-js/blob/bb6936760963f7dc4fc942da1eadeead5976b3b1/
test/require/es6/class_with_attributes.js#L45).

This was also the opportunity to **refactor** in depth the validation of the require configuration options.

### Improved serialization

The side project is **extensively using
[serialization attributes](https://arnaudbuchholz.github.io/gpf/doc/gpf.attributes.Serializable.html)**.
Quickly, the need for **code simplification** became obvious.

First, it does not make sense to repeat the
[property name](https://arnaudbuchholz.github.io/gpf/doc/gpf.typedef.html#.serializableProperty)
when it can be easily **deduced** from the member the attribute is assigned to.

(...) When set on a 'private' member, the result property name won't include the underscore.

Then, these attributes are used in a context where serialization is used to implement an
**[ODATA](https://www.odata.org/) service**.
Consequently, they are used to **describe** how the data should be sent back the client but also how it is
received.

For instance, an entity unique identifier must be transmitted to the client but it will never be modified by the client.

With the introduction of the
[readOnly property](https://arnaudbuchholz.github.io/gpf/doc/gpf.typedef.html#.serializableProperty), it is possible
to make this distinction and have **asymetric serialization**.

But, as for names, it does not make sense to repeat something that is **already built in the class**.
Indeed, with the use [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/
Global_Objects/Object/defineProperty) - or using ES6 class getter / setter - it is possible to define the (get, set)
couple and, when not setter exists, configure read-only members.

That's why, **when the hosts supports it**, the serialization code will leverage
[Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/
Object/getOwnPropertyDescriptor) recursively on
the class hierarchy to **determine if the member is read-only**.

### Improved compatibility

Browser's **base64 helpers** ([atob](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/
atob) and [btoa](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa)) were added to
the [compatibility](https://arnaudbuchholz.github.io/gpf/doc/tutorial-COMPATIBILITY.html) layer.

The Function.prototype.compatibleName method has been **removed** since it induced an **extension of the Function
prototype**. Usually, libraries should avoid doing that because it is **against best practices**.

Because of the [mocking](https://arnaudbuchholz.github.io/gpf/doc/gpf.http.html#.mock__anchor) implementation, the
[gpf.http.request](https://arnaudbuchholz.github.io/gpf/doc/gpf.http.html#.request__anchor) was **limited** in terms
of which [http methods](https://www.restapitutorial.com/lessons/httpmethods.html) could be used.
Some hosts do not support
custom verbs (and this is **documented** in the
[compatibility page](https://arnaudbuchholz.github.io/gpf/doc/tutorial-COMPATIBILITY.html)) but browsers & node supports
almost any verb. The code was modified to allow the use of **custom verbs**.

Surprisingly, the
[String method .substr](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr)
is documented as *"to be avoided when possible"*.
Since it was massively used in the sources, an ESLint
[custom rule](https://github.com/ArnaudBuchholz/gpf-js/blob/master/.eslintrules/no-substr.js) was developped and the
code reworked.

### New flavor node

A **Node.js flavor** was created and is used as the **default library** being loaded when using `require("gpf-js")`

It implements **all features** including the compatibility's atob and btoa.

<a name="todo">&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;&#128317;&#128315;</a>

## Lessons learned

### Asymetric Serialization

The user story [Asymetric serialization](https://github.com/ArnaudBuchholz/gpf-js/issues/299) required several updates
since it was pretty difficult to find the right balance between simplicity of use and flexibility. In the end,
this feature is really usefull when going through a converter function since this is the place where one can control
if the value will be serialized or not.

### Refactoring of classes

Integrating ES6 class was only a small part of the challenge. Actually, the library was suffering from inner defect
regarding how class inheritance was handled. Actually, when looking for a class definition, you could get a base class
provided the class was an instance of this one.

To solve this issue, a mechanism was put in place to import classes and import all the class hierarchy up to root classes (i.e. Object).
It also means that base classes are now associated with a class definition right upon the startup of the library.

This also imply that the library may have to deal with anonymous functions when importing a class.
It is still not possible to use gpf.define with a class name but, internally, the library can import *any* function.

### Putting the effort at the right place

When looking to import decorators, the initial idea was to have the library replace them when an ES6 class definition
is [required](https://arnaudbuchholz.github.io/gpf/doc/gpf.require.html#.define__anchor).

However, this would need the library to parse the javascript in order to detect the decorator uses.

Since this should be let out of the library scope, it was instead decided to open resource preprocessing so that
any user of the library could implement its own decorator substitution (or any other usefull feature).

### Refactoring of tests

Introduction of ES6 to the library had a significant impact on how the tests are made.
Indeed, it is mandatory to check if the host is actually supporting the ES6 class syntax.
Node.js is an obvious candidate but the library does not distinguish browsers.

So a new mechansim was built to detect features and add some flags to a global object available during the tests.

The same way, the same algorithm was used multiple times to adapt reading / require pathRegarding include path

### Improved flavor mechanism

Build the Node.js flavor was harder than expected. Since the compatibility layer was not included, the internal use
of .compatibleName didn't work anymore. That's the reason why it was decided to remove it. Instad an internal function
was created to extract a function name (that points to the name property by default).

Furthermore, a flavor debugging page was created to ensure that any update on the flavor algorithm would fit the
expectations.

### New eslint rules

As mentionned before, a new eslint rule was created to forbid the use of .substr:
[no-substr](https://github.com/ArnaudBuchholz/gpf-js/blob/master/.eslintrules/no-substr.js).

The same way, another rule was create to ensures that if a module has no function, a default one is being created:
[no-empty-modules](https://github.com/ArnaudBuchholz/gpf-js/blob/master/.eslintrules/no-empty-module.js).

This the linters are applied every time a module is modified, more custom rules might be created to solve common
problems (such as dependencies update).

### Release notes

Now that more than 14 releases exist for the library, it takes some time to access the release notes since one had to
go to the release tab of GitHub in order to find them.

It was decided to change the readme to include a link to the release notes.

Regarding the last version, since the notes are usually written once the release is out, a mechanism was built to
make any reader wait until the notes are out.

## Next release

The [next release content](https://github.com/ArnaudBuchholz/gpf-js/milestone/18) is about performances.
It's been a while I wanted to manipulate the release code to inline functions as much as possible and substitute loops
for performances.

Still, I need to work on the side project beacuse it **really** requires all my attention.

</code>
</div>
</div>
