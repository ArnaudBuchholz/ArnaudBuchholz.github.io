<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own jsdoc plugin
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    Jsdoc provides a convenient way to document APIs by adding comments directly in the code.
    However, the task can be tedious when it comes to documenting every details of each symbol.
    Luckily, the tool provides ways to interact with the parsing process through the creation of plugins.
</div>
<code class="markdown">
## Introduction

Just before the release of [version 0.1.5](http://gpf-js.blogspot.ca/2016/12/release-015.html), I focused on
[documenting the API](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/index.html).
I knew I had to use [jsdoc](http://usejsdoc.org/) so I started adding comments early in the
development process.

### Documentation

Before going any further with jsdoc, I would like to quickly present my point of view on documentation.

I tend to agree with [Uncle Bob's view on documentation](http://softwareengineering.stackexchange.com/questions/285787/
clean-code-comments-vs-class-documentation) meaning that I first focus on making the code clean and, on rare occasions,
I put some comments to clarify some non-obvious facts.

[Code never lies, comments sometimes do.](http://thequotes.in/code-never-lies-comments-sometimes-do-ron-jeffries/)

This being said, you don't expect developers to read the code to understand which methods they have access to and how
to use them. That's why, you need to document the API.

### Automation and validation

To make it a part of the build process, I installed [grunt-jsdoc](https://github.com/krampstudio/grunt-jsdoc) and
configured [two tasks](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/jsdoc.js):
* One 'private' to see all symbols (including the private and the internal ones)
* One 'public' for the official documentation (only the public symbols)

(...) The default rendering of jsdoc is quite boring, I decided to go with
[ink-docstrap](https://www.npmjs.com/package/ink-docstrap) for the public documentation.

To make sure my jsdoc comments were consistent and correctly used, I also
[configured eslint](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/.eslintrc#L29-L44) to validate them.

(...) jsdoc offers many aliases (for instance @return and @returns).
That's why eslint allows you to decide which tokens should be preferred.

Finally, I decided to control which files would be used to generate documentation through the
[sources.json](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/src/sources.json) doc properties.

### The reality

After fixing all the linter errors, I quickly realized that I had to do lot of copy & paste to generate the proper
documentation.

For example: when an internal method is exposed as a public API, the comment must be copied.
* On one hand, the internal method must be flagged with
[@private](http://usejsdoc.org/tags-private.html)
* On the other hand, the public method has the same comment but flagged with
[@public](http://usejsdoc.org/tags-public.html)

`/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @private
 */
function _gpfExtend (destination, source) {
    _gpfIgnore(source);
    [].slice.call(arguments, 1).forEach(function (nthSource) {
        _gpfObjectForEach(nthSource, _gpfAssign, destination);
    });
    return destination;
}

/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @public
 */
gpf.extend = _gpfExtend;`

This implies double maintenance with the risk of forgetting to replace @private with @public.

The lazy developer in me started to get annoyed and I started to look at ways I could do things more efficiently.

In that case, we could instruct jsdoc to copy the comment from the internal method and use the name to detect if
the API is public or private (depending if it starts with '_').

## jsdoc plugins

That's quite paradoxical for a documentation tool to have such a short explanation on
[plugins](http://usejsdoc.org/about-plugins.html).

### Comments and doclets

So let's start with the [basis](http://usejsdoc.org/about-getting-started.html):
jsdoc relies on specific comment blocks (starting with exactly two stars) to detect documentation placeholders.
It is not required for these blocks to be closed to a symbol but, when they do, the symbol context is used to determine
what is documented.

`/** this is a valid jsdoc description for variable a */
var a;

/**
    @file This is also a valid jsdoc description for the whole file
*/

/*** this comment is not a valid jsdoc one */

/*
 * This is not a valid jsdoc comment, even if it contains jsdoc tags
 * @return {Object} Empty object
 * @public
 */
function () {
    return {}
}`

Each valid jsdoc comment block is converted into a JavaScript object, named doclet, containing extracted information.

For instance, the following comment and function:
`/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @private
 */
function _gpfExtend (destination, source) {
    _gpfIgnore(source);
    [].slice.call(arguments, 1).forEach(function (nthSource) {
        _gpfObjectForEach(nthSource, _gpfAssign, destination);
    });
    return destination;
}`

generates the following doclet:
`{ comment: '/**\n * Extends the destination object by copying own enumerable properties from the source object.\n * If the member already exists, it is overwritten.\n *\n * @param {Object} destination Destination object\n * @param {...Object} source Source objects\n * @return {Object} Destination object\n * @since 0.1.5\n */',
  meta:
   { range: [ 834, 1061 ],
     filename: 'extend.js',
     lineno: 34,
     path: 'J:\\Nano et Nono\\Arnaud\\dev\\GitHub\\gpf-js\\src',
     code:
      { id: 'astnode100000433',
        name: '_gpfExtend',
        type: 'FunctionDeclaration',
        paramnames: [Object] },
     vars: { '': null } },
  description: 'Extends the destination object by copying own enumerable properties from the source object.\nIf the member already exists, it is overwritten.',
  params:
   [ { type: [Object],
       description: 'Destination object',
       name: 'destination' },
     { type: [Object],
       variable: true,
       description: 'Source objects',
       name: 'source' } ],
  returns: [ { type: [Object], description: 'Destination object' } ],
  name: '_gpfExtend',
  longname: '_gpfExtend',
  kind: 'function',
  scope: 'global',
  access: 'private' }`

The structure itself is not fully documented as it depends on the tags used and the symbol context.
However, some properties are most likely to be found, see the [newDoclet event](http://usejsdoc.org/about-plugins.html)
documentation.

I strongly recommend running jsdoc using the command line and output
[some traces](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/doc/gpf.js#L15-L23) to have a better understanding
on how doclets are generated.

(...) In the GPF-JS welcome page, I created a link named "JSDoc plugin test" for that purpose. It uses an
[exec:jsdoc task](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/exec.js#L49-L56).

### Plugins interaction

The plugins can be used to interact with jsdoc at three different levels:
* Interact with the parsing process through event handlers (beforeParse, jsdocCommentFound, newDoclet,
processingComplete...)
* Define tags and be notified when they are encountered inside a jsdoc comment: it gives you the chance to alter the
doclet that is generated
* Interact with the parsing process through an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) node visitor

The most important thing to remember is that you can interfere with doclet generation by altering them or even
preventing them. But, I struggled to find ways to generate them on the fly (i.e. with no jsdoc block comment).

(...) It looks like there is a way to generate new doclets with a node visitor. However, the documentation is not very
clear on that part. See [this example](http://www.zuojj.com/tdocs/jsdoc3/about-plugins.html).

## gpf.js plugin

### Member types

When creating a class, I usually declare members and initialize them with a default value that is representative
of the expected member type.
This works well with primitive types or arrays but it gets more complicated when dealing with object references (which
are most of the time initialized with null).

For instance, in [error.js](https://github.com/ArnaudBuchholz/gpf-js/blob/master/src/error.js#L25-L35):

`_gpfExtend(_GpfError.prototype, /** @lends gpf.Error.prototype */ {

    constructor: _GpfError,

    /**
     * Error code
     *
     * @readonly
     * @since 0.1.5
     */
    code: 0,`

In that case, the member type can easily be deduced from the AST node:

`{ comment: '/**\n     * Error code\n     *\n     * @readonly\n     * @since 0.1.5\n     */',
  meta:
   { range: [ 801, 808 ],
     filename: 'error.js',
     lineno: 35,
     path: 'J:\\Nano et Nono\\Arnaud\\dev\\GitHub\\gpf-js\\src',
     code:
      { id: 'astnode100000209',
        name: 'code',
        type: 'Literal',
        value: 0 } },
  description: 'Error code',
  readonly: true,
  since: '0.1.5',
  name: 'code',
  longname: 'gpf.Error#code',
  kind: 'member',
  memberof: 'gpf.Error',
  scope: 'instance' }`

Indeed the AST structure gives me the literal value the member is initialized with (see meta.code.value).

This is done in the [_addMemberType](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/doc/gpf.js#L115-L134)
function.

### Access type based on naming convention

There are no real private members in JavaScript. There are
[ways](https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Contributor_s_Guide/Private_Properties) to achieve similar
behavior (such as function scoped variables used in closure methods) but this is not the discussion here.

The main idea is to detail, through the documentation, which members the developer can rely on (public or protected when
inherited) and which ones should not be used directly (because they are private).

Because of the way JavaScript is designed, everything is public by default.
But I follow the naming convention where the underscore at the beginning of the member name means that the member is
private.

This means that the symbol name gives information about the access type.

This is leveraged in the [_checkAccess](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/doc/gpf.js#L136-L144)
function.

### Access type based on class definitions

In the next version, I will implement a class definition method and the structure will provide information about
members visibility. This will include a way to define static members.

The idea will be to leverage the node visitor to keep track of which visibility is defined on top of members.

### Custom tags

Through custom tags, I am able to instruct the plugin to modify the doclet in a specific way.

#### gpf:chainable

    Same return type
    Simple description

#### gpf:read / gpf:write

    Associated with a member name, it provides pre-defined signatures for getters and setters

#### sameas

    DRY principle applied to jsdoc comments

### The enumeration case

    What's the point of showing the value of an enum?
    I removed it.


### Error generation in GPF-JS

    That one is the most interesting example I had to go through

    Explain that everything starts from _gpfErrorDeclare
Example:

    One method is created
    One class is created

### Documentation generation

    Two steps process

    1. Creating new documentation blocks during the beforeParse

    2. Blocking the default handling through the node visitor


## ESLint customization

valid-jsdoc.js
    return handling (
    parameter handling (signature defined)

## @since

## Markdown?

## Conclusion

The lazy developper in me is statisfied :-)



</code>
<!-- Drop those two lines -->
</div>
</div>
