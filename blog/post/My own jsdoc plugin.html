<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own jsdoc plugin
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    Jsdoc provides a convenient way to document APIs by adding comments directly in the code.
    However, the task can be tedious when it comes to documenting every details of each symbol.
    Luckily, the tool provides ways to interact with the parsing process through the creation of plugins.
</div>
<code class="markdown">
## Introduction

Just before the release of [version 0.1.5](http://gpf-js.blogspot.ca/2016/12/release-015.html), I focused on
[documenting the API](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/index.html).
I knew I had to use [jsdoc](http://usejsdoc.org/) so I started adding comments early in the
development process.

### Documentation

Before going any further with jsdoc, I would like to quickly present my point of view on documentation.

I tend to agree with [Uncle Bob's view on documentation](http://softwareengineering.stackexchange.com/questions/285787/
clean-code-comments-vs-class-documentation) meaning that I first focus on making the code clean and, on rare occasions,
I put some comments to clarify some non-obvious facts.

[Code never lies, comments sometimes do.](http://thequotes.in/code-never-lies-comments-sometimes-do-ron-jeffries/)

This being said, you don't expect developers to read the code to understand which methods they have access to and how
to use them. That's why, you need to document the API.

### Automation and validation

To make it a part of the build process, I installed [grunt-jsdoc](https://github.com/krampstudio/grunt-jsdoc) and
configured [two tasks](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/jsdoc.js):
* One 'private' to see all symbols (including the private and the internal ones)
* One 'public' for the official documentation (only the public symbols)

(...) The default rendering of jsdoc is quite boring, I decided to go with
[ink-docstrap](https://www.npmjs.com/package/ink-docstrap) for the public documentation.

To make sure my jsdoc comments were consistent and correctly used, I also
[configured eslint](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/.eslintrc#L29-L44) to validate them.

(...) jsdoc offers many aliases (for instance @return and @returns).
That's why eslint allows you to decide which tokens should be preferred.

Finally, I decided to control which files would be used to generate documentation (using the source tile).

### The reality

After fixing all the linter errors, I quickly realized that I had to do lot of copy & paste to generate the proper
documentation.

For example: when an internal method is exposed as a public API, the comment must be copied.
* On one hand, the internal method must be flagged with
[@private](http://usejsdoc.org/tags-private.html)
* On the other hand, the public method has the same comment but flagged with
[@public](http://usejsdoc.org/tags-public.html)

`/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @private
 */
function _gpfExtend (destination, source) {
    _gpfIgnore(source);
    [].slice.call(arguments, 1).forEach(function (nthSource) {
        _gpfObjectForEach(nthSource, _gpfAssign, destination);
    });
    return destination;
}

/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @public
 */
gpf.extend = _gpfExtend;`

This implies double maintenance with the risk of forgetting to replace @private with @public.

The lazy developer in me started to get annoyed and I started to look at ways I could do things more efficiently.

In that case, we could instruct jsdoc to copy the comment from the internal method and use the name to detect if
the API is public or private (depending if it starts with '_').

## jsdoc plugins

That's quite paradoxical for a documentation tool to have such a short explanation on
[plugins](http://usejsdoc.org/about-plugins.html).

### Comments and doclets

So let's start with the [basis](http://usejsdoc.org/about-getting-started.html):
jsdoc relies on specific comment blocks (starting with exactly two stars) to detect documentation placeholders.
It is not required for these blocks to be closed to a symbol but, when they do, the symbol context is used to determine
what is documented.

`/** this is a valid jsdoc comment documenting variable a */
var a;

/**
    @file This is also a valid jsdoc comment, documenting the whole file
*/

/*** this comment is not a valid jsdoc one */

/*
 * This is not a valid jsdoc comment, even if it contains jsdoc tags
 * @return {Object} Empty object
 * @public
 */
function () {
    return {}
}`

Each valid jsdoc comment block is converted into a JavaScript object, named doclet, containing extracted information.

For instance, the following comment and function:
`/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @private
 */
function _gpfExtend (destination, source) {
    _gpfIgnore(source);
    [].slice.call(arguments, 1).forEach(function (nthSource) {
        _gpfObjectForEach(nthSource, _gpfAssign, destination);
    });
    return destination;
}`

generates the following doclet:
`{ comment: '/**\n * Extends the destination object by copying own enumerable properties from the source object.\n * If the member already exists, it is overwritten.\n *\n * @param {Object} destination Destination object\n * @param {...Object} source Source objects\n * @return {Object} Destination object\n * @since 0.1.5\n */',
  meta:
   { range: [ 834, 1061 ],
     filename: 'extend.js',
     lineno: 34,
     path: 'J:\\Nano et Nono\\Arnaud\\dev\\GitHub\\gpf-js\\src',
     code:
      { id: 'astnode100000433',
        name: '_gpfExtend',
        type: 'FunctionDeclaration',
        paramnames: [Object] },
     vars: { '': null } },
  description: 'Extends the destination object by copying own enumerable properties from the source object.\nIf the member already exists, it is overwritten.',
  params:
   [ { type: [Object],
       description: 'Destination object',
       name: 'destination' },
     { type: [Object],
       variable: true,
       description: 'Source objects',
       name: 'source' } ],
  returns: [ { type: [Object], description: 'Destination object' } ],
  name: '_gpfExtend',
  longname: '_gpfExtend',
  kind: 'function',
  scope: 'global',
  access: 'private' }`

The structure itself is not fully documented as it depends on the tags used and the symbol context.
However, some properties are most likely to be found, see the [newDoclet event](http://usejsdoc.org/about-plugins.html)
documentation.

### Plugins interaction

The plugins can be used to interact with jsdoc at three different levels:
* Interact with the parsing process through event handlers (beforeParse, jsdocCommentFound, newDoclet,
processingComplete...)
* Define tags and be notified when they are encountered inside a jsdoc comment: it gives you the chance to alter the
doclet that is generated
* Interact with the parsing process through an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) node visitor

The most important thing to understand is that you can interfere with doclet generation by altering them or even
preventing them. But, I struggled to find ways to generate them on the fly.

(...) It looks like there is a way to generate new doclets with a node visitor. However, the documentation is very
not clear on that part.

As of today, the only wai
Members are poorly documented (for instance type...)
doclets can't easily be created ==> go with beforeParse to add new comments
    with the drawback of pointing to unknown lines

The best way to know how to generate or alter a doclet is to create one using the proper jsdoc comments and then dump
the structure to see how jsdoc generated the doclet.

## gpf.js plugin

### Member types

    When creating a class, I use to declare members and initialize them with a default value
    Most of the time the value type can be deduced from this default value

    error sample

_gpfExtend(_GpfError.prototype, /** @lends gpf.Error.prototype */ {

    constructor: _GpfError,

    /**
     * Error code
     *
     * @readonly
     * @since 0.1.5
     */
    code: 0,

    /**
     * Error name
     *
     * @readonly
     * @since 0.1.5
     */
    name: "Error",

    /**
     * Error message
     *
     * @readonly
     * @since 0.1.5
     */
    message: "",

### Access type based on naming convention

    By default, all symbols are public.
    I follow the naming convention where the underscore at the beginning of the member names means that the member
    is private.

### Access type based on class definitions

    In the next versions, I will implement a class definition method and the structure will provide information about
    member visibility. The idea would be to avoid writing @private / @protected
    Will also handle @static

### Custom tags

chainable
    Same return type
    Simple description

read / write
    Defining property getters and setters

sameas
    DRY principle applied to comments

### The enumeration case

    What's the point of showing the value of an enum?
    I removed it.


### Error generation in GPF-JS

    That one is the most interesting example I had to go through

    Explain that everything starts from _gpfErrorDeclare
Example:

    One method is created
    One class is created

### Documentation generation

    Two steps process

    1. Creating new documentation blocks during the beforeParse

    2. Blocking the default handling through the node visitor


## ESLint customization

valid-jsdoc.js
    return handling (
    parameter handling (signature defined)

## @since

## Markdown?

## Conclusion

The lazy developper in me is statisfied :-)



</code>
<!-- Drop those two lines -->
</div>
</div>
