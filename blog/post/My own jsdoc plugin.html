<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own jsdoc plugin
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    Jsdoc provides a convenient way to document APIs by adding comments directly in the code.
    However, the task can be tedious when it comes to documenting every details of each symbol.
    Luckily, the tool provides ways to interact with the parsing process through the creation of plugins.
</div>
<code class="markdown">
## Introduction

Just before the release of [version 0.1.5](http://gpf-js.blogspot.ca/2016/12/release-015.html), I focused on
[documenting the API](https://arnaudbuchholz.github.io/gpf/0.1.5/doc/index.html).
I knew I had to use [jsdoc](http://usejsdoc.org/) so I started adding comments early in the
development process.

### Automation and validation

To make it a part of the build process, I installed [grunt-jsdoc](https://github.com/krampstudio/grunt-jsdoc) and
configured [two tasks](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/grunt/jsdoc.js):
* One 'private' to see all symbols (including the private and the internal ones)
* One 'public' for the official documentation (only the public symbols)

(...) The default rendering of jsdoc is quite boring, I decided to go with
[ink-docstrap](https://www.npmjs.com/package/ink-docstrap) for the public documentation.

To make sure my jsdoc comments were consistent and correctly used, I also
[configured eslint](https://github.com/ArnaudBuchholz/gpf-js/blob/v0.1.5/.eslintrc#L29-L44) to validate them.

(...) jsdoc offers many aliases (for instance @return and @returns).
That's why eslint allows you to decide which tokens you prefer.


Finally, I decided to control which files would be used to generate documentation (using the source tile).

### The reality

After fixing all the linter errors, I quickly realized that I had to do lot of copy & paste to generate the proper
documentation.

For example: when an internal method is exposed as a public API, the comment must be copied.
* On one hand, the internal method must be flagged with
[@private](http://usejsdoc.org/tags-private.html)
* On the other hand, the public method has the same comment but flagged with
[@public](http://usejsdoc.org/tags-public.html)

`/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @private
 */
function _gpfExtend (destination, source) {
    _gpfIgnore(source);
    [].slice.call(arguments, 1).forEach(function (nthSource) {
        _gpfObjectForEach(nthSource, _gpfAssign, destination);
    });
    return destination;
}

/**
 * Extends the destination object by copying own enumerable properties from the source object.
 * If the member already exists, it is overwritten.
 *
 * @param {Object} destination Destination object
 * @param {...Object} source Source objects
 * @return {Object} Destination object
 * @public
 */
gpf.extend = _gpfExtend;`

This implies double maintenance with the risk of forgetting to replace @private with @public.

The lazy developer in me started to get annoyed and I started to look at ways I could do things more efficiently.

In that case, we could instruct jsdoc to copy the comment from the internal method and use the name to detect if
the API is public or private (depending if it starts with '_').

### jsdoc plugins

That's quite paradoxical for a documentation tool to have such limited explanations on
[plugins](http://usejsdoc.org/about-plugins.html).

I guess the most important sentence that I should have read several times is the following:

A plugin can affect the parse results by doing any of the following:

    Defining event handlers
    Defining tags
    Defining a visitor for abstract syntax tree nodes
jsdoc offers

Members are poorly documented (for instance type...)
doclets can't easily be created ==> go with beforeParse to add new comments
    with the drawback of pointing to unknown lines

The best way to know how to generate or alter a doclet is to create one using the proper jsdoc comments and then dump
the structure to see how jsdoc generated the doclet.

## gpf.js plugin

### Member types

    When creating a class, I use to declare members and initialize them with a default value
    Most of the time the value type can be deduced from this default value

    error sample

_gpfExtend(_GpfError.prototype, /** @lends gpf.Error.prototype */ {

    constructor: _GpfError,

    /**
     * Error code
     *
     * @readonly
     * @since 0.1.5
     */
    code: 0,

    /**
     * Error name
     *
     * @readonly
     * @since 0.1.5
     */
    name: "Error",

    /**
     * Error message
     *
     * @readonly
     * @since 0.1.5
     */
    message: "",

### Access type based on naming convention

    By default, all symbols are public.
    I follow the naming convention where the underscore at the beginning of the member names means that the member
    is private.

### Access type based on class definitions

    In the next versions, I will implement a class definition method and the structure will provide information about
    member visibility. The idea would be to avoid writing @private / @protected
    Will also handle @static

### Custom tags

chainable
    Same return type
    Simple description

read / write
    Defining property getters and setters

sameas
    DRY principle applied to comments

### The enumeration case

    What's the point of showing the value of an enum?
    I removed it.


### Error generation in GPF-JS

    That one is the most interesting example I had to go through

    Explain that everything starts from _gpfErrorDeclare
Example:

    One method is created
    One class is created

### Documentation generation

    Two steps process

    1. Creating new documentation blocks during the beforeParse

    2. Blocking the default handling through the node visitor


## ESLint customization

valid-jsdoc.js
    return handling (
    parameter handling (signature defined)

## @since

## Markdown?

## Conclusion

The lazy developper in me is statisfied :-)



</code>
<!-- Drop those two lines -->
</div>
</div>
