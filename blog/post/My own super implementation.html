<script language="javascript" src="../include.js"></script>
<link rel="stylesheet" type="text/css" href="../file.css" />
<div class="post">
<h3 class="post-title entry-title">
    My own super implementation
</h3>
<div class="post-header">
    <div class="post-header-line-1"></div>
</div>
<div class="post-body">
<!-- Copy from the next line -->
<div class="summary">
    <img src="http://ArnaudBuchholz.github.io/blog/student.png" align="left">
    Release 0.1.6 of GPF-JS delivers a basic class definition mechanism.
    Working on the release 0.1.7, I am securing this implementation by providing mechanism that mimic
    the ES6 class definition. In particular, the super keyword is replaced with a $super member that provides
    the same level of functionalities. Here is how.
</div>
<code class="markdown">
## Introduction

The [super](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) keyword was introduced
with ECMAScript 2015. Its goal is to simplify the access to parent methods of an object.
It can be used within a class definition or directly in object literals.

### Class examples

To demonstrate the usage, let define a class A.
`class A {

    constructor (value) {
        this._a = true;
        if (undefined !== value) {
            this._value = value;
        }
    }

    getValue () {
        return this._value;
    }

}`

Then, let subclass it to a class B.
`class B extends A {

    constructor () {
        super("b");
        this._b = true;
    }

    getValue () {
        return super.getValue().toUpperCase();
    }
}`

The way B is defined changes the behavior of the method getValue so that the result of A implementation is uppercased.
Also, when instance of B are built, the constructor of A is explicitly called with a parameter.

Without the ES6 syntax, you could do it this way:
`function A (value) {
    this._a = true;
    if (undefined !== value) {
        this._value = value;
    }
}

Object.assign(A.prototype, {
    getValue: function () {
        return this._value;
    }
});

function B () {
    A.call(this, "b");
    this._b = true;
}

B.prototype = Object.create(A.prototype);
Object.assign(B.prototype, {
    getValue: function () {
        return A.prototype.getValue.call(this).toUpperCase();
    }
});`

(...) There are several ways to implement inheritance in JavaScript.
In this example, I applied the pattern used in GPF-JS.

### Syntax differences

Whether you use one syntax or the other, both versions of A and B will look almost the same:
* A and B are functions
* A.prototype has a method named getValue
* b instances only have own properties _a, _b and _value
* b instanceof A works

[Class version (Chrome & Firefox only)](https://jsfiddle.net/ArnaudBuchholz/um9511we/)

[Function version](https://jsfiddle.net/ArnaudBuchholz/kj457uvu/1/)

### So, why would you use the super keyword?

As you may see in the examples, accessing the parent methods without ES6 is possible but requires the knowledge of the
parent class being extended:
* In the constructor, `super("b")` is replaced with `A.call(this, "b")`

* In a method, `super.getValue()` is replaced with `A.prototype.getValue.call(this)`

As a consequence, any update in the class hierarchy would lead to a mass search & replace in the code.

Beside this, one could say that this keyword is a typical example of
[syntaxic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar) as it does not bring new feature.

(...) if you forget about object literals...

### Exploring the feature

The very first time I was exposed to the super keyword, I had some questions about the way it react to
[edge cases](https://en.wikipedia.org/wiki/Edge_case).

#### Redefining parent method

What happens if the parent prototype is modified? Does it call the modified method or does it call the method that was
existing when the child method is defined.

It appears that the link is dynamic.

[Example (Chrome & Firefox only)](https://jsfiddle.net/ArnaudBuchholz/Layhbjye/)

(...) This is consistent with the function implementation: A.prototype.getValue re-evaluates the member every time it
is called.

#### Getting function object

Is it possible to access the parent method without invoking it? Does it return a function object?

Indeed, it returns the parent function object.

[Example (Chrome & Firefox only)](https://jsfiddle.net/ArnaudBuchholz/34n4ae99/4/)

(...) It is important to notice that when invoked outside of the method, it appears that the value of
[this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) is undefined.

#### Checking parent method existence

Finally, I was also wondering how the super keyword validates the method that is accessed: what happens if you try to
reference a non existing member: does it fail when generating the class or upon method execution?

Accessing a non existing member returns
[undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).

[Example (Chrome & Firefox only)](https://jsfiddle.net/54L2eovo/1/)

(...) Because it supports dynamism, I suspected that the error would be thrown at evaluation time.

## A super idea

One of the goal of [GPF-JS](https://github.com/ArnaudBuchholz/gpf-js) is to provide the same feature set whatever the
host running the script. Because some of them are old (Rhino and WScript), it is not only impossible to use ES6 features
but also it prevents the use of
[transpilers](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them).

[gpf.define](https://github.com/ArnaudBuchholz/gpf-js/blob/master/doc/tutorials/DEFINE.md#class) is a class definition
helper exposed by the library. I wanted it to offer a mechanism that would mimic the super keyword.

However, super being a reserved keyword, I could not use it.

As the library reserves $ properties for specific usage, I came with the idea of defining $super.

I initially tried to make the $super keyword a global one (like super) but the library had to tweak the global
context object which generated lots of issue. So I ended up defining this.$super inside class methods.

I wanted to support two different forms:

* Calling `this.$super` must be equivalent to `super`

* Calling `this.$super.methodName` must be equivalent to `super.methodName`

### Invoking a function

The very first problem that quickly became obvious is related to the second form.
How do you make sure that when calling `this.$super.methodName()`
the proper [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) is transmitted to
methodName?

If you understand how
[JavaScript function invocation](https://www.safaribooksonline.com/library/view/javascript-the-good/9780596517748/
ch04s03.html) works, you know that inside methodName, it would be equal to this.$super... which is a function.

I could use binding to force the value of this inside the function but then I would loose the possibility to invoke it
with any context.

### Binding

Before [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/
Function/bind) was introduced, people used to create a closure to force the value of this inside a function.

`Function.prototype.bind = function(oThis) {
    var fToBind = this;
    return function () {
        return fToBind.apply(oThis, arguments);
    }
};`

This concept was also made popular with [jQuery.proxy](https://api.jquery.com/jQuery.proxy/).

Once a function is bound, it is no more possible to change the context it is executed with.

[Demonstration](https://jsfiddle.net/ArnaudBuchholz/duxnd03m/)
`function getValue() {
  return this.value;
}

// Passing the context
log(getValue.call({
	value: "Hello World"
})); // output "Hello World"

// Binding
var boundGetValue = getValue.bind({
	value: "Bound"
});
log(boundGetValue());  // output "Bound"

// Trying to pass a different context
log(boundGetValue.call({
	value: "Hello World"
})); // output "Bound"

// Trying to bind again
var reboundGetValue = boundGetValue.bind({
	value: "Hello World"
});
log(reboundGetValue());  // output "Bound"`

Back to my $super.methodName example, I needed a way to bind the method so that it could be called with a different
context: a sort of weak bind.

### Wrapping a method

Explain the use of function builder to replicate method signature and inject symbols
I can also clean the this object once the method has been called in order to make sure it does not leak

### Static mapping of super method

It all started with static mapping because the wrapper is created while the class prototype is built

### Dynamic mapping of super method

Then the idea changed to be more dynamic and handle error cases where super does not make sense.

### Dynamic members of super

Beside the fact that the methodName should exist in the inherited prototype, we still need to overcome two problems:

1) if $super is equal to the inherited method, I am not allowed to modify it
2) if invoked with .call or .apply, I want the this to be modifiable
3) For performance reasons, I don't want to define *all* possible members of $super by copying the inherited methods

#### Building a new $super method object

A JavaScript function being an object, I am allowed to add methods onto it

#### Weak binding

$super being known when the methods are defined, I can check that this === $super and substitute when needed

#### Detecting $super members

Guess what, a regular expression is being used



</code>
<!-- Drop those two lines -->
</div>
</div>
