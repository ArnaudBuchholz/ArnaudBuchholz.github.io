<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - i_wrapper.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>i_wrapper.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">339</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">42.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.41</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*#ifndef(UMD)*/
(function () { /* Begin of privacy scope */
    &quot;use strict&quot;;
/*#endif*/

    var
        gpfI = gpf.interfaces,
        gpfFireEvent = gpf.events.fire,
        _wrappers = {},

        /**
         * Build the synchronous member (no event)
         *
         * @param {String} name
         * @return {Function}
         * @closure
         * @private
         */
        _sync = function (name) {
            return function () {
                this._calls.push(new MethodCall(true, name, arguments, 0));
                this._start();
                return this;
            };
        },

        /**
         * Build the asynchronous member (i.e. event related)
         *
         * @param {String} name
         * @param {Number} length argument count in the function (used to deduce
         * where the event handler is)
         * @return {Function}
         * @closure
         * @private
         */
        _async = function (name, length) {
            return function () {
                this._calls.push(new MethodCall(false, name, arguments,
                    length));
                this._start();
                return this;
            };
        },

        _buildMembers = function (interfaceDef) {
            var
                result = {
                    public: {},
                    static: {
                        interface: interfaceDef
                    }
                },
                publicMembers = result.public,
                attributes = new gpf.attributes.Map(),
                prototype = interfaceDef.prototype,
                member,
                method;
            attributes.fillFromClassDef(gpf.classDef(interfaceDef));
            for (member in prototype) {
                if (prototype.hasOwnProperty(member)) {
                    method = prototype[member];
                    if (&quot;constructor&quot; === member) {
                        continue; // ignore
                    }
                    gpf.ASSERT(&quot;function&quot; === typeof method, &quot;Only methods&quot;);
                    if (attributes.member(member)
                        .has(gpf.attributes.ClassEventHandlerAttribute)) {
                        publicMembers[member] = _async(member, method.length);
                    } else {
                        publicMembers[member] = _sync(member);
                    }
                }
            }
            return result;
        },

        MethodCall = gpf.define(&quot;MethodCall&quot;, {

            private: {

                /**
                 * Call is synchronous
                 *
                 * @type {Boolean}
                 * @private
                 */
                _synchronous: true,

                /**
                 * Method name
                 *
                 * @type {String}
                 * @private
                 */
                _name: &quot;&quot;,

                /**
                 * Method arguments
                 *
                 * @type {Array}
                 * @private
                 */
                _args: [],

                /**
                 * When asynchronous, length provides the position of the event
                 * handler
                 *
                 * @type {Number}
                 * @private
                 */
                _length: 0

            },

            public: {

                /**
                 *
                 * @param {Boolean} synchronous Call is synchronous
                 * @param {String} name Method name
                 * @param {Array} args Method arguments
                 * @param {Number} length When asynchronous, length provides the
                 * position of the event handler
                 */
                constructor: function (synchronous, name, args, length) {
                    this._synchronous = synchronous;
                    this._name = name;
                    this._args = args;
                    this._length = length;
                },

                /**
                 * Apply the call
                 *
                 * @param {Object} iHandler
                 * @param {gpf.Callback} callback
                 */
                apply: function (iHandler, callback) {
                    var
                        args = this._args,
                        method = iHandler[this._name],
                        finalArgs,
                        count,
                        idx;
                    if (this._synchronous) {
                        method.apply(iHandler, args);
                        callback.call();
                    } else {
                        count = this._length;
                        finalArgs = new Array(count);
                        finalArgs[--count] = callback;
                        if (count &gt; args.length) {
                            count = args.length;
                        }
                        for (idx = 0; idx &lt; count; ++idx) {
                            finalArgs[idx] = args[idx];
                        }
                        method.apply(iHandler, finalArgs);
                    }
                }

            }

        }),

        WrapInterface = gpf.define(&quot;WrapInterface&quot;, {

            private: {

                /**
                 * Interface handler
                 *
                 * @type {gpf.interfaces.Interface}
                 * @private
                 */
                _iHandler: null,

                /**
                 * List of method calls
                 *
                 * @type {MethodCall[]}
                 * @private
                 */
                _calls: [],

                /**
                 * Callback to be used as event handler
                 *
                 * @type {gpf.Callback}
                 * @private
                 */
                _callback: null,

                /**
                 * $catch callback
                 *
                 * @type {gpf.events.Handler}
                 * @private
                 */
                _catch: null,

                /**
                 * $finally callback
                 *
                 * @type {gpf.events.Handler}
                 * @private
                 */
                _finally: null,

                /**
                 * $finally event type
                 *
                 * @type {String}
                 * @private
                 */
                _finalEventType: &quot;done&quot;,

                /**
                 * Event handler
                 *
                 * @param {gpf.Event} event
                 * @private
                 */
                _asyncResult: function (event) {
                    var
                        iHandler = this._iHandler,
                        calls;
                    if (event &amp;&amp; event.type() === &quot;error&quot;) {
                        if (this._catch) {
                            gpfFireEvent.apply(iHandler, [
                                event, this._catch
                            ]);
                        }
                        return;
                    }
                    calls = this._calls;
                    if (calls.length) {
                        calls.shift().apply(iHandler, this._callback);
                    } else if (this._finally) {
                        gpfFireEvent.apply(iHandler, [
                            this._finalEventType, this._finally
                        ]);
                    }
                },

                /**
                 * @type {Boolean}
                 * @private
                 */
                _needStart: true,

                /**
                 * When at least one method is called, this one makes sure the
                 * execution starts
                 *
                 * @private
                 */
                _start: function () {
                    if (this._needStart) {
                        this._needStart = false;
                        gpf.defer(this._asyncResult, 0, this);
                    }
                }

            },

            public: {

                /**
                 * @param {Object} instance
                 * @constructor
                 */
                constructor: function (instance) {
                    this._iHandler = gpfI.query(instance,
                        this.constructor.interface);
                    this._calls = [];
                    this._callback = new gpf.Callback(this._asyncResult, this);
                },

                /**
                 * Configure the error handler
                 *
                 * @param {gpf.events.Handler} eventHandler
                 * @return {WrapInterface}
                 * @chainable
                 */
                $catch: function (eventHandler) {
                    this._catch = eventHandler;
                    this._start();
                    return this;
                },

                /**
                 * Configure the final handler
                 *
                 * @param {gpf.events.Handler} eventHandler
                 * @param {String}[eventType=done] eventType
                 * @return {WrapInterface}
                 * @chainable
                 */
                $finally: function (eventHandler, eventType) {
                    this._finally = eventHandler;
                    if (eventType) {
                        this._finalEventType = eventType;
                    }
                    this._start();
                    return this;
                }
            }

        });

    /**
     * Get or build the wrapper class for the given interface definition
     *
     * @param {Function} interfaceDef
     * @return {Function}
     */
    gpfI.wrap = function (interfaceDef) {
        var
            classDef = gpf.classDef(interfaceDef),
            result = _wrappers[classDef.uid()],
            base;
        if (undefined === result) {
            if (interfaceDef === gpfI.Interface) {
                result = WrapInterface;
            } else {
                base = gpfI.wrap(classDef.Base());
                result = gpf.define(&quot;Wrap&quot; + classDef.nameOnly(), base,
                    _buildMembers(interfaceDef));
            }
            _wrappers[classDef.uid()] = result;
        }
        return result;
    };

/*#ifndef(UMD)*/
}()); /* End of privacy scope */
/*#endif*/</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
