<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - xml.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>xml.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.46</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1345</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.33</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*#ifndef(UMD)*/
(function () { /* Begin of privacy scope */
    &quot;use strict&quot;;
/*#endif*/

    /*jshint forin:false*/ // Need to inspect all members of the prototype

    var
        // Namespaces shortcut
        gpfI = gpf.interfaces,
        gpfA = gpf.attributes,
        gpfFireEvent = gpf.events.fire

/*
        // XML Parser constants
        _XMLPARSER_STATE_NONE = 0
*/
        ;

    gpf.xml = {};

    /**
     * Defines the possibility for the object to be saved as XML
     *
     * @class gpf.interfaces.IXmlSerializable
     * @extends gpf.interfaces.Interface
     */
    gpf._defIntrf(&quot;IXmlSerializable&quot;, {

        /**
         * Translate obj into an gpf.interfaces.IXmlContentHandler and serialize
         * itself into XML
         *
         * @param {gpf.interfaces.IXmlContentHandler} out XML Content handler
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready
         */
        &quot;[toXml]&quot;: [gpf.$ClassEventHandler()],
        toXml: function (out, eventsHandler) {
            gpfI.ignoreParameter(out);
            gpfI.ignoreParameter(eventsHandler);
        }

    });

    /**
     * Defines the possibility for an object to receive XML serialization events
     *
     * @class gpf.interfaces.IXmlContentHandler
     * @extends gpf.interfaces.Interface
     *
     * Inspired from
     * http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
     */
    gpf._defIntrf(&quot;IXmlContentHandler&quot;, {

        /**
         * Receive notification of character data
         *
         * @param {String} buffer characters
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready
         */
        &quot;[characters]&quot;: [gpf.$ClassEventHandler()],
        characters: function (buffer, eventsHandler) {
            gpfI.ignoreParameter(buffer);
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         * Receive notification of the end of a document
         *
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready
         */
        &quot;[endDocument]&quot;: [gpf.$ClassEventHandler()],
        endDocument: function (eventsHandler) {
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         * Signal the end of an element
         *
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready
         */
        &quot;[endElement]&quot;: [gpf.$ClassEventHandler()],
        endElement: function (eventsHandler) {
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         *  End the scope of a prefix-URI mapping
         *
         * @param {String} prefix
         *
         * @event ready
         */
        endPrefixMapping: function (prefix) {
            gpfI.ignoreParameter(prefix);
        },

        /**
         * Receive notification of ignorable whitespace in element content
         *
         * @param {String} buffer characters
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready
         */
        &quot;[ignorableWhitespace]&quot;: [gpf.$ClassEventHandler()],
        ignorableWhitespace: function (buffer, eventsHandler) {
            gpfI.ignoreParameter(buffer);
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         * Receive notification of a processing instruction
         *
         * @param {String} target
         * @param {String} data
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready
         */
        &quot;[processingInstruction]&quot;: [gpf.$ClassEventHandler()],
        processingInstruction: function (target, data, eventsHandler) {
            gpfI.ignoreParameter(target);
            gpfI.ignoreParameter(data);
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         * Receive an object for locating the origin of SAX document events.
         *
         * @param {*} locator
         */
        setDocumentLocator: function (locator) {
            gpfI.ignoreParameter(locator);
        },

        /**
         * Receive notification of a skipped entity
         *
         * @param {String} name
         */
        skippedEntity: function (name) {
            gpfI.ignoreParameter(name);
        },

        /**
         * Receive notification of the beginning of a document
         *
         * @param {gpf.events.Handler} eventsHandler
         */
        &quot;[startDocument]&quot;: [gpf.$ClassEventHandler()],
        startDocument: function (eventsHandler) {
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         * Receive notification of the beginning of an element
         *
         * @param {String} uri [uri=&quot;&quot;] namespace uri (if any)
         * @param {String} localName
         * @param {String} [qName=localName] qName qualified name
         * @param {Object} attributes attribute dictionary (string/string)
         * @param {gpf.events.Handler} eventsHandler
         */
        &quot;[startElement]&quot;: [gpf.$ClassEventHandler()],
        startElement: function (uri, localName, qName, attributes,
            eventsHandler) {
            gpfI.ignoreParameter(uri);
            gpfI.ignoreParameter(localName);
            gpfI.ignoreParameter(qName);
            gpfI.ignoreParameter(attributes);
            gpfI.ignoreParameter(eventsHandler);
        },

        /**
         * Begin the scope of a prefix-URI Namespace mapping
         *
         * @param {String} prefix
         * @param {String} uri
         */
        startPrefixMapping: function (prefix, uri) {
            gpfI.ignoreParameter(prefix);
            gpfI.ignoreParameter(uri);
        }

    });

    var

        //region XML attributes

        /**
         * XML attribute (base class).
         * once the attribute is assigned to an object, it implements the
         * IXmlSerializable interface
         *
         * @class gpf.attributes.XmlAttribute
         * @extends gpf.attributes.Attribute
         * @private
         */
        _XmlBase = gpf._defAttr(&quot;XmlAttribute&quot;, {

            protected: {

                /**
                 * @inheritdoc gpf.attributes.Attribute:_alterPrototype
                 */
                _alterPrototype: function (objPrototype) {
                    /*
                     * If not yet defined creates new XML members
                     * - toXml()
                     * - IXmlContentHandler implementation
                     */
                    if (undefined === objPrototype.toXml) {
                        // Declare toXml
                        gpfA.add(objPrototype.constructor, &quot;Class&quot;,
                            [gpf.$InterfaceImplement(gpfI.IXmlSerializable)]);
                        objPrototype.toXml = _toXml;
                        // Declare IXmlContentHandler interface through IUnknown
                        gpfA.add(objPrototype.constructor, &quot;Class&quot;,
                            [gpf.$InterfaceImplement(gpfI.IXmlContentHandler,
                                _fromXml)]);
                    }
                }

            }

        }),

        /**
         * XML Ignore attribute
         * Indicates the member must not be serialized
         *
         * @class gpf.attributes.XmlIgnoreAttribute
         * @extends gpf.attributes.XmlAttribute
         * @alias gpf.$XmlIgnore
         */
        _XmlIgnore = gpf._defAttr(&quot;$XmlIgnore&quot;, _XmlBase, {}),

        /**
         * XML Attribute attribute
         * Indicates the member is serialized as an attribute
         *
         * @param {String} name The attribute name
         *
         * @class gpf.attributes.XmlAttributeAttribute
         * @extends gpf.attributes.XmlAttribute
         * @alias gpf.$XmlAttribute
         */
        _XmlAttribute = gpf._defAttr(&quot;$XmlAttribute&quot;, _XmlBase, {

            private: {

                /**
                 * Name of the attribute
                 *
                 * @type {String}
                 * @private
                 */
                &quot;[_name]&quot;: [gpf.$ClassProperty()],
                _name: &quot;&quot;

            },

            public: {

                /**
                 * @param {String} name Name of the attribute
                 * @constructor
                 */
                constructor: function (name) {
                    gpf.ASSERT(gpf.xml.isValidName(name),
                        &quot;Valid XML attribute name&quot;);
                    this._name = name;
                }

            }

        }),

        /**
         * XML RAW Element attribute
         *
         * @param {String} name The element name
         *
         * @class gpf.attributes.XmlRawElementAttribute
         * @extends gpf.attributes.XmlAttribute
         */
        _XmlRawElement = gpf._defAttr(&quot;XmlRawElementAttribute&quot;, _XmlBase, {

            private: {

                /**
                 * Name of the element
                 *
                 * @type {String}
                 * @private
                 */
                &quot;[_name]&quot;: [gpf.$ClassProperty()],
                _name: &quot;&quot;

            },

            public: {

                /**
                 * @param {String} name Name of the element
                 * @constructor
                 */
                constructor: function (name) {
                    gpf.ASSERT(gpf.xml.isValidName(name),
                        &quot;Valid XML element name&quot;);
                    this._name = name;
                }

            }

        }),

        /**
         * XML Element attribute
         * Indicates the member is serialized as an element
         *
         * @param {String} name The element name
         * @param {Function} objClass The class used for un-serializing it
         *
         * @class gpf.attributes.XmlElementAttribute
         * @extends gpf.attributes.XmlRawElementAttribute
         * @alias gpf.$XmlElement
         */
        _XmlElement = gpf._defAttr(&quot;$XmlElement&quot;, _XmlRawElement, {

            private: {

                /**
                 * Object constructor
                 *
                 * @type {Function}
                 * @private
                 */
                &quot;[_objClass]&quot;: [gpf.$ClassProperty()],
                _objClass: null

            },

            public: {

                /**
                 * @param {String} name Name of the element
                 * @param {Function} objClass Object constructor
                 * @constructor
                 */
                constructor: function (name, objClass) {
                    this._super(name);
                    if (objClass) {
                        this._objClass = objClass;
                    }
                }

            }

        }),

        /**
         * XML List attribute
         * Indicates the member is an array and is serialized inside an element
         *
         * @class gpf.attributes.XmlListAttribute
         * @extends gpf.attributes.XmlRawElementAttribute
         * @alias gpf.$XmlList
         */
        _XmlList = gpf._defAttr(&quot;$XmlList&quot;, _XmlRawElement, {}),

        //endregion

        //region TO XML

        /**
         * Select the attribute related to the value type
         *
         * @param {gpf.attributes.Array} array Attribute array
         * @param {Object} value
         * @return {null|gpf.attributes.Attribute}
         * @private
         */
        _selectByType = function (array, value) {
            var
                idx,
                attribute,
                defaultResult = null,
                result = null,
                attObjClass;
            for (idx = 0; idx &lt; array.length(); ++idx) {
                attribute = array.get(idx);
                if (!(attribute instanceof _XmlElement)) {
                    continue;
                }
                attObjClass = attribute.objClass();
                if (attObjClass) {
                    if (value instanceof attObjClass) {
                        /*
                         * If no result attribute has been set
                         * OR if the new attribute is a &#039;child&#039; class of the
                         * existing result (meaning the new attribute is &#039;more&#039;
                         * specific)
                         */
                        if (!result || attObjClass.prototype
                            instanceof result.objClass()) {
                            result = attribute;
                        }
                    }
                }
                else if (!defaultResult) {
                    defaultResult = attribute;
                }
            }
            if (null !== result) {
                return result;
            } else {
                return defaultResult;
            }
        },

        /**
         * Decide if the member value must be serialized as an attribute (and
         * return its name) or as a sub node (empty result)
         *
         * @param {String} member
         * @param {*} value
         * @param {String} type
         * @param {gpf.attributes.Array} attArray
         * @return {String} &quot;&quot; if the member should be serialized as a sub
         *          node, otherwise the name to apply
         * @private
         */
        _objMemberValueIsAttribute = function /*gpf:inline*/ (member, value,
            type, attArray) {
            var attribute;
            // Check if list or element
            if (value instanceof Array || attArray.has(_XmlList)
                || &quot;object&quot; === type || attArray.has(_XmlElement)) {
                return &quot;&quot;; // Not an attribute
            }
            // Else attribute
            attribute = attArray.has(_XmlAttribute);
            if (attribute &amp;&amp; attribute.name()) {
                member = attribute.name();
            } else {
                if (&quot;_&quot; === member.charAt(0)) {
                    member = member.substr(1);
                }
            }
            return member;
        },

        /**
         * Convert the object member into XML using the provided XML content
         * handler
         *
         * @param {Object} obj
         * @param {String} member Member name
         * @param {gpf.interfaces.wrap(IXmlContentHandler)} wrapped
         * @param {gpf.attributes.Map} attMap Map filled with XML attributes
         * @private
         */
        _objMemberToSubNodes = function /*gpf:inline*/ (obj, member,
            wrapped, attMap) {
            var
                value,
                attArray,
                attribute,
                closeNode,
                idx,
                subValue,
                type,
                name;
            value = obj[member];
            // Exception for dates
            if (value instanceof Date) {
                value = gpf.dateToComparableFormat(value, true);
            }
            attArray = attMap.member(member);
            if (&quot;_&quot; === member.charAt(0)) {
                member = member.substr(1);
            }
            // Check if list
            attribute = attArray.has(_XmlList);
            if (value instanceof Array || attribute) {
                // TODO: what to do when value is empty?
                if (attribute &amp;&amp; attribute.name()) {
                    closeNode = true;
                    wrapped.startElement(&quot;&quot;,
                        attribute.name());
                }
                // Get the list of &#039;candidates&#039;
                attArray = attArray.filter(_XmlElement);
                for (idx = 0; idx &lt; value.length; ++idx) {
                    subValue = value[ idx ];
                    // Select the right candidate
                    type = _selectByType(attArray, subValue);
                    if (type &amp;&amp; type.name()) {
                        name = type.name();
                    } else {
                        name = &quot;item&quot;;
                    }
                    _toContentHandler(subValue, wrapped,
                        name);
                }
                if (closeNode) {
                    wrapped.endElement();
                }
                return;
            }
            attribute = attArray.has(_XmlElement);
            // Element
            if (attribute &amp;&amp; attribute.name()) {
                name = attribute.name();
            }
            _toContentHandler(value, wrapped, name);
        },

        /**
         * Convert the object into XML using the provided XML content handler
         *
         * @param {Object} obj
         * @param {gpf.interfaces.wrap(IXmlContentHandler)} wrapped
         * @param {String} [name=&quot;object&quot;] name Name of the root node
         * @param {gpf.attributes.Map} attMap Map filled with XML attributes
         * @private
         */
        _objPrototypeToContentHandler = function /*gpf:inline*/ (obj,
            wrapped, name, attMap) {
            var
                attArray,
                member,
                value,
                type,
                attName,
                subNodeMembers = 0,
                xmlAttributes = 0,
                idx;
            /*
             * WARNING: the prototype is used instead of the object itself
             * This is done to respect the order provided in the prototype
             * (order that can be overridden through the object).
             * Furthermore, this guarantees we serialize only &#039;members&#039;
             * coming from the &#039;class&#039; definition.
             * It needs two passes:
             * - one for attributes,
             * - another one for sub nodes
             */
            for (member in obj.constructor.prototype) {
                /*
                 * I must also use inherited properties
                 * NO hasOwnProperty
                 */
                value = obj[member];
                // Exception for dates
                if (value instanceof Date) {
                    value = gpf.dateToComparableFormat(value, true);
                }
                type = typeof value;
                // Skip functions
                if (&quot;function&quot; === type) {
                    continue;
                }
                // Check member&#039;s attributes
                attArray = attMap.member(member);
                // Ignore?
                if (attArray.has(_XmlIgnore)) {
                    continue;
                }
                // Decide if attribute or subNode
                attName = _objMemberValueIsAttribute(member, value, type,
                    attArray);
                if (attName) {
                    if (0 === xmlAttributes) {
                        xmlAttributes = {};
                    }
                    xmlAttributes[attName] = value.toString();
                } else {
                    // Subnode
                    if (0 === subNodeMembers) {
                        subNodeMembers = [];
                    }
                    subNodeMembers.push(member);
                }
            }
            wrapped.startElement(&quot;&quot;, name, name, xmlAttributes);
            if (subNodeMembers) {
                for (idx = 0; idx &lt; subNodeMembers.length; ++idx) {
                    _objMemberToSubNodes(obj, subNodeMembers[idx],
                        wrapped, attMap);
                }
            }
        },

        /**
         * Convert the parameter into XML using the provided XML content handler
         *
         * @param {*} obj
         * @param {gpf.interfaces.wrap(IXmlContentHandler)} wrapped
         * @param {String} [name=&quot;object&quot;] name Name of the root node
        * @private
         */
        _toContentHandler = function (obj, wrapped, name) {
            var
                attMap = (new gpfA.Map(obj)).filter(_XmlBase),
                attribute;
            // If no &#039;name&#039;, check the Class attribute
            if (!name) {
                attribute = attMap.member(&quot;Class&quot;).has(_XmlElement);
                if (attribute) {
                    name = attribute.name();
                } else {
                    name = gpf.classDef(obj.constructor).name();
                    if (!name) {
                        name = &quot;object&quot;;
                    }
                }
            }
            // If not an object, serialize the textual representation
            if (&quot;object&quot; !== typeof obj) {
                wrapped.startElement(&quot;&quot;, name);
                wrapped.characters(gpf.value(obj, &quot;&quot;));
            } else {
                _objPrototypeToContentHandler(obj, wrapped, name,
                    attMap);
            }
            wrapped.endElement();
        },

        /**
         * Converts this into XML using the provided XML content handler
         *
         * @@implements gpf.interfaces.IIXmlSerializable:toXml
         * @private
         */
        _toXml = function (out, eventsHandler) {
            var
                WXmlContentHandler =
                    gpf.interfaces.wrap(gpfI.IXmlContentHandler),
                wrapped = new WXmlContentHandler(out);
            wrapped
                .$catch(eventsHandler)
                .$finally(eventsHandler, &quot;ready&quot;);
            _toContentHandler(this, wrapped);
        },

        //endregion

        //region FROM XML

        /**
         * Class to handle object un-serialization from XML
         *
         * @class FromXmlContentHandler
         * @implements gpf.interfaces.IXmlContentHandler
         * @private
         */
        FromXmlContentHandler = gpf.define(&quot;FromXmlContentHandler&quot;, {

            // Even if it is not necessary, let be precise
            &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IXmlContentHandler)],

            _target: null,                          // Object that is serialized
            _firstElement: true,             // startElement has not been called
            _forward: [],                                 // subsequent handlers
            /*
                {
                    {number} type
                                0 IXmlContentHandler
                                1 Element
                                2 List
                    {object} iXCH
                    {string} member
                    {string[]} buffer
                    {number} depth
                }
             */

            constructor: function (target) {
                this._target = target;
                this._firstElement = true;
                this._forward = [];
            },

            _fillFromAttributes: function (attributes) {
                var
                    xmlAttributes = new gpfA.Map(this._target),
                    targetProto = this._target.constructor.prototype,
                    member,
                    attArray,
                    attName;
                for (member in targetProto) {
                    if (&quot;function&quot; === typeof targetProto[member]) {
                        continue; // ignore
                    }
                    attArray = xmlAttributes
                        .member(member)
                        .filter(_XmlAttribute);
                    if (0 &lt; attArray.length()) {
                        gpf.ASSERT(attArray.length() === 1,
                            &quot;Expected one attribute only&quot;);
                        attName = attArray.get(0).name();
                    } else {
                        // Only private are serialized by default as att.
                        if (member.charAt(0) === &quot;_&quot;) {
                            attName = member.substr(1);
                        } else {
                            continue; // ignore
                        }
                    }
                    if (attName in attributes) {
                        this._target[member] =
                            gpf.value(attributes[attName], targetProto[member]);
                    }
                }
            },

            _fillFromElement: function (uri, localName, qName, attributes) {
                var
                    xmlAttributes = new gpfA.Map(this._target)
                        .filter(_XmlRawElement),
                    forward = this._forward[0],
                    members,
                    idx,
                    member,
                    attArray,
                    jdx,
                    attribute;
                gpf.interfaces.ignoreParameter(uri);
                gpf.interfaces.ignoreParameter(qName);
                gpf.interfaces.ignoreParameter(attributes);
                // If
                if (undefined === forward) {
                    // No forward, check all members
                    members = xmlAttributes.members();
                } else {
                    // At least one forward exists, it is related to a member
                    gpf.ASSERT(forward.type !== 0, &quot;No content handler here&quot;);
                    members = [forward.member];
                }
                for (idx = 0; idx &lt; members.length; ++idx) {
                    member = members[idx];
                    attArray = xmlAttributes.member(member);
                    for (jdx = 0; jdx &lt; attArray.length(); ++jdx) {
                        attribute = attArray.get(jdx);
                        // TODO handle namespaces
                        if (attribute.name() === localName) {
                            // Attribute found, try
                            if (this._fillFromRawElement(member, attribute)) {
                                return;
                            }
                        }
                    }
                }
                // Ignore?
            },

            _fillFromRawElement: function (member, attribute) {
                var
                    obj,
                    forward;
                if (attribute instanceof _XmlElement) {
                    // Build new object and assign it to the member
                    if (attribute.objClass()) {
                        obj = new (attribute.objClass())();
                        this._target[member] = obj;
                        // Query IXmlContentHandler
                        forward = gpfI.query(obj, gpfI.IXmlContentHandler);
                    }
                    if (forward) {
                        forward = {
                            type: 0,
                            iXCH: forward
                        };
                    } else {
                        forward = {
                            type: 1,
                            member: member,
                            buffer: []
                        };
                    }
                } else if (attribute instanceof _XmlList) {
                    // The member is an array of objects
                    this._target[member] = [];
                    forward = {
                        type: 2,
                        member: member
                    };
                }
                if (forward) {
                    forward.depth = 1;
                    this._forward.unshift(forward);
                    return true;
                } else {
                    return false;
                }
            },

            //region gpf.interfaces.IXmlContentHandler

            /**
             * @implements gpf.interfaces.IXmlContentHandler:characters
             */
            characters: function (buffer, eventsHandler) {
                var forward = this._forward[0];
                if (undefined !== forward) {
                    if (0 === forward.type) {
                        forward.iXCH.characters.apply(forward.iXCH, arguments);
                    } else if (1 === forward.type) {
                        forward.buffer.push(buffer);
                    }
                }
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:endDocument
             */
            endDocument: function (eventsHandler) {
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:endElement
             */
            endElement: function (eventsHandler) {
                var
                    forward = this._forward[0],
                    memberValue,
                    textValue;
                if (undefined !== forward) {
                    if (0 === forward.type) {
                        forward.iXCH.endElement.apply(forward.iXCH, arguments);
                    } else if (1 === forward.type) {
                        memberValue = this._target[forward.member];
                        textValue = forward.buffer.join(&quot;&quot;);
                        if (memberValue instanceof Array) {
                            memberValue.push(textValue);
                        } else {
                            this._target[forward.member] = gpf.value(textValue,
                                memberValue);
                        }
                    } /*else if (2 === forward.type) {
                        // Nothing to do

                    } */
                    if (0 === --forward.depth) {
                        this._forward.shift();
                    }
                }
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:endPrefixMapping
             */
            endPrefixMapping: function (prefix) {
                // Nothing to do (?)
                gpfI.ignoreParameter(prefix);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:ignorableWhitespace
             */
            ignorableWhitespace: function (buffer, eventsHandler) {
                // Nothing to do
                gpfI.ignoreParameter(buffer);
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces
             *             .IXmlContentHandler:processingInstruction
             */
            processingInstruction: function (target, data, eventsHandler) {
                // Not relevant
                gpfI.ignoreParameter(target);
                gpfI.ignoreParameter(data);
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:setDocumentLocator
             */
            setDocumentLocator: function (locator) {
                // Nothing to do
                gpfI.ignoreParameter(locator);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:skippedEntity
             */
            skippedEntity: function (name) {
                // Nothing to do
                gpfI.ignoreParameter(name);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:startDocument
             */
            startDocument: function (eventsHandler) {
                // Nothing to do
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:startElement
             */
            startElement: function (uri, localName, qName, attributes,
                eventsHandler) {
                var
                    forward = this._forward[0];
                gpf.interfaces.ignoreParameter(uri);
                gpf.interfaces.ignoreParameter(localName);
                gpf.interfaces.ignoreParameter(qName);
                if (undefined !== forward) {
                    if (0 === forward.type) {
                        ++forward.depth;
                        forward.iXCH.startElement.apply(forward.iXCH,
                            arguments);
                    } else {
                        this._fillFromElement.apply(this, arguments);
                    }
                } else if (this._firstElement) {
                    this._firstElement = false;
                    /*
                     * First time startElement is called, ignore localName
                     * but process attributes.
                     */
                    this._fillFromAttributes(attributes);
                } else {
                    /*
                     * Elements are used to introduce a sub-object
                     */
                    this._fillFromElement.apply(this, arguments);
                }
                gpfFireEvent.apply(this, [&quot;ready&quot;, eventsHandler]);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:startPrefixMapping
             */
            startPrefixMapping: function (prefix, uri) {
                // Nothing to do (?)
                gpfI.ignoreParameter(prefix);
                gpfI.ignoreParameter(uri);
            }

            //endregion

        }),

        _fromXml = function (target) {
            return new FromXmlContentHandler(target);
        };

        // endregion

    //region XML Writer

    /**
     * A class to serialize an XML into a string
     *
     * @class gpf.xml.Writer
     * @implements gpf.interfaces.IXmlContentHandler
     */
    gpf.define(&quot;gpf.xml.Writer&quot;, {

        &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IXmlContentHandler)],

        private: {

            /**
             * @type {gpf.interfaces.IWritableStream}
             * @private
             */
            _stream: null,

            /**
             * @type {Boolean[]}
             * @private
             */
            _branch: [],

            /**
             * @type {String[]}
             * @private
             */
            _pendingPrefixMappings: [],

            /**
             * @type {String[]}
             * @private
             */
            _buffer: [],

            /**
             * @type {gpf.events.Handler}
             * @private
             */
            _eventsHandler: null,

            /**
             * Close the current tag (if opened) in order to put content in it
             *
             * @private
             */
            _closeLeafForContent: function() {
                var leaf;
                if (this._branch.length) {
                    leaf = this._branch[this._branch.length - 1];
                    if (!leaf.hasContent) {
                        this._buffer.push(&quot;&gt;&quot;);
                        leaf.hasContent = true;
                    }
                }
            },

            /**
             * Flush the buffer into the stream
             *
             * @param {gpf.events.Handler} eventsHandler
             * @private
             */
            _flush: function (eventsHandler) {
                this._eventsHandler = eventsHandler;
                this._flushed();
            },

            /**
             * Handle write event on stream
             *
             * @param {gpf.events.Event} event
             * @private
             */
            _flushed: function (event) {
                var
                    eventsHandler;
                if (event
                    &amp;&amp; event.type() === gpfI.IWritableStream.EVENT_ERROR) {
                    gpfFireEvent.apply(this, [
                        event,
                        this._eventsHandler
                    ]);
                } else if (0 === this._buffer.length) {
                    eventsHandler = this._eventsHandler;
                    this._eventsHandler = null;
                    gpfFireEvent.apply(this, [
                        gpfI.IWritableStream.EVENT_READY,
                        eventsHandler
                    ]);
                } else {
                    this._stream.write(this._buffer.shift(),
                        gpf.Callback.bind(this, &quot;_flushed&quot;));
                }
            }

        },

        public: {

            /**
             * @param {gpf.interfaces.IWritableStream} stream
             * @constructor
             */
            constructor: function(stream) {
                this._stream = gpfI.query(stream, gpfI.IWritableStream, true);
                this._branch = [];
                this._pendingPrefixMappings = [];
                this._buffer = [];
            },

            //region gpf.interfaces.IXmlContentHandler

            /**
             * @implements gpf.interfaces.IXmlContentHandler:characters
             */
            characters: function (buffer, eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                this._closeLeafForContent();
                this._buffer.push(buffer);
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:endDocument
             */
            endDocument: function (eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                // Nothing to do
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:endElement
             */
            endElement: function (eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                var
                    leaf = this._branch.pop();
                if (leaf.hasContent) {
                    this._buffer.push(&quot;&lt;/&quot;, leaf.qName, &quot;&gt;&quot;);
                } else {
                    this._buffer.push(&quot;/&gt;&quot;);
                }
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:endPrefixMapping
             */
            endPrefixMapping: function (prefix) {
                // Nothing to do (?)
                gpf.interfaces.ignoreParameter(prefix);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:ignorableWhitespace
             */
            ignorableWhitespace: function (buffer, eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                this._closeLeafForContent();
                this._buffer.push(buffer);
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:
             * processingInstruction
             */
            processingInstruction: function (target, data, eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                this._buffer.push(&quot;&lt;?&quot;, target, &quot; &quot;, gpf.escapeFor(data, &quot;xml&quot;),
                    &quot;?&gt;&quot;);
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:setDocumentLocator
             */
            setDocumentLocator: function (locator) {
                // Nothing to do
                gpf.interfaces.ignoreParameter(locator);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:skippedEntity
             */
            skippedEntity: function (name) {
                // Nothing to do
                gpf.interfaces.ignoreParameter(name);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:startDocument
             */
            startDocument: function (eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                // Nothing to do
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:startElement
             */
            startElement: function (uri, localName, qName, attributes,
                eventsHandler) {
                gpf.ASSERT(null === this._eventsHandler, &quot;Write in progress&quot;);
                var
                    attName,
                    attValue,
                    len,
                    idx;
                if (undefined === qName &amp;&amp; !uri) {
                    qName = localName;
                }
                this._closeLeafForContent();
                var leaf = {
                    hasContent: false,
                    qName: qName
                };
                this._branch.push(leaf);
                this._buffer.push(&quot;&lt;&quot;, qName);
                if (attributes) {
                    for (attName in attributes) {
                        if (attributes.hasOwnProperty(attName)) {
                            this._buffer.push(&quot; &quot;, attName, &quot;=\&quot;&quot;);
                            attValue = gpf.escapeFor(
                                attributes[attName].toString(), &quot;xml&quot;);
                            if (-1 &lt; attValue.indexOf(&quot;\&quot;&quot;)) {
                                attValue = gpf.replaceEx(attValue, {
                                    &quot;\&quot;&quot;: &quot;&amp;quot;&quot;
                                });
                            }
                            this._buffer.push(attValue, &quot;\&quot;&quot;);
                        }
                    }
                }
                len = this._pendingPrefixMappings.length;
                if (len) {
                    for (idx = 0; idx &lt; len; ++idx) {
                        this._buffer.push(&quot; &quot;,
                            this._pendingPrefixMappings[idx]);
                    }
                    this._pendingPrefixMappings = [];
                }
                this._flush(eventsHandler);
            },

            /**
             * @implements gpf.interfaces.IXmlContentHandler:startPrefixMapping
             */
            startPrefixMapping: function (prefix, uri) {
                this._pendingPrefixMappings.push([&quot;xmlns:&quot;, prefix, &quot;:\&quot;&quot;,
                    gpf.escapeFor(uri, &quot;xml&quot;), &quot;\&quot;&quot;].join(&quot;&quot;));
            }

            //endregion

        }

    });

    //endregion

    //region XML Parser
/* TBD
    gpf.xml.Parser = gpf.Parser.extend({

        _contentHandler: null,

        constructor: function (contentHandler) {
            this._contentHandler = contentHandler;
        },

        _parse: function (char) {

            if (_XMLPARSER_STATE_NONE === this._state) {
                
            }

        },

        _reset: function () {

        }

    });
*/
    //endregion

    //region Parsing

    /**
     * Tries to convert any value into XML
     *
     * @param {*} value
     * @param {Object} out Recipient object for XML serialization
     * @param {gpf.events.Handler} eventsHandler
     *
     * @event ready
     */
    gpf.xml.convert = function (value, out, eventsHandler) {
        var
            iXmlSerializable;
        if (&quot;string&quot; === typeof value) {
            throw gpf.Error.NotImplemented();
        } else if (&quot;object&quot; === typeof value) {
            iXmlSerializable = gpfI.query(value, gpfI.IXmlSerializable);
            if (null === iXmlSerializable) {
                iXmlSerializable = new gpf.xml.ConstNode(value);
            }
            iXmlSerializable.toXml(out, eventsHandler);
        }
    };

    //endregion

    //region Helpers

    var
        _firstValidChar = gpf._alpha + gpf._ALPHA + &quot;_&quot;,
        _otherValidChars = _firstValidChar + &quot;012345789.-&quot;;

    gpf.extend(gpf.xml, {

        /**
         * Check that the provided name can be use as an element or attribute
         * name
         *
         * @param {String} name
         * @return {Boolean}
         */
        isValidName: function (name) {
            var
                idx;
            if (0 === name.length
                || -1 === _firstValidChar.indexOf(name.charAt(0))) {
                return false;
            }
            for (idx = 1; idx &lt; name.length; ++idx) {
                if (-1 === _otherValidChars.indexOf(name.charAt(idx))) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Make sure that the provided name can be use as an element or
         * attribute name
         *
         * @param {String} name
         * @return {String} a valid attribute/element name
         */
        toValidName: function (name) {
            var newName;
            if (gpf.xml.isValidName(name)) {
                return name;
            }
            // Try with a starting _
            newName = &quot;_&quot; + name;
            if (!gpf.xml.isValidName(newName)) {
                throw gpf.Error.XmlInvalidName();
            }
            return newName;
        }

    });

    //endregion

/*#ifndef(UMD)*/
}()); /* End of privacy scope */
/*#endif*/</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
