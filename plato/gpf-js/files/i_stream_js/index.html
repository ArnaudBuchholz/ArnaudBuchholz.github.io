<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - i_stream.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>i_stream.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.97</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1071</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">100.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.09</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*#ifndef(UMD)*/
(function () { /* Begin of privacy scope */
    &quot;use strict&quot;;
/*#endif*/

    var
        gpfI = gpf.interfaces,
        gpfFireEvent = gpf.events.fire,
        _BUFREADSTREAM_READ_SIZE        = 256,
        _BUFREADSTREAM_ISTATE_INIT        = 0,
        _BUFREADSTREAM_ISTATE_INPROGRESS  = 1,
        _BUFREADSTREAM_ISTATE_WAITING     = 2,
        _BUFREADSTREAM_ISTATE_EOS         = 3;

    /**
     * The Readable stream interface is the abstraction for a source of data
     * that you are reading from. In other words, data comes out of a Readable
     * stream.
     *
     * @class gpf.interfaces.IReadableStream
     * @extends gpf.interfaces.Interface
     */
    gpf._defIntrf(&quot;IReadableStream&quot;, {

        /**
         * Triggers the reading of data.
         * The expected behavior is:
         * - The callback is asynchronous
         * - One of the following callback must be called after a read
         *   - EVENT_ERROR: an error occurred.
         *     the stream can&#039;t be used after this.
         *   - EVENT_END_OF_STREAM: stream ended.
         *     the stream can&#039;t be used after this.
         *   - EVENT_DATA: a buffer is provided, it can&#039;t be empty.
         *
         * @param {Number} [size=0] size Number of bytes to read. Read
         * as much as possible if 0
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event data Some data is ready to be used
         * @eventParam {gpf.IReadOnlyArray} buffer Bytes buffer
         *
         * @event eos No more data can be read from the stream
         *
         */
        &quot;[read]&quot;: [gpf.$ClassEventHandler()],
        read: function (size, eventsHandler) {
            gpf.interfaces.ignoreParameter(size);
            gpf.interfaces.ignoreParameter(eventsHandler);
        },

        static: {
            EVENT_ERROR: &quot;error&quot;,
            EVENT_DATA: &quot;data&quot;,
            EVENT_END_OF_STREAM: &quot;eos&quot;,

            EXCEPTION_READ_IN_PROGRESS: {
                message: &quot;Read in progress&quot;
            }
        }

    });

    /**
     * The Writable stream interface is an abstraction for a destination that
     * you are writing data to.
     * The expected behavior is:
     * - The callback is asynchronous
     * - One of the following callback must be called after a read
     *   - EVENT_ERROR: an error occurred.
     *     the stream can&#039;t be used after this.
     *   - EVENT_READY: the write operation succeeded, the provided buffer has
     *     been fully written (otherwise an error is thrown)
     *
     * @class gpf.interfaces.IReadableStream
     * @extends gpf.interfaces.Interface
     */
    gpf._defIntrf(&quot;IWritableStream&quot;, {

        /**
         * Triggers the writing of data
         *
         * @param {IReadOnlyArray} int8buffer Buffer to write
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event ready it is appropriate to begin writing more data to the
         * stream
         *
         */
        &quot;[write]&quot;: [gpf.$ClassEventHandler()],
        write: function (int8buffer, eventsHandler) {
            gpf.interfaces.ignoreParameter(int8buffer);
            gpf.interfaces.ignoreParameter(eventsHandler);
        },

        static: {
            EVENT_ERROR: &quot;error&quot;,
            EVENT_READY: &quot;ready&quot;,

            EXCEPTION_WRITE_IN_PROGRESS: {
                message: &quot;Read in progress&quot;
            }
        }

    });

    /**
     * The stream combines both IReadableStream and IWritableStream
     */
    gpf._defIntrf(&quot;IStream&quot;, {

        /**
         * @inheritDoc gpf.interfaces.IReadableStream:read
         */
        &quot;[read]&quot;: [gpf.$ClassEventHandler()],
        read: function (size, eventsHandler) {
            gpf.interfaces.ignoreParameter(size);
            gpf.interfaces.ignoreParameter(eventsHandler);
        },

        /**
         * @inheritDoc gpf.interfaces.IWritableStream:write
         */
        &quot;[write]&quot;: [gpf.$ClassEventHandler()],
        write: function (int8buffer, eventsHandler) {
            gpf.interfaces.ignoreParameter(int8buffer);
            gpf.interfaces.ignoreParameter(eventsHandler);
        }

    });

    /**
     * Text stream: instead of an int8 buffer, the interface handles strings
     *
     * @class gpf.interfaces.ITextStream
     * @extends gpf.interfaces.IStream
     *
     * @event data Some data is ready to be ready
     * @eventParam {String} buffer
     */
    gpf._defIntrf(&quot;ITextStream&quot;, gpfI.IStream, {
    });

    //endregion

    //region Stream namespace

    gpf.stream = {

        /**
         *
         * @param {gpf.interfaces.IReadableStream} readable
         * @param {gpf.interfaces.IWritableStream} writable
         * @param {Object} [options=undefined] options
         * @param {gpf.events.Handler} eventsHandler
         *
         * @event done The readable stream was written in the writable one
         */
        pipe: function (readable, writable, options, eventsHandler) {
            var
                scope = new StreamPipeScope(readable, writable, options,
                    eventsHandler);
            scope.ready();
        }

    };

    //region gpf.stream.pipe implementation

    /**
     * Creates a custom EventsHandler to sequence the calls to be made
     *
     * @param {gpf.interfaces.IReadableStream} readable
     * @param {gpf.interfaces.IWritableStream} writable
     * @param {Object} [options=undefined] options
     * @param {gpf.events.Handler} eventsHandler
     * @constructor
     */
    function StreamPipeScope (readable, writable, options, eventsHandler) {
        this._readable = gpfI.queryInterface(readable, gpfI.IReadableStream,
            true);
        this._writable = gpfI.queryInterface(writable, gpfI.IWritableStream,
            true);
        if (undefined === eventsHandler) {
            this._options = {};
            this._eventsHandler = options;
        } else {
            this._options = options;
            this._eventsHandler = eventsHandler;
        }
        this.scope = this;
    }

    StreamPipeScope.prototype = {
        _readable: null,        // Readable stream
        _writable: null,        // Writable stream
        _options: null,         // Options
        _eventsHandler: null,   // Original events handler
        scope: null             // This eventsHandler scope
    };

    /**
     * ready event handler
     *
     * @param {gpf.Event} event
     */
    StreamPipeScope.prototype.ready = function () {
        var chunkSize = this._options.chunkSize || 4096;
        this._readable.read(chunkSize, this);
    };

    /**
     * eos event handler
     *
     * @param {gpf.Event} event
     */
    StreamPipeScope.prototype.eos = function (/*event*/) {
        gpfFireEvent(&quot;done&quot;, this._eventsHandler);
    };

    /**
     * data event handler
     *
     * @param {gpf.Event} event
     */
    StreamPipeScope.prototype.data = function (event) {
        var buffer = event.get(&quot;buffer&quot;);
        this._writable.write(buffer, this);
    };

    /**
     * Any other event handler
     *
     * @param {gpf.Event} event
     */
    StreamPipeScope.prototype[&quot;*&quot;] = function (event) {
        // Forward to original handler (error or data)
        gpfFireEvent(event, this._eventsHandler);
    };

    //endregion

    //region gpf.stream.Out

    /**
     * console.log exposed as an output stream.
     * Line is buffered until the carriage return.
     *
     * @class gpf.stream.Out
     * @implements gpf.interfaces.IWritableStream
     */
    gpf.define(&quot;gpf.stream.Out&quot;, {

        &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IWritableStream)],

        public: {

            /**
             * @constructor
             */
            constructor: function () {
                this._buffer = [];
            },

            /**
             * @inheritdoc gpf.interfaces.IWritableStream:write
             */
            write: function (buffer, eventsHandler) {
                // TODO: do we allow mixin strings &amp; buffer
                if (&quot;string&quot; === typeof buffer) {
                    this._writeString(buffer, eventsHandler);
                } else {
                    this._writeBuffer(buffer, eventsHandler);
                }
            }

        },

        private: {

            /**
             * Line buffer
             *
             * @type {String[]}
             * private
             */
            _buffer: [],

            /**
             * @inheritdoc gpf.interfaces.IWritableStream:write
             *
             * String version
             *
             * @private
             */
            _writeString: function (buffer, eventsHandler) {
                var
                    lines = buffer.split(&quot;\n&quot;),
                    len,
                    idx;
                len = lines.length;
                if (len) {
                    // If the array has at least 2 elements, \n was present
                    if (1 &lt; len) {
                        console.log(this._buffer.join(&quot;&quot;)
                        + this._trimFinalR(lines[0]));
                        this._buffer = [];
                    }
                    --len;
                    // The last item of the array did not have \n
                    if (lines[len].length) {
                        this._buffer.push(lines[len]);
                    }
                    // Dump other lines
                    for (idx = 1; idx &lt; len; ++idx) {
                        console.log(this._trimFinalR(lines[idx]));
                    }
                }
                gpfFireEvent.apply(this, [
                    gpfI.IWritableStream.EVENT_READY,
                    eventsHandler
                ]);
            },

            /**
             * Remove final \r if any
             *
             * @param {String} line
             * @return {String}
             * @private
             */
            _trimFinalR: function (line) {
                var lastCharIdx = line.length - 1;
                if (-1 &lt; lastCharIdx &amp;&amp; line.charAt(lastCharIdx) === &quot;\r&quot;) {
                    return line.substr(0, lastCharIdx);
                }
                return line;
            },

            /**
             * @inheritdoc gpf.interfaces.IWritableStream:write
             *
             * String version
             *
             * @private
             */
            _writeBuffer: function (buffer, eventsHandler) {
                gpf.interfaces.ignore(buffer);
                gpf.interfaces.ignore(eventsHandler);
                /**
                 * TODO implement
                 * Would need to reuse UTF8 decoder in order to output
                 * characters.
                 * Maybe I can create a ReadableStream which input would be
                 * appended with the buffer and rely on the createDecoder
                 * stream.
                 *
                 * Right now: I don&#039;t need it.
                 */
                throw gpf.Error.NotImplemented();
            }

        }

    });

    //endregion

    /**
     * Handles a buffered stream that depends on a read stream.
     * The way the underlying buffer is read and converted can be overridden
     * through the following protected APIs:
     * - _readSize
     * - _addToBuffer
     *
     * @class gpf.stream.BufferedOnRead
     * @abstract
     * @implements gpf.interfaces.IReadableStream
     */
    gpf.define(&quot;gpf.stream.BufferedOnRead&quot;, {

        &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IReadableStream)],

        //region Configurable part

        protected: {

            /**
             * Output buffer containing content to be read
             *
             * @type {*[]}
             * @protected
             */
            _buffer: [],

            /**
             * Length of the buffer (compared with read size)
             *
             * @type {Number}
             * @protected
             */
            _bufferLength: 0,

            /**
             * Underlying stream default read size
             *
             * @type {Number}
             * @protected
             */
            _readSize: _BUFREADSTREAM_READ_SIZE,

            /**
             * Process underlying stream buffer (this should grow the output
             * buffer)
             *
             * @param {Array} buffer
             * @abstract
             * @protected
             */
            _addToBuffer: function (buffer) {
                gpf.interfaces.ignoreParameter(buffer);
                throw gpf.Error.Abstract();
            },

            /**
             * Underlying stream reached its end (this may grow the output
             * buffer)
             *
             * @protected
             */
            _endOfInputStream: function () {
            },

            /**
             * Read buffer.
             * This default implementation checks the buffer type to switch
             * between string and byte array.
             *
             * @param {Number} size
             * @returns {String|Array}
             * @protected
             */
            _readFromBuffer: function (size) {
                gpf.ASSERT(0 !== this._buffer.length, &quot;Buffer is not empty&quot;);
                if (&quot;string&quot; === this._buffer[0]) {
                    return this._readFromStringBuffer(size);
                } else {
                    return this._readFromByteBuffer(size);
                }
            },

            /**
             * Read string buffer.
             *
             * @param {Number} size
             * @returns {String}
             * @protected
             */
            _readFromStringBuffer: function (size) {
                var
                    result = gpf.stringExtractFromStringArray(this._buffer,
                        size);
                this._bufferLength -= result.length;
                return result;
            },

            /**
             * Read byte buffer.
             *
             * @param {Number} size
             * @returns {Array}
             * @protected
             */
            _readFromByteBuffer: function (size) {
                this._bufferLength -= size;
                return this._buffer.splice(0, size);
            }

        },

        //endregion

        //region Implementation

        public: {

            /**
             * @param {gpf.interfaces.IReadableStream} input
             * @constructor
             */
            constructor: function (input) {
                this._iStream = gpfI.query(input, gpfI.IReadableStream, true);
                this._buffer = [];
            },

            //region gpf.interfaces.IReadableStream

            /**
             * @implements gpf.interfaces.IReadableStream:read
             */
            read: function (size, eventsHandler) {
                var
                    iState = this._iState,
                    length = this._bufferLength;
                if (_BUFREADSTREAM_ISTATE_INPROGRESS === iState) {
                    // A read call is already in progress
                    throw gpfI.IReadableStream.EXCEPTION_READ_IN_PROGRESS;

                } else if (size &lt; length
                    || length &amp;&amp; _BUFREADSTREAM_ISTATE_EOS === iState) {
                    // Enough chars in the output buffer to do the read
                    // OR there won&#039;t be any more chars. Can output something.
                    if (0 === size || size &gt; length) {
                        size = length;
                    }
                    gpfFireEvent.apply(this, [
                        gpfI.IReadableStream.EVENT_DATA,
                        {
                            buffer: this._readFromBuffer(size)
                        },
                        eventsHandler
                    ]);

                } else if (_BUFREADSTREAM_ISTATE_EOS === iState) {
                    // No more input and output buffer is empty
                    gpfFireEvent.apply(this, [
                        gpfI.IReadableStream.EVENT_END_OF_STREAM,
                        eventsHandler
                    ]);

                } else {
                    // Read input
                    if (_BUFREADSTREAM_ISTATE_INIT === this._iState) {
                        // Very first call, create callback for input reads
                        this._cbRead = new gpf.Callback(this._onRead, this);
                    }
                    this._iState = _BUFREADSTREAM_ISTATE_INPROGRESS;
                    // Backup parameters
                    this._size = size;
                    this._eventsHandler = eventsHandler;
                    this._iStream.read(this._readSize, this._cbRead);
                }
            }

            //endregion
        },

        private: {

            /**
             * Input stream
             * @type {gpf.interfaces.IReadableStream}
             */
            _iStream: null,

            /**
             * Input stream read callback (pointing to this:_onRead)
             * @type {gpf.Callback}
             */
            _cbRead: null,

            /**
             * Input state
             * @type {Number} see _BUFREADSTREAM_ISTATE_xxx
             */
            _iState: _BUFREADSTREAM_ISTATE_INIT,

            /**
             * Pending read call size
             * @type {Number}
             */
            _size: 0,

            /**
             * Pending read call event handlers
             * @type {gpf.events.Handler}
             */
            _eventsHandler: null,

            /**
             * Handles input stream read event
             *
             * @param {gpf.events.Event} event
             * @private
             */
            _onRead: function (event) {
                var
                    type = event.type();
                if (type === gpfI.IReadableStream.EVENT_END_OF_STREAM) {
                    this._iState = _BUFREADSTREAM_ISTATE_EOS;
                    this._endOfInputStream();
                    // Redirect to read with backed parameters
                    return this.read(this._size, this._eventsHandler);

                } else if (type === gpfI.IReadableStream.EVENT_ERROR) {
                    // Forward the event
                    gpfFireEvent.apply(this, [
                        event,
                        this._eventsHandler
                    ]);

                } else {
                    this._iState = _BUFREADSTREAM_ISTATE_WAITING;
                    this._addToBuffer(event.get(&quot;buffer&quot;));
                    if (0 &lt; this._bufferLength) {
                        // Redirect to read with backed parameters
                        return this.read(this._size, this._eventsHandler);
                    } else {
                        // Try to read source again
                        this._iStream.read(_BUFREADSTREAM_READ_SIZE,
                            this._cbRead);
                    }
                }
            }

        }

        //endregion
    });

    /**
     * Bit reader (count is expressed as bits)
     * Rely on a underlying byte stream reader
     *
     * @class gpf.stream.BitReader
     * @extend gpf.stream.BufferedOnRead
     * @implements gpf.interfaces.IReadableStream
     */
    gpf.define(&quot;gpf.stream.BitReader&quot;, &quot;gpf.stream.BufferedOnRead&quot;, {

        &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IReadableStream)],

        //region Implementation

        protected: {

            /**
             * @inheritdoc gpf.stream.BufferedOnRead:_addToBuffer
             */
            _addToBuffer: function (buffer) {
                this._buffer = this._buffer.concat(buffer);
                this._bufferLength += buffer.length * 8; // Expressed in bits
            },

            /**
             * @inheritdoc gpf.stream.BufferedOnRead:_readFromBuffer
             */
            _readFromBuffer: function (size) {
                var
                    buffer = this._buffer, // alias
                    result = [],
                    readBit = this._bit,
                    readByte,
                    writeBit = 0,
                    writeByte = 0;
                readByte = buffer[0];
                while (0 &lt; size) {
                    --size; // Expressed in bits
                    writeByte &lt;&lt;= 1;
                    if (0 !== (readByte &amp; readBit)) {
                        writeByte |= 1;
                    }
                    // Next read
                    --this._bufferLength; // Because expressed in bits
                    if (readBit === 1) {
                        // End of current byte, move to next one
                        buffer.shift();
                        readByte = buffer[0];
                        readBit = 128;
                    } else {
                        readBit &gt;&gt;= 1;
                    }
                    // Next write
                    if (writeBit === 7) {
                        result.push(writeByte);
                        writeByte = 0;
                        writeBit = 0;
                    } else {
                        ++writeBit;
                    }
                }
                if (writeBit !== 0) {
                    result.push(writeByte);
                }
                this._bit = readBit;
                return result;
            }

        },

        private: {

            /**
             * Current bit cursor
             *
             * @type {Number}
             * @private
             */
            _bit: 128

        }

        //endregion

    });

    var
        /**
         * Base class used to fully read a stream
         *
         * @class AbstractStreamReader
         * @abstract
         * @private
         */
        AbstractStreamReader = gpf.define(&quot;AbstractStreamReader&quot;, {

            public: {

                constructor: function (scope, eventsHandler) {
                    this._scope = gpf.Callback.resolveScope(scope);
                    this._eventsHandler = eventsHandler;
                },

                read: function (stream) {
                    stream.read(this._readSize,
                        gpf.Callback.bind(this, &quot;callback&quot;));
                }

            },

            protected: {

                _readSize: 0,

                _consolidateBuffer: function () {
                    throw gpf.Error.Abstract();
                },

                _addBuffer: function (buffer) {
                    gpf.interfaces.ignoreParameter(buffer);
                    throw gpf.Error.Abstract();
                }
            },

            private: {

                _scope: null,
                _eventsHandler: null,

                callback: function (event) {
                    var
                        type = event.type(),
                        stream = event.scope();
                    if (type === gpfI.IReadableStream.EVENT_END_OF_STREAM) {
                        gpfFireEvent.apply(this._scope, [
                            gpfI.IReadableStream.EVENT_DATA,
                            {
                                buffer: this._consolidateBuffer()
                            },
                            this._eventsHandler
                        ]);

                    } else if (type === gpfI.IReadableStream.EVENT_ERROR) {
                        // Forward the event
                        gpfFireEvent.apply(this._scope, [
                            event,
                            this._eventsHandler
                        ]);

                    } else {
                        this._addBuffer(event.get(&quot;buffer&quot;));
                        this.read(stream);
                    }
                }

            }

        }),

        StreamReader = gpf.define(&quot;StreamReader&quot;, AbstractStreamReader, {

            public: {

                constructor: function (scope, eventsHandler, concatMethod) {
                    this._super(scope, eventsHandler);
                    this._concatMethod = concatMethod;
                }

            },

            protected: {

                _consolidateBuffer: function () {
                    return this._concatMethod(this._buffer);
                },

                _addBuffer: function (buffer) {
                    this._buffer = this._concatMethod(this._buffer, buffer);
                }
            },

            private: {

                _buffer: undefined,
                _concatMethod: null

            }

        }),

        B64StreamReader = gpf.define(&quot;B64StreamReader&quot;, AbstractStreamReader, {

            public: {

                constructor: function (scope, eventsHandler) {
                    this._super(scope, eventsHandler);
                    this._buffer = [];
                }

            },

            protected: {

                _readSize: 6,

                _consolidateBuffer: function () {
                    return this._buffer.join(&quot;&quot;);
                },

                _addBuffer: function (buffer) {
                    this._buffer.push(gpf.bin.toBase64(buffer[0]));
                }

            },

            private: {

                _buffer: []

            }

        });

    /**
     * Read the whole stream and concat the buffers using the provided handler
     *
     * @param {gpf.interfaces.ITextStream} stream
     * @param {Function} concatMethod
     * @param {gpf.events.Handler} eventsHandler
     *
     * @forwardThis
     *
     * @event data finished reading the stream, the buffer is provided
     * @eventParam {Array|String} buffer
     */
    gpf.stream.readAll = function (stream, concatMethod, eventsHandler) {
        stream = gpf.interfaces.query(stream, gpfI.IReadableStream,  true);
        (new StreamReader(this, eventsHandler, concatMethod)).read(stream);
    };

    /**
     * Read the whole stream and returns a base64 string
     *
     * @param {gpf.interfaces.ITextStream} stream
     * @param {gpf.events.Handler} eventsHandler
     *
     * @forwardThis
     *
     * @event data finished reading the stream, the buffer is provided
     * @eventParam {Array|String} buffer
     */
    gpf.stream.readAllAsB64 = function (stream, eventsHandler) {
        stream = new gpf.stream.BitReader(stream);
        (new B64StreamReader(this, eventsHandler)).read(stream);
    };

    //endregion

    //region NodeJS specific classes

    if (gpf.node) {

        /**
         * Wraps a readable stream from NodeJS into a IReadableStream
         *
         * @class gpf.stream.NodeReadable
         * @implements gpf.interfaces.IReadableStream
         */
        gpf.define(&quot;gpf.node.ReadableStream&quot;, {

            &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IReadableStream)],

            public: {

                /**
                 * @param {stream.Readable} stream
                 * @constructor
                 */
                constructor: function (stream) {
                    this._stream = stream;
                    stream.on(&quot;end&quot;, gpf.Callback.bind(this, &quot;_onEnd&quot;));
                    stream.on(&quot;error&quot;, gpf.Callback.bind(this, &quot;_onError&quot;));
                },

                /**
                 * @inheritDoc gpf.interfaces.IReadableStream:read
                 */
                &quot;[read]&quot;: [gpf.$ClassEventHandler()],
                read: function (size, eventsHandler) {
                    var chunk;
                    // Used as a critical section to prevent concurrent reads
                    if (null !== this._eventsHandler) {
                        // A read call is already in progress
                        throw gpfI.IReadableStream.EXCEPTION_READ_IN_PROGRESS;
                    }
                    this._eventsHandler = eventsHandler;
                    // If we received the &quot;readable&quot; event
                    if (this._readable) {
                        // We try to read a chunk
                        chunk = this._stream.read(size);
                        if (chunk) {
                            this._onData(chunk);
                            return;
                        }
                        // No chunk means we must wait for next &quot;readable&quot;
                        this._readable = false;
                    }
                    this._size = size;
                    this._stream.once(&quot;readable&quot;,
                        gpf.Callback.bind(this, &quot;_onReadable&quot;));
                }

            },

            protected: {

                /**
                 * Before doing any read on the stream, we wait for the readable
                 * event to be thrown
                 *
                 * @type {Boolean}
                 * @protected
                 */
                _readable: false,

                /**
                 * Last read eventsHandler
                 * Also used as a critical section to prevent concurrent reads
                 *
                 * @type {gpf.events.Handler}
                 * @protected
                 */
                _eventsHandler: null,

                /**
                 * Last read size (if pending)
                 *
                 * @type {Number}
                 * @protected
                 */
                _size: 0,

                /**
                 * Provides an atomic access to the _eventsHandler variable
                 * (that is immediately cleared)
                 *
                 * @return {gpf.events.Handler}
                 * @private
                 */
                _getEventsHandler: function () {
                    var result = this._eventsHandler;
                    gpf.ASSERT(null !== result, &quot;Event handler expected&quot;);
                    this._eventsHandler = null;
                    return result;
                },

                /**
                 * Handles &quot;readable&quot; stream event
                 * NOTE that it was registered with once
                 *
                 * @private
                 */
                _onReadable: function() {
                    this._readable = true;
                    this._onData(this._stream.read(this._size));
                },

                /**
                 * Handles &quot;data&quot; stream event
                 *
                 * @param {Buffer} chunk
                 * @private
                 */
                _onData: function(chunk) {
                    gpf.events.fire(&quot;data&quot;, {
                        buffer: gpf.node.buffer2JsArray(chunk)
                    }, this._getEventsHandler());
                },

                _onEnd: function () {
                    gpf.events.fire(&quot;eos&quot;, this._getEventsHandler());
                },

                _onError: function (error) {
                    gpf.events.fire(&quot;error&quot;, {
                        error: error
                    }, this._getEventsHandler());
                }

            },

            private: {

                /**
                 * @type {stream.Readable}
                 * @private
                 */
                _stream: null

            }

        });

        /**
         * Wraps a writable stream from NodeJS into a IReadableStream
         *
         * @class gpf.stream.NodeWritable
         * @implements gpf.interfaces.IReadableStream
         */
        gpf.define(&quot;gpf.node.WritableStream&quot;, {

            &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpfI.IWritableStream)],

            public: {

                /**
                 * @param {stream.Writable} stream
                 * @constructor
                 */
                constructor: function (stream) {
                    this._stream = stream;
                },

                /**
                 * @inheritDoc gpf.interfaces.IWritableStream:write
                 */
                &quot;[write]&quot;: [gpf.$ClassEventHandler()],
                write: function (int8buffer, eventsHandler) {
                    gpf.interfaces.ignoreParameter(int8buffer);
                    gpf.interfaces.ignoreParameter(eventsHandler);
                }

            },

            private: {

                /**
                 * @type {stream.Writable}
                 * @private
                 */
                _stream: null

            }

        });

    }

    //endregion

/*#ifndef(UMD)*/
}()); /* End of privacy scope */
/*#endif*/</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
