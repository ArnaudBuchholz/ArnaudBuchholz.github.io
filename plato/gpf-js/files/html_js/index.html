<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - html.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>html.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1301</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">75.93</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.86</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*#ifndef(UMD)*/
(function () { /* Begin of privacy scope */
    &quot;use strict&quot;;
/*#endif*/

    gpf.html = {

        // DOM standards
        ELEMENT_NODE: 1,
        TEXT_NODE: 3

    };

    var
        gpfI = gpf.interfaces,
        gpfFireEvent = gpf.events.fire;

    /**
     * Markdown to HTML converter using Parser interface
     * Inspired from http://en.wikipedia.org/wiki/Markdown,
     * improved with http://daringfireball.net/projects/markdown/syntax
     *
     * Weak -but working- implementation
     *
     * @class gpf.html.MarkdownParser
     */
    gpf.define(&quot;gpf.html.MarkdownParser&quot;, &quot;gpf.Parser&quot;, {

        public: {

            /**
             * @constructor
             */
            constructor: function () {
                this._super.apply(this, arguments);
                this._openedTags = [];
            }

        },

    /*
     * &#039;Grammar&#039;
     * init
     *      : &#039;\n&#039; init
     *      | &#039;#&#039; title1
     *      | &#039;*&#039; list
     *      | &#039;0&#039;...&#039;9&#039; list
     *      | &#039; &#039; init
     *      | content
     *
     * title1
     *      : &#039;#&#039; title2
     *      | text \n init
     * title2
     *      : &#039;#&#039; title3
     *      | text \n init
     * title3
     *       : text \n init
     *
     * list
     *      : &#039; &#039; content // confirmed
     *      | &#039;0&#039;...&#039;9&#039; list // If started with &#039;0&#039;...&#039;9&#039;
     *      | &#039;.&#039; content // confirmed, if started with &#039;0&#039;...&#039;9&#039;
     *      | &#039;*&#039; text &#039;*&#039; &#039;*&#039; // bold
     *      | content
     *
     * content
     *      : &#039;\n&#039; init
     *      | &#039;*&#039; italic
     *      | &#039;`&#039; monospace
     *      | &#039;[&#039; link
     *      | &#039;!&#039; image (if followed by &#039;[&#039;)
     *      | &#039;&amp;&#039; content
     *      | &#039;&lt;&#039; content
     *      | &#039;&gt;&#039; content
     *      | &#039;-&#039; escape
     *      | content
     *
     * escape
     *      : &#039;-&#039; &#039;-&#039; content
     *
     * italic
     *      : &#039;*&#039; content &#039;*&#039; &#039;*&#039; // bold
     *      : content &#039;*&#039; // italic
     *
     * monospace
     *      : (text) &#039;`&#039;
     *
     * link
     *      : (text) &#039;]&#039; &#039;(&#039; (text) &#039;)&#039;
     *
     * image
     *      : &#039;[&#039; link
     *      : content
     */

        protected: {

            //region Parser configuration
            _ignoreCarriageReturn: true, // \r

            /**
             * Initial state
             *
             * @param {String} char
             * @protected
             */
            _initialParserState: function (char) {
                var
                    newState,
                    tagsOpened = 0 &lt; this._openedTags.length;
                if (&quot;#&quot; === char) {
                    this._hLevel = 1;
                    newState = this._parseTitle;
                } else if (&quot;*&quot; === char || &quot;0&quot; &lt;= char &amp;&amp; &quot;9&quot; &gt;= char ) {
                    if (char !== &quot;*&quot;) {
                        this._numericList = 1;
                    } else {
                        this._numericList = 0;
                    }
                    newState = this._parseList;
                    tagsOpened = false; // Wait for disambiguation
                } else if (&quot; &quot; !== char &amp;&amp; &quot;\t&quot; !== char &amp;&amp; &quot;\n&quot; !== char) {
                    if (tagsOpened) {
                        this._output(&quot; &quot;);
                        tagsOpened = false; // Avoid closing below
                    } else {
                        this._openTag(&quot;p&quot;);
                    }
                    newState = this._parseContent(char);
                    if (!newState) {
                        newState = this._parseContent;
                    }
                }
                if (tagsOpened) {
                    this._closeTags();
                }
                return newState;
            },

            /**
             * @inheritdoc gpf.Parser:_finalizeParserState
             * @protected
             */
            _finalizeParserState: function () {
                this._closeTags();
            }

        },

        private: {

            /**
             * Stack of opened tags
             *
             * @type {String[}}
             * @private
             */
            _openedTags: [],

            /**
             * Close all opened tags
             *
             * @private
             */
            _closeTags: function () {
                var
                    tag;
                while (this._openedTags.length) {
                    tag = this._openedTags.pop();
                    this._output(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;);
                    if (&quot;p&quot; === tag) {
                        break;
                    }
                }
            },

            /**
             * Open (or concatenate) a list tag. This includes closing previous
             * list item (if any)
             *
             * @param {String} listTag
             * @private
             */
            _openList: function (listTag) {
                var
                    tag,
                    len = this._openedTags.length;
                while (len) {
                    tag = this._openedTags.pop();
                    --len;
                    this._output(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;);
                    if (&quot;li&quot; === tag) {
                        break;
                    }
                }
                if (len) {
                    tag = this._openedTags[len - 1];
                    if (tag !== listTag) {
                        this._openedTags.pop();
                        this._output(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;);
                    } else {
                        return;
                    }
                }
                this._openTag(listTag);
            },

            /**
             * Open/Close tag depending if it has been opened previously (if it
             * appears as the top tag on the stacked items)
             *
             * @param {String} tag
             * @private
             */
            _toggleTag: function (tag) {
                var
                    len = this._openedTags.length;
                if (len &amp;&amp; this._openedTags[len - 1] === tag) {
                    this._openedTags.pop();
                    this._output(&quot;&lt;/&quot; + tag + &quot;&gt;&quot;);
                } else {
                    this._openTag(tag);
                }
            },

            /**
             * Open a tag (and adds it to the stack)
             *
             * @param {String} tag
             * @private
             */
            _openTag: function (tag) {
                this._output(&quot;&lt;&quot; + tag + &quot;&gt;&quot;);
                this._openedTags.push(tag);
            },

            /**
             * H level (number of times the # char has been found)
             *
             * @type {Number}
             * @private
             */
            _hLevel: 1,

            /**
             * States title1, ... N
             *
             * @param {String} char
             * @private
             */
            _parseTitle: function (char) {
                if (&quot;#&quot; === char) {
                    ++this._hLevel;
                } else {
                    this._openTag(&quot;h&quot; + this._hLevel);
                    return this._parseText; // No formatting allowed in Hx
                }
            },

            /**
             * Indicates a numeric list element has been found
             *
             * @type {Boolean}
             * @private
             */
            _numericList: false,

            /**
             * State list
             * TODO: numbered list parsing is incorrect
             *
             * @param {String} char
             * @private
             */
            _parseList: function (char) {
                var
                    tagsOpened = 0 &lt; this._openedTags.length,
                    listTag;
                if (&quot; &quot; === char) {
                    // Start or append list
                    if (this._numericList) {
                        listTag = &quot;ol&quot;;
                    } else {
                        listTag = &quot;ul&quot;;
                    }
                    this._openList(listTag);
                    this._openTag(&quot;li&quot;);
                } else if (this._numericList
                    &amp;&amp; (&quot;0&quot; &lt;= char &amp;&amp; &quot;9&quot; &gt;= char || &quot;.&quot; === char)) {
                    return; // No state change
                } else if (&quot;*&quot; === char) {
                    if (tagsOpened) {
                        this._output(&quot; &quot;); // new line inside a paragraph
                    }
                    this._openTag(&quot;strong&quot;);
                }
                return this._parseContent;
            },

            /**
             * Handles &lt;, &gt; and &amp; HTML entities
             *
             * @param {String} char
             * @returns {boolean} The character has been processed
             * @private
             */
            _handleEntities: function (char) {
                if (&quot;&lt;&quot; === char) {
                    this._output(&quot;&amp;lt;&quot;);
                } else if (&quot;&gt;&quot; === char) {
                    this._output(&quot;&amp;gt;&quot;);
                } else if (&quot;&amp;&quot; === char) {
                    this._output(&quot;&amp;amp;&quot;);
                } else {
                    return false;
                }
                return true;
            },

            /**
             * Escape character
             *
             * @type {String}
             * @private
             */
            _escapeChar: &quot;&quot;,

            /**
             * Escape character count
             *
             * @type {Number}
             * @private
             */
            _escapeCount: 0,

            /**
             * State escape
             *
             * @param {String} char
             * @private
             */
            _parseEscape: function (char) {
                var
                    escapeChar = this._escapeChar,
                    count;
                if (char === escapeChar) {
                    count = ++this._escapeCount;
                    if (&quot;-&quot; === escapeChar &amp;&amp; 3 === count) {
                        this._output(&quot;&amp;mdash;&quot;);
                        return this._parseContent;
                    }
                } else {
                    count = this._escapeCount + 1;
                    while (--count) {
                        this._output(escapeChar);
                    }
                    this._setParserState(this._parseContent);
                    return this._parseContent(char);
                }
            },

            /**
             * State content
             *
             * @param {String} char
             * @private
             */
            _parseContent: function (char) {
                if (this._handleEntities(char)) {
                    return;
                }
                if (&quot;*&quot; === char) {
                    return this._parseItalic;
                } else if (&quot;`&quot; === char) {
                    this._toggleTag(&quot;code&quot;);
                    return this._parseMonospace;
                } else if (&quot;[&quot; === char) {
                    return this._startLink(0);
                } else if (&quot;!&quot; === char) {
                    return this._parseImage;
                } else if (&quot;-&quot; === char) {
                    this._escapeCount = 1;
                    this._escapeChar = &quot;-&quot;;
                    return this._parseEscape;
                } else if (&quot;\n&quot; === char) {
                    return null;
                } else {
                    this._output(char);
                }
            },

            /**
             * State italic
             *
             * @param {String} char
             * @private
             */
            _parseItalic: function (char) {
                if (&quot;*&quot; === char) {
                    this._toggleTag(&quot;strong&quot;);
                } else {
                    this._toggleTag(&quot;em&quot;);
                    this._output(char);
                }
                return this._parseContent;
            },

            /**
             * State text
             *
             * @param {String} char
             * @private
             */
            _parseText: function (char) {
                if (this._handleEntities(char)) {
                    return;
                }
                if (&quot;\n&quot; === char) {
                    // Ignore any formatting until \n
                    this._closeTags();
                    return null;
                } else {
                    this._output(char);
                }
            },

            /**
             * State monospace
             *
             * @param {String} char
             * @private
             */
            _parseMonospace: function (char) {
                if (&quot;`&quot; === char) {
                    this._toggleTag(&quot;code&quot;);
                    return this._parseContent;
                } else {
                    this._output(char);
                }
            },

            /**
             * 0 for A, 1 for IMG
             *
             * @type {Number}
             * @private
             */
            _linkType: 0,

            /**
             * 0: in text
             * 1: ], waiting for (
             * 2: in url
             *
             * @type {Number}
             * @private
             */
            _linkState: 0,

            /**
             * Link text
             *
             * @type {String[]}
             * @private
             */
            _linkText: [],

            /**
             * Link url
             *
             * @type {String[]}
             * @private
             */
            _linkUrl: [],

            /**
             * Prepare a link parsing
             *
             * @return {Function}
             * @private
             */
            _startLink: function (type) {
                this._linkType = type;
                this._linkState = 0;
                this._linkText = [];
                this._linkUrl = [];
                return this._parseLink;
            },

            /**
             * Finalize link parsing
             *
             * @return {Function}
             * @private
             */
            _finishLink: function () {
                var
                    url = this._linkUrl.join(&quot;&quot;),
                    text = this._linkText.join(&quot;&quot;);
                if (0 === this._linkType) {
                    this._output(&quot;&lt;a href=\&quot;&quot;);
                    this._output(url);
                    this._output(&quot;\&quot;&gt;&quot;);
                    this._output(text);
                    this._output(&quot;&lt;/a&gt;&quot;);
                } else if (1 ===  this._linkType) {
                    this._output(&quot;&lt;img src=\&quot;&quot;);
                    this._output(url);
                    this._output(&quot;\&quot; alt=\&quot;&quot;);
                    this._output(text);
                    this._output(&quot;\&quot; title=\&quot;&quot;);
                    this._output(text);
                    this._output(&quot;\&quot;&gt;&quot;);
                }
                return this._parseContent;
            },

            /**
             * State link
             * TODO improve?
             *
             * @param {String} char
             * @private
             */
            _parseLink: function (char) {
                var
                    linkState = this._linkState;
                if (&quot;]&quot; === char &amp;&amp; 0 === linkState) {
                    ++this._linkState;
                } else if (&quot;(&quot; === char &amp;&amp; 1 === linkState) {
                    ++this._linkState;
                } else if (&quot;)&quot; === char &amp;&amp; 2 === linkState) {
                    return this._finishLink();
                } else if (0 === linkState) {
                    this._linkText.push(char);
                } else if (2 === linkState) {
                    /*
                     * https://github.com/ArnaudBuchholz/gpf-js/issues/33
                     * Filter out tabs and carriage returns
                     */
                    if (-1 === &quot;\t\n&quot;.indexOf(char)) {
                        this._linkUrl.push(char);
                    }
                }
                // Else... nothing. do some kind of error handling?
            },

            /**
             * State image
             *
             * @param {String} char
             * @private
             */
            _parseImage: function (char) {
                if (&quot;[&quot; === char) {
                    return this._startLink(1);
                } else {
                    this._output(&quot;!&quot;);
                    this._setParserState(this._parseContent);
                    return this._parseContent(char);
                }
            }
        }

    });

    /**
     * HTML5 File to ReadableStream wrapper
     */
    gpf.define(&quot;gpf.html.File&quot;, {

        &quot;[Class]&quot;: [gpf.$InterfaceImplement(gpf.interfaces.ITextStream)],

        public: {

            constructor: function (file) {
                this._file = file;
            },

            /**
             * Name of the file
             *
             * @return {String}
             */
            name: function () {
                return this._file.name;
            },

            /**
             * Size of the file
             *
             * @return {Number}
             */
            size: function () {
                return this._file.size;
            },

            /**
             * @implements gpf.interfaces.ITextStream:read
             * @closure
             */
            read: function(count, eventsHandler) {
                var
                    that = this,
                    reader = this._reader,
                    left = this._file.size - this._pos,
                    blob;
                if (0 === left) {
                    gpfFireEvent.apply(this, [
                        gpfI.IReadableStream.EVENT_END_OF_STREAM,
                        eventsHandler
                    ]);
                    return;
                }
                this._eventsHandler = eventsHandler;
                if (null === reader) {
                    reader = this._reader = new FileReader();
                    reader.onloadend = function (event) {
                        that._onLoadEnd(event);
                    };
                }
                if (0 === count || count &gt; left) {
                    count = left;
                }
                blob = this._file.slice(this._pos, count);
                this._pos += count;
                reader.readAsArrayBuffer(blob);
            }

        },

        private: {

            /**
             * @type {File}
             * @private
             */
            _file: null,

            /**
             * @type {FileReader}
             * @private
             */
            _reader: null,

            /**
             * @type {Number}
             * @private
             */
            _pos: 0,

            /**
             * @type {gpf.events.Handler}
             * @private
             */
            _eventsHandler: null,

            /**
             * Wrapper for the onloadend event handler
             *
             * @param {DOM Event} event
             * @private
             */
            _onLoadEnd: function (event) {
                var
                    reader = event.target,
                    buffer,
                    len,
                    result,
                    idx;
                gpf.ASSERT(reader === this._reader,
                    &quot;Unexpected change of reader&quot;);
                if (reader.error) {
                    gpfFireEvent.apply(this, [
                        gpfI.IReadableStream.ERROR,
                        {
                            // According to W3C
                            // http://www.w3.org/TR/domcore/#interface-domerror
                            error: {
                                name: reader.error.name,
                                message: reader.error.message
                            }
                        },
                        this._eventsHandler
                    ]);
                } else if (reader.readyState === FileReader.DONE) {
                    buffer = new Int8Array(reader.result);
                    len = buffer.length;
                    result = [];
                    for (idx = 0; idx &lt; len; ++idx) {
                        result.push(buffer[idx]);
                    }
                    gpfFireEvent.apply(this, [
                        gpfI.IReadableStream.EVENT_DATA,
                        {
                            buffer: result
                        },
                        this._eventsHandler
                    ]);
                }
            }
        }

    });

    //region HTML Attributes

    var
        /**
         * HTML attribute (base class).
         *
         * @class gpf.attributes.HtmlAttribute
         * @extends gpf.attributes.Attribute
         * @private
         */
        _HtmBase = gpf._defAttr(&quot;HtmlAttribute&quot;, {}),

        /**
         * HTML Handler
         * Used to identify the member receiving the attached DOM inside an
         * object
         *
         * @class gpf.attributes.HtmlHandlerAttribute
         * @extends gpf.attributes.HtmlAttribute
         * @alias gpf.$HtmlHandler
         * @friend _handleHandlers
         * @friend _handleEvent
         */
        _HtmHandler = gpf._defAttr(&quot;$HtmlHandler&quot;, _HtmBase, {

            private: {

                _selector: &quot;&quot;,
                _globalSelector: false

            },

            protected: {

                /**
                 * Apply selection starting from the provided object
                 *
                 * @param {Object} domObject
                 * @returns {Object|undefined}
                 * @private
                 */
                _select: function (domObject) {
                    var selector = this._selector;
                    if (selector) {
                        if (this._globalSelector) {
                            return document.querySelector(selector);
                        } else {
                            return domObject.querySelector(selector);
                        }
                    }
                    return undefined;
                }

            },

            public: {

                /**
                 * @constructor
                 * @param {String} [selector=undefined] selector
                 * @param {Boolean} [global=false] global
                 */
                constructor: function (selector, global) {
                    if (selector) {
                        this._selector = selector;
                    }
                    if (undefined !== global) {
                        this._globalSelector = global === true;
                    }
                }

            }

        }),

        /**
         * HTML Event Mapper
         *
         * @class gpf.attributes.HtmlEventAttribute
         * @extends gpf.attributes.HtmlHandlerAttribute
         * @alias gpf.$HtmlEvent
         * @friend _handleEvent
         */
        _HtmEvent = gpf._defAttr(&quot;$HtmlEvent&quot;, _HtmHandler, {

            private: {

                _event: &quot;&quot;

            },

            public: {

                /**
                 * @constructor
                 * @param {String} event
                 * @param {String} [selector=undefined] selector
                 * @param {Boolean} [global=false] global
                 */
                constructor: function (event, selector, global) {
                    _HtmHandler.apply(this,[selector, global]);
                    this._event = event;
                }

            }

        });

    //endregion

    //region HTML event handlers mappers through attributes

    function _getHandlerAttribute(member, handlerAttributeArray) {
        var attribute;
        if (1 !== handlerAttributeArray.length()) {
            throw gpf.Error.HtmlHandlerMultiplicityError({
                member: member
            });
        }
        attribute = handlerAttributeArray.get(0);
        if (!(attribute instanceof _HtmEvent)) {
            return attribute;
        }
        return null;
    }

    function _findDefaultHandler(member, handlerAttributeArray) {
        var
            attribute = _getHandlerAttribute(member, handlerAttributeArray);
        if (attribute &amp;&amp; !attribute._selector) {
            return attribute;
        }
    }

    /**
     * Attach the selected DOM object to the object instance
     *
     * @param {Object} instance Object instance
     * @param {String|Object} [domSelection=undefined] domSelection DOM
     * selector, DOM object or nothing. If a DOM selector or object is provided
     * it will be associated to the object using the default $HtmlHandler
     * attribute.
     * Otherwise, this can be used to refresh the missing associations.
     *
     * @return {Object|undefined} the DOM object
     * @closure
     */
    gpf.html.handle = function (instance, domSelection) {
        var
            allAttributes = new gpf.attributes.Map(instance).filter(_HtmBase),
            handlerAttributes = allAttributes.filter(_HtmHandler),
            defaultHandler,
            eventAttributes;
        if (0 === handlerAttributes.count()) {
            throw gpf.Error.HtmlHandlerMissing();
        }
        defaultHandler = handlerAttributes.each(_findDefaultHandler);
        if (undefined === defaultHandler) {
            throw gpf.Error.HtmlHandlerNoDefault();
        }
        defaultHandler = defaultHandler.member();
        if (undefined === domSelection) {
            domSelection = instance[defaultHandler];
            gpf.ASSERT(domSelection, &quot;Handle not previously set&quot;);
        } else {
            if (&quot;string&quot; === typeof domSelection) {
                domSelection = document.querySelector(domSelection);
            }
            gpf.ASSERT(domSelection, &quot;Selector does not resolve to DOM&quot;);
            if (!domSelection) {
                return; // Nothing can be done
            }
            instance[defaultHandler] = domSelection;
        }
        // Process other handlers
        handlerAttributes.each(_handleHandlers, instance, [domSelection]);
        // Process event handlers
        eventAttributes = allAttributes.filter(_HtmEvent);
        if (0 &lt; eventAttributes.count()) {
            eventAttributes.each(_handleEvents, instance, [domSelection]);
        }
        return domSelection;
    };

    function _handleHandlers(member, handlerAttributeArray, domObject) {
        /*jshint -W040*/ // Used as a callback, this is the object instance
        var
            attribute = _getHandlerAttribute(member, handlerAttributeArray);
        if (!attribute || !attribute._selector) {
            return;
        }
        domObject = attribute._select(domObject);
        if (!domObject) {
            return;
        }
        this[member] = domObject;
        /*jshint +W040*/
    }

    /**
     * @param {String} member
     * @param {gpf.attributes.Array} attributesArray
     * @param {Object} domObject
     * @private
     */
    function _handleEvents(member, attributesArray, domObject) {
        /*jshint -W040*/ // Used as a callback, this is the object instance
        attributesArray.each(_handleEvent, this, [member, domObject]);
        /*jshint +W040*/
    }

    /**
     * @param {gpf.attributes.HtmlEventAttribute} eventAttribute
     * @param {String} member
     * @param {Object} domObject
     * @private
     */
    function _handleEvent(eventAttribute, member, domObject) {
        /*jshint -W040*/ // Used as a callback, this is the object instance
        var
            event = eventAttribute._event,
            _boundMember = member + &quot;:$HtmlEvent(&quot; + event + &quot;,&quot;
                + eventAttribute._selector + &quot;)&quot;;
        domObject = eventAttribute._select(domObject);
        if (!domObject) {
            return; // Nothing to do
        }
        if (!this[_boundMember]) {
            domObject.addEventListener(event, gpf.Callback.bind(this, member));
            this[_boundMember] = true;
        }
        /*jshint +W040*/
    }

    //endregion

    //region Common HTML helpers

    gpf.extend(gpf.html, {

        /**
         * Check if the DOM object has the requested class name(s)
         *
         * @param {Object} domObject
         * @param {String|String[]} toCheck
         * @return {Boolean}
         * @chainable
         */
        hasClass: function (domObject, toCheck) {
            var
                classNames,
                len,
                idx;
            if (&quot;string&quot; === typeof toCheck) {
                toCheck = [toCheck];
            }
            gpf.ASSERT(toCheck instanceof Array, &quot;Expected array&quot;);
            classNames = domObject.className.split(&quot; &quot;);
            len = toCheck.length;
            for (idx = 0; idx &lt; len; ++idx) {
                if (undefined !== gpf.test(classNames, toCheck[idx])) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Add/Remove the provided class name(s) to the DOM object
         *
         * @param {Object} domObject
         * @param {String|String[]} toAdd
         * @param {String|String[]} toRemove
         * @return {Object}
         * @chainable
         */
        alterClass: function (domObject, toAdd, toRemove) {
            var
                classNames,
                lengthBefore,
                len,
                idx;
            if (domObject.className) {
                classNames = domObject.className.split(&quot; &quot;);
            } else {
                classNames = [];
            }
            lengthBefore = classNames.length;
            // Remove first (faster)
            if (undefined !== toRemove) {
                if (&quot;string&quot; === typeof toRemove) {
                    toRemove = [toRemove];
                }
                gpf.ASSERT(toRemove instanceof Array, &quot;Expected array&quot;);
                len = toRemove.length;
                for (idx = 0; idx &lt; len; ++idx) {
                    gpf.clear(classNames, toRemove[idx]);
                }
            }
            // Then add
            if (undefined !== toAdd) {
                if (&quot;string&quot; === typeof toAdd) {
                    toAdd = [toAdd];
                }
                gpf.ASSERT(toAdd instanceof Array, &quot;Expected array&quot;);
                len = toAdd.length;
                for (idx = 0; idx &lt; len; ++idx) {
                    gpf.set(classNames, toAdd[idx]);
                }
            }
            // Avoid resource consuming refresh if nothing changed
            if (lengthBefore !== classNames.length) {
                domObject.className = classNames.join(&quot; &quot;);
            }
            return domObject;
        },

        /**
         * Add the provided class name(s) to the DOM object
         *
         * @param {Object} domObject
         * @param {String|String[]} toAdd
         * @return {Object}
         * @chainable
         */
        addClass: function (domObject, toAdd) {
            return gpf.html.alterClass(domObject, toAdd, undefined);
        },

        /**
         * Remove the provided class name(s) to the DOM object
         *
         * @param {Object} domObject
         * @param {String|String[]} toRemove
         * @return {Object}
         * @chainable
         */
        removeClass: function (domObject, toRemove) {
            return gpf.html.alterClass(domObject, undefined, toRemove);
        }

    });

    //endregion

    //region Responsive page framework

    var
        /**
         * Responsive framework broadcaster
         *
         * @type {gpf.events.Broadcaster}
         * @private
         */
        _broadcaster = null,

        /**
         * Handle of a dynamic CSS section used for some responsive helpers
         *
         * @type {Object}
         * @private
         */
        _dynamicCss = null,

        /**
         * gpf-top
         *
         * @type {boolean}
         * @private
         */
        _monitorTop = false,

        /**
         * Current page width
         *
         * @type {Number}
         * @private
         */
        _width,

        /**
         * Current page height
         *
         * @type {Number}
         * @private
         */
        _height,

        /**
         * Current page scroll Y
         *
         * @type {Number}
         * @private
         */
        _scrollY,

        /**
         * Current page orientation
         *
         * @type {String}
         * @private
         */
        _orientation = &quot;&quot;;

    function _updateDynamicCss() {
        var content = [];
        if (_monitorTop) {
            content.push(&quot;.gpf-top { top: &quot;, _scrollY, &quot;px; }\n&quot;);
        }
        _dynamicCss.innerHTML = content.join(&quot;&quot;);
    }

    /**
     * HTML Event &quot;resize&quot; listener
     *
     * @private
     */
    function _onResize() {
        _width = window.innerWidth;
        _height = window.innerHeight;
        var
            orientation,
            orientationChanged = false,
            toRemove = [],
            toAdd = [];
        if (_width &gt; _height) {
            orientation = &quot;gpf-landscape&quot;;
        } else {
            orientation = &quot;gpf-portrait&quot;;
        }
        if (_orientation !== orientation) {
            toRemove.push(_orientation);
            _orientation = orientation;
            toAdd.push(orientation);
            orientationChanged = true;
        }
        gpf.html.alterClass(document.body, toAdd, toRemove);
        _broadcaster.broadcastEvent(&quot;resize&quot;, {
            width: _width,
            height: _height
        });
        if (orientationChanged) {
            _broadcaster.broadcastEvent(&quot;rotate&quot;, {
                orientation: orientation
            });
        }
    }

    /**
     * HTML Event &quot;scroll&quot; listener
     *
     * @private
     */
    function _onScroll() {
        _scrollY = window.scrollY;
        if (_monitorTop &amp;&amp; _dynamicCss) {
            _updateDynamicCss();
        }
        _broadcaster.broadcastEvent(&quot;scroll&quot;, {
            top: _scrollY
        });
    }

    /**
     * Generates the initial calls for responsive framework
     *
     * @private
     */
    function _init() {
        _onResize();
        _onScroll();
    }

    /**
     * Install (if not done) responsive framework handlers:
     * - Listen to the resize handlers and insert body css classNames according
     *   to the current configuration:
     *
     * @param {Object} options
     * &lt;ul&gt;
     *     &lt;li&gt;{Boolean} [monitorTop=undefined] monitorTop If true, a CSS class
     *     gpf-top is defined and maintained to the vertical offset of top
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     * @return {gpf.events.Broadcaster}
     */
    gpf.html.responsive = function (options) {
        var
            needDynamicCss,
            headTag;
        if (options &amp;&amp; undefined !== options.monitorTop) {
            _monitorTop = options.monitorTop;
        }
        needDynamicCss = _monitorTop;
        if (needDynamicCss) {
            if (!_dynamicCss) {
                headTag = document.getElementsByTagName(&quot;head&quot;)[0]
                          || document.documentElement;
                _dynamicCss = document.createElement(&quot;style&quot;);
                _dynamicCss.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
                _dynamicCss = headTag.appendChild(_dynamicCss);
            }
        } else if (_dynamicCss) {
            // Remove
            _dynamicCss.parentNode.removeChild(_dynamicCss);
            _dynamicCss = null;
        }
        if (null === _broadcaster) {
            _broadcaster = new gpf.events.Broadcaster([

                /**
                 * @event resize
                 * @eventParam {Number} width
                 * @eventParam {Number} height
                 */
                &quot;resize&quot;,

                /**
                 * @event rotate
                 * @eventParam {String} orientation
                 */
                &quot;rotate&quot;,

                /**
                 * @event scroll
                 * @eventParam {Number} top
                 */
                &quot;scroll&quot;
            ]);
            // Use the document to check if the framework is already installed
            window.addEventListener(&quot;resize&quot;, _onResize);
            window.addEventListener(&quot;scroll&quot;, _onScroll);
            // First execution (deferred to let caller register on them)
            gpf.defer(_init, 0);
        }
        return _broadcaster;
    };

    //endregion

    //region Handles gpf-loaded tag

    var
        _gpfIncludes = [];

    function _searchGpfLoaded () {
        /**
         * Look for a script tag with the gpf-loaded attribute
         */
        var scripts = document.getElementsByTagName(&quot;script&quot;),
            len = scripts.length,
            idx,
            script,
            gpfLoaded;
        for (idx = 0; idx &lt; len; ++idx) {
            script = scripts[idx];
            gpfLoaded = script.getAttribute(&quot;gpf-loaded&quot;);
            if (gpfLoaded) {
                script.removeAttribute(&quot;gpf-loaded&quot;);
                gpfLoaded = gpfLoaded.split(&quot;,&quot;);
                len = gpfLoaded.length;
                for (idx = 0; idx &lt; len; ++idx) {
                    _gpfIncludes.push(gpfLoaded[idx]);
                }
            }
        }
        // Load the scripts sequentially
        if (_gpfIncludes.length) {
            _loadGpfIncludes();
        }
    }

    function _loadGpfIncludeFailed(event) {
        console.error(&quot;gpf-loaded: failed to include &#039;&quot; + event.get(&quot;url&quot;)
            + &quot;&#039;&quot;);
    }

    function _loadGpfIncludes() {
        if (!_gpfIncludes.length) {
            return;
        }
        var src = _gpfIncludes.shift();
        gpf.http.include(src, {
            load: _loadGpfIncludes,
            error:_loadGpfIncludeFailed
        });
    }

    if (&quot;browser&quot; === gpf.host() || &quot;phantomjs&quot; === gpf.host()) {
        _searchGpfLoaded();
    }

    //endregion

/*#ifndef(UMD)*/
}()); /* End of privacy scope */
/*#endif*/</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
