<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - params.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>params.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">53.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">404</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.99</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*#ifndef(UMD)*/
(function () { /* Begin of privacy scope */
    &quot;use strict&quot;;
/*#endif*/

    gpf.define(&quot;gpf.Parameter&quot;, {

        private: {

            /**
             * Name
             *
             * @type {String}
             * @private
             */
            &quot;[_name]&quot;: [gpf.$ClassProperty(), gpf.$XmlAttribute(&quot;name&quot;)],
            _name: &quot;&quot;,

            /**
             * Description
             *
             * @type {String}
             * @private
             */
            &quot;[_description]&quot;: [gpf.$ClassProperty(),
                gpf.$XmlElement(&quot;description&quot;)],
            _description: &quot;&quot;,

            /**
             * Type
             *
             * @type {String} see gpf.Parameter.TYPE_xxx
             * @private
             */
            &quot;[_type]&quot;: [gpf.$ClassProperty(), gpf.$XmlAttribute(&quot;type&quot;)],
            _type: &quot;string&quot;,

            /**
             * Is required
             *
             * @type {Boolean}
             * @private
             */
            &quot;[_required]&quot;: [gpf.$ClassProperty(),
                gpf.$XmlAttribute(&quot;required&quot;)],
            _required: false,

            /**
             * Default value to apply if not specified
             *
             * @type {*}
             * @private
             */
            &quot;[_defaultValue]&quot;: [gpf.$ClassProperty(),
                gpf.$XmlElement(&quot;default&quot;)],
            _defaultValue: undefined,

            /**
             * Prefix used to locate parameter in the given parameter list.
             * NOTE: required parameter may not specify any prefix: they are
             * have to be specified in the correct order (and they can&#039;t be
             * multiple)
             *
             * @type {String}
             * @private
             */
            &quot;[_prefix]&quot;: [gpf.$ClassProperty(), gpf.$XmlAttribute(&quot;prefix&quot;)],
            _prefix: &quot;&quot;,

            /**
             * Multiple parameter means they can be specified more than once.
             * The parameter value would be then an array.
             *
             * @type {Boolean}
             * @private
             */
            &quot;[_multiple]&quot;: [gpf.$ClassProperty(),
                gpf.$XmlAttribute(&quot;multiple&quot;)],
            _multiple: false,

            /**
             * Hidden parameters are not displayed when calling usage
             *
             * @type {Boolean}
             * @private
             */
            &quot;[_hidden]&quot;: [gpf.$ClassProperty(), gpf.$XmlAttribute(&quot;hidden&quot;)],
            _hidden: false
        },

        public: {

        },

        static: {

            VERBOSE: &quot;verbose&quot;,
            HELP: &quot;help&quot;,

            TYPE_BOOLEAN: &quot;boolean&quot;,
            TYPE_NUMBER: &quot;number&quot;,
            TYPE_STRING: &quot;string&quot;,

            DEFAULTS: {
                &quot;string&quot;: &quot;&quot;,
                &quot;boolean&quot;: false,
                &quot;number&quot;: 0
            },

            /**
             * Create a list of parameters
             *
             * @param {Object[]} definitions
             * @return {gpf.Parameter[]}
             */
            create: function (definitions) {
                var
                    result = [],
                    len = definitions.length,
                    idx,
                    definition;
                for (idx = 0; idx &lt; len; ++idx) {
                    definition = definitions[idx];
                    if (!(definition instanceof gpf.Parameter)) {
                        definition = this._createFromObject(definition);
                    }
                    result.push(definition);
                }
                return result;
            },

            /**
             * Create a parameter from the definition object
             *
             * @param {Object} definition
             * @return {gpf.Parameter}
             * @private
             */
            _createFromObject: function (definition) {
                var
                    result = new gpf.Parameter(),
                    typeDefaultValue;
                if (definition === gpf.Parameter.VERBOSE
                    || definition.prefix === gpf.Parameter.VERBOSE) {
                    definition = {
                        name: &quot;verbose&quot;,
                        description: &quot;Enable verbose mode&quot;,
                        type: &quot;boolean&quot;,
                        defaultValue: false,
                        prefix: gpf.Parameter.VERBOSE
                    };
                } else if (definition === gpf.Parameter.HELP
                           || definition.prefix === gpf.Parameter.HELP) {
                    definition = {
                        name: &quot;help&quot;,
                        description: &quot;Display help&quot;,
                        type: &quot;boolean&quot;,
                        defaultValue: false,
                        prefix: gpf.Parameter.HELP
                    };
                }
                gpf.json.load(result, definition);
                // name is required
                if (!result._name) {
                    throw gpf.Error.ParamsNameRequired();
                }
                if (!result._multiple) {
                    /**
                     * When multiple is used, the default value will be an array
                     * if not specified.
                     * Otherwise, we get the default value based on the type
                     */
                    typeDefaultValue = this.DEFAULTS[result._type];
                    if (undefined === typeDefaultValue) {
                        throw gpf.Error.ParamsTypeUnknown();
                    }
                    if (result.hasOwnProperty(&quot;_defaultValue&quot;)) {
                        result._defaultValue =
                            gpf.value(result._defaultValue, typeDefaultValue,
                                result._type);
                    }
                }
                return result;
            },

            /**
             * Helper used to manipulate the list of parameters: retrieve one
             * using prefix. If no prefix is specified or a number is used, get
             * the first parameter with no prefix (starting at N if a number was
             * used).
             *
             * @param {gpf.Parameter[]} parameters
             * @param {String|Number} [prefix=0] prefix
             */
            getOnPrefix: function (parameters, prefix) {
                var
                    len,
                    idx,
                    parameter;
                if (undefined === prefix) {
                    prefix = 0;
                }
                len = parameters.length;
                if (&quot;number&quot; === typeof prefix) {
                    idx = prefix;
                    prefix = &quot;&quot;;
                } else {
                    idx = 0;
                }
                for (; idx &lt; len; ++idx) {
                    parameter = parameters[idx];
                    if (parameter._prefix === prefix) {
                        return parameter;
                    }
                }
                return null;
            },

            /**
             * Helper used to manipulate the list of parameters: retrieve one
             * using name.
             *
             * @param {gpf.Parameter[]} parameters
             * @param {String} name
             */
            getByName: function (parameters, name) {
                var
                    len,
                    idx,
                    parameter;
                len = parameters.length;
                for (idx = 0; idx &lt; len; ++idx) {
                    parameter = parameters[idx];
                    if (parameter._name === name) {
                        return parameter;
                    }
                }
                return null;
            },

            /**
             * Parse the arguments and return an object with the
             * recognized parameters. Throws an error if required parameters
             * are missing.
             *
             * @param {gpf.Parameter[]|Object[]} parameters
             * @param {String[]} argumentsToParse
             * @return {Object}
             */
            parse: function (parameters, argumentsToParse) {
                var
                    result = {},
                    len,
                    idx,
                    argument,
                    parameter,
                    name,
                    lastNonPrefixIdx = 0;
                parameters = gpf.Parameter.create(parameters);
                len = argumentsToParse.length;
                for (idx = 0; idx &lt; len; ++idx) {
                    // Check if a prefix was used and find parameter
                    argument = this.getPrefixValuePair(argumentsToParse[idx]);
                    if (argument instanceof Array) {
                        parameter = this.getOnPrefix(parameters, argument[0]);
                        argument = argument[1];
                    } else {
                        parameter = this.getOnPrefix(parameters,
                            lastNonPrefixIdx);
                        lastNonPrefixIdx = parameters.indexOf(parameter) + 1;
                    }
                    // If no parameter corresponds, ignore
                    if (!parameter) {
                        // TODO maybe an error might be more appropriate
                        continue;
                    }
                    // Sometimes, the prefix might be used without value
                    if (undefined === argument) {
                        if (&quot;boolean&quot; === parameter._type) {
                            argument = !parameter._defaultValue;
                        } else {
                            // Nothing to do with it
                            // TODO maybe an error might be more appropriate
                            continue;
                        }
                    }
                    // Convert the value to match the type
                    // TODO change when type will be an object
                    argument = gpf.value(argument, parameter._defaultValue,
                        parameter._type);
                    // Assign the corresponding member of the result object
                    name = parameter._name;
                    if (parameter._multiple) {
                        if (undefined === result[name]) {
                            result[name] = [];
                        }
                        result[name].push(argument);
                        if (parameter._prefix === &quot;&quot;) {
                            --lastNonPrefixIdx;
                        }

                    } else {
                        // The last one wins
                        result[name] = argument;
                    }
                }
                this._finalizeParse(parameters, result);
                return result;
            },

            /**
             * Check that all required fields are set,
             * apply default values
             *
             * @param {gpf.Parameter[]} parameters
             * @param {Object} result
             * @private
             */
            _finalizeParse: function (parameters, result) {
                var
                    len,
                    idx,
                    parameter,
                    name,
                    value;
                len = parameters.length;
                for (idx = 0; idx &lt; len; ++idx) {
                    parameter = parameters[idx];
                    name = parameter._name;
                    if (undefined === result[name]) {
                        if (parameter._required) {
                            throw gpf.Error.ParamsRequiredMissing({
                                name: name
                            });
                        }
                        value = parameter._defaultValue;
                        if (undefined !== value) {
                            if (parameter._multiple) {
                                value = [value];
                            }
                            result[name] = value;
                        } else if (parameter._multiple) {
                            result[name] = [];
                        }
                    }
                }
            },

            /**
             * Split the argument in a prefix / value pair if it makes sense.
             * Otherwise, only the value is returned.
             *
             * Recognized prefixes:
             * &lt;ul&gt;
             *     &lt;li&gt;-{prefix}[:value]&lt;/li&gt;
             *     &lt;li&gt;{prefix}=value&lt;/li&gt;
             * &lt;/ul&gt;
             *
             * @param {String} argument
             * @return {String[]|String}
             */
            getPrefixValuePair: function (argument) {
                var pos;
                // -{prefix}:
                if (argument.charAt(0) === &quot;-&quot;) {
                    argument = argument.substr(1);
                    pos = argument.indexOf(&quot;:&quot;);
                    if (-1 &lt; pos) {
                        return [
                            argument.substr(0, pos),
                            argument.substr(pos + 1)
                        ];
                    } else {
                        return [argument];
                    }
                }
                // {prefix}=
                pos = argument.indexOf(&quot;=&quot;);
                if (-1 &lt; pos) {
                    return [
                        argument.substr(0, pos),
                        argument.substr(pos + 1)
                    ];
                }
                // Default
                return argument;
            },

            /**
             * Build the usage string for these parameters
             *
             * @param {gpf.Parameter[]} parameters
             * @return {String}
             */
            usage: function (parameters) {
                gpf.interface.ignoreParameter(parameters);
                return &quot;&quot;;
            }

        }

    });

/*#ifndef(UMD)*/
}()); /* End of privacy scope */
/*#endif*/</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
