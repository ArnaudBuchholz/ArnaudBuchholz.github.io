<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - src/path_matcher.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/path_matcher.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.82</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">302</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.06</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">1.23</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*#ifndef(UMD)*/
&quot;use strict&quot;;
/*global _gpfAssert*/ // Assertion method
/*global _gpfExtend*/ // gpf.extend
/*global _gpfPathDecompose*/ // Normalize path and returns an array of parts
/*#endif*/

// Split the part to be processed in _GpfPathMatcher#_matchName
function _gpfPatternPartSplit (part) {
    return part.split(&quot;*&quot;);
}

/**
 * @param {String} pattern
 *
 * @class _GpfLikeContext
 * @constructor
 */
function _GpfPathMatcher (pattern) {
    /*jshint validthis:true*/
/*#ifdef(DEBUG)*/
    this._dbgSource = pattern;
/*#endif*/

    if (&quot;!&quot; === pattern.charAt(0)) {
        this.negative = true;
        pattern = pattern.substr(1);
    }

    /**
     * if any use of &quot;**&quot;, split the pattern in two:
     * - the before part: start
     * - the after part: end
     * (otherwise, it is only the before part)
     */
    var pos = pattern.indexOf(&quot;**&quot;);
    if (-1 === pos) {
        this.start = pattern
            .split(&quot;/&quot;)
            .map(_gpfPatternPartSplit);
    } else {
        if (0 &lt; pos) {
            _gpfAssert(pattern.charAt(pos - 1) === &quot;/&quot;, &quot;** must be preceded by /&quot;);
            this.start = pattern
                .substr(0, pos - 1) // skip /
                .split(&quot;/&quot;)
                .map(_gpfPatternPartSplit);
        }
        if (pos &lt; pattern.length - 2) {
            _gpfAssert(pattern.charAt(pos + 2) === &quot;/&quot;, &quot;** must be followed by /&quot;);
            this.end = pattern
                .substr(pos + 3) // skip /
                .split(&quot;/&quot;)
                .map(_gpfPatternPartSplit)
                .reverse();
        }
    }
}

/**
 * Convert - if necessary - the pattern parameter
 *
 * @param {_GpfPathMatcher|String} pattern
 * @return {_GpfPathMatcher}
 */
function _gpfPathMatchCompilePattern (pattern) {
    if (pattern instanceof _GpfPathMatcher) {
        return pattern;
    }
    return new _GpfPathMatcher(pattern);
}

/**
 * Convert - if necessary - the pattern parameter
 *
 * @param {Array|String} pattern
 * @return {_GpfPathMatcher[]}
 */
function _gpfPathMatchCompilePatterns (pattern) {
    if (pattern instanceof Array) {
        return pattern.map(_gpfPathMatchCompilePattern);
    }
    return [_gpfPathMatchCompilePattern(pattern)];
}

/**
 * Match a path item
 *
 * @param pathMatcher
 * @this An object containing
 * - {String[]} parts the path being tested split in parts
 * - {Boolean} [result=undefined] result the result
 */
function _gpfPathMatchApply (pathMatcher) {
    /*jshint validthis:true*/
    var negative = pathMatcher.negative;
    if (pathMatcher.match(this.parts)) {
        this.result = !negative;
        return false; // Stop the main loop
    }
    if (negative) {
        this.result = true;
        return false; // Stop the main loop
    }
    return true; // continue
}

/**
 * Match the pattern with the path
 * @param {Array|String} pattern
 * @param {String} path
 * @return {Boolean|undefined}
 */
function _gpfPathMatch (pattern, path) {
    var parts = _gpfPathDecompose(path),
        matchers = _gpfPathMatchCompilePatterns(pattern),
        scope = {
            parts: parts
        };
    matchers.every(_gpfPathMatchApply, scope);
    return scope.result;
}

_GpfPathMatcher.prototype = {

    constructor: _GpfPathMatcher,

/*#ifdef(DEBUG)*/

    // Source of the pattern
    _dbgSource: &quot;&quot;,

/*#endif*/


    // Indicate the pattern started with !
    negative: false,

    /**
     * List of name patterns to be applied on the beginning of the path
     *
     * @type {String[]}
     */
    start: null,

    /**
     * List of name patterns to be applied on the end of the path (note they are in the reverse order)
     *
     * @type {String[]}
     */
    end: null,

    /**
     * When no * is used, the namePattern must exactly match the part.
     * Otherwise the * represents a variable part in the part.
     * It may contain as many variable part as necessary.
     *
     * a*b  matches     (start)a(anything)b(end)
     * *b   matches     b(end)
     * a*   matches     (start)a
     *
     * @param {String[]} fixedPatterns
     * @param {String} part
     */
    _matchName: function (fixedPatterns, part) {
        var
            len = fixedPatterns.length,
            idx,
            fixedPattern,
            pos = 0; // end
        for (idx = 0; idx &lt; len; ++idx) {
            fixedPattern = fixedPatterns[idx];
            // an empty pattern correspond to a star position
            if (fixedPattern) {
                pos = part.indexOf(fixedPattern, pos);
                // part not found means not matching
                if (-1 === pos) {
                    return false;
                }
                // the first part must match the beginning
                if (0 === idx &amp;&amp; 0 &lt; pos) {
                    return false;
                }
            }
        }
        /**
         * fixedPattern represents the last pattern used (and matching)
         * If empty, we match (because we don&#039;t care about the end)
         * Otherwise, it should leads us to the end of the part.
         */
        return !fixedPattern || pos + fixedPattern.length === part.length;
    },

    _matchStart: function (context) {
        var parts = context.parts,
            partsLen = parts.length,
            startPos = context.startPos,
            array = this.start,
            len = array.length,
            idx;
        for (idx = 0; idx &lt; len; ++idx) {
            if (this._matchName(array[idx], parts[startPos])) {
                if (++startPos &gt;= partsLen) {
                    // Match if last part of the start and no end
                    return idx === len - 1 &amp;&amp; !this.end;
                }
            } else {
                return false;
            }
        }
        context.startPos = startPos;
        return undefined;
    },

    _matchEnd: function (context) {
        var parts = context.parts,
            startPos = context.startPos,
            endPos = parts.length - 1,
            array = this.end,
            len = array.length,
            idx;
        for (idx = 0; idx &lt; len; ++idx) {
            if (-1 &lt; endPos &amp;&amp; this._matchName(array[idx], parts[endPos])) {
                if (endPos-- &lt; startPos) {
                    return false;
                }
            } else {
                return false;
            }
        }
        return undefined;
    },

    /**
     * Matches the provided path
     *
     * @param {String[]} parts
     * @return {Boolean}
     */
    match: function (parts) {
        var result,
            context = {
                parts: parts,
                startPos: 0
            };
        if (this.start) {
            result = this._matchStart(context);
            if (undefined !== result) {
                return result;
            }
        }
        if (this.end) {
            result = this._matchEnd(context);
            if (undefined !== result) {
                return result;
            }
        }
        return true;
    }

};

_gpfExtend(gpf.path, {

    /**
     * Matches the provided path
     *
     * PATTERN FORMAT
     * - An optional prefix &quot;!&quot; negates the pattern
     * - Path separator are /
     * - In a DOS environment, path is transformed to lowercase and path separators are converted to / (hence the
     *   pattern remains the same)
     * - A leading slash matches the beginning of the pathname. For example, &quot;/*.c&quot; matches &quot;cat-file.c&quot; but not
     *   &quot;mozilla-sha1/sha1.c&quot;.
     * - Two consecutive asterisks (&quot;**&quot;) in patterns matched against full pathname may have special meaning:
     *   - A leading &quot;**&quot; followed by a slash means match in all directories.
     *     For example, &quot;**&quot; + &quot;/foo&quot; matches file or directory &quot;foo&quot; anywhere, the same as pattern &quot;foo&quot;.
     *     &quot;**&quot; + &quot;/foo/bar&quot; matches file or directory &quot;bar&quot; anywhere that is directly under directory &quot;foo&quot;.
     *   - A trailing &quot;/**&quot; matches everything inside. For example, &quot;abc/**&quot; matches all files inside directory &quot;abc&quot;
     *   - A slash followed by two consecutive asterisks then a slash matches zero or more directories.
     *     For example, &quot;a/**&quot; + &quot;/b&quot; matches &quot;a/b&quot;, &quot;a/x/b&quot;, &quot;a/x/y/b&quot; and so on.
     * Other consecutive asterisks are considered invalid.
     *
     * @param {Array|String} pattern
     * @param {String} path
     * @return {Boolean}
     */
    match: function (pattern, path) {
        return _gpfPathMatch(pattern, path) || false;
    },

    /**
     * Process the pattern and return an array that can be used in match.
     * NOTE this is not mandatory but if you reuse the same pattern multiple times, this will make it more efficient
     *
     * @param {Array|String} pattern
     * @return {Array}
     */
    compileMatchPattern: function (pattern) {
        return _gpfPathMatchCompilePatterns(pattern);
    }

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
